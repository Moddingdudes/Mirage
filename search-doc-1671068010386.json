[{"title":"Overview","type":0,"sectionRef":"#","url":"docs/components/","content":"Overview These core components are included in Mirage: Network Animator The Network Animator component allows you to synchronize animation states for networked objects. It synchronizes state and parameters from an Animator Controller. Network Authenticator Network Authenticators facilitate the integration of user accounts and credentials into your application. Network Discovery Network Discovery uses a UDP broadcast on the LAN enabling clients to find the running server and connect to it. Network Identity The Network Identity component is at the heart of the Mirage networking high-level API. It controls a game object’s unique identity on the network, and it uses that identity to make the networking system aware of the game object. It offers two different options for configuration and they are mutually exclusive, which means either one of the options or none can be checked. Network LogSettings Adds logging levels per class for Mirror components Network Manager The Network Manager is a component for managing the networking aspects of a multiplayer game. Network Manager HUD The Network Manager HUD is a quick-start tool to help you start building your multiplayer game straight away, without first having to build a user interface for game creation/connection/joining. It allows you to jump straight into your gameplay programming and means you can build your own version of these controls later in your development schedule. Network Match Checker The Network Match Checker component controls the visibility of networked objects based on match id. Network Ping DisplayNetwork Ping Display shows the Ping time for clients using OnGUI Network Proximity Checker The Network Proximity Checker component controls the visibility of game objects for network clients, based on proximity to players. Network RigidbodyThe Network Rigidbody synchronizes velocity and other properties of a rigidbody across the network. Network Room Manager The Network Room Manager is an extension component of Network Manager that provides a basic functional room. Network Room Player The Network Room Player is a component that's required on Player prefabs used in the Room Scene with the Network Room Manager above. Network Scene Checker The Network Scene Checker component controls the visibility of networked objects between scenes. Network Start Position Network Start Position is used by the Network Manager when creating character objects. The position and rotation of the Network Start Position are used to place the newly created character object. Network Transform The Network Transform component synchronizes the movement and rotation of game objects across the network. Note that the network Transform component only synchronizes spawned networked game objects. Network Transform Child The Network Transform Child component synchronizes the position and rotation of the child game object of a game object with a Network Transform component.","keywords":""},{"title":"Authentication","type":0,"sectionRef":"#","url":"docs/components/authenticators/","content":"","keywords":""},{"title":"Encryption Notice​","type":1,"pageTitle":"Authentication","url":"docs/components/authenticators/#encryption-notice","content":"By default Mirage is not encrypted, so if you want to do authentication through Mirage, we highly recommend you use a transport that supports encryption. "},{"title":"Basic Authenticator​","type":1,"pageTitle":"Authentication","url":"docs/components/authenticators/#basic-authenticator","content":"Basic Authenticator Mirage includes a Basic Authenticator in the Mirage/Authenticators folder which just uses a simple password. This will only allow people with the password to join the server. For example, a password on a hosted game so that only friends can join. "},{"title":"Custom Authenticators​","type":1,"pageTitle":"Authentication","url":"docs/components/authenticators/#custom-authenticators","content":"To Create a custom authenticator implement the NetworkAuthenticator abstract class and override the ServerAuthenticated and ClientAuthenticated methods. After authenticating a player call either ServerAccept, ServerReject, ClientAccept or ClientReject depending if running on Server or Client and if you it was successful or not. Calling the Accept method will cause mirage to invoke the OnServerAuthenticated or OnClientAuthenticated events. Subscribe to OnServerAuthenticated and OnClientAuthenticated events if you wish to perform additional steps after authentication. Calling the Reject method will cause the player to be disconnected after a short delay. When Rejecting, It is a good idea to send a message to the client to tell them that authentication failed, for example: &quot;Server password invalid&quot; or &quot;Login failed&quot;. "},{"title":"Check if a player is authenticated​","type":1,"pageTitle":"Authentication","url":"docs/components/authenticators/#check-if-a-player-is-authenticated","content":"After a player has been accepted IsAuthenticated will be set to true. The bool can be used alongside AuthenticationData to check if a user is allowed to do certain actions. "},{"title":"Storing Authentication data​","type":1,"pageTitle":"Authentication","url":"docs/components/authenticators/#storing-authentication-data","content":"The NetworkPlayer object has an AuthenticationData property that can be used to store any data related to authentication, such as account id, tokens, or players username. This property is of type object so can be set to any object and can be cast back to that object when you need to read the data. if (player.IsAuthenticated) { var loginData = (MyLogInData)player.AuthenticationData; var username = loginData.Username; // do something with username :) }  Now that you have the foundation of a custom Authenticator component, the rest is up to you. You can exchange any number of custom messages between the server and client as necessary to complete your authentication process before approving the client. Authentication can also be extended to character selection and customization, just by crafting additional messages and exchanging them with the client before completing the authentication process. This means this process takes place before the client player actually enters the game or changes to the Online scene. If you write a good authenticator, consider sharing it with other users or contributing it to the Mirage project. "},{"title":"Basic Authenticator","type":0,"sectionRef":"#","url":"docs/components/authenticators/basic-authenticator","content":"Basic Authenticator Mirage includes a Basic Authenticator in the Mirage / Authenticators folder which just uses a simple username and password. Drag the Basic Authenticator script to the inspector of the object in your scene that has Network ManagerThe Basic Authenticator component will automatically be assigned to the Authenticator field in Network Manager When you're done, it should look like this: note You don't need to assign anything to the event lists unless you want to subscribe to the events in your own code for your own purposes. Mirage has internal listeners for both events.","keywords":""},{"title":"Network Animator","type":0,"sectionRef":"#","url":"docs/components/network-animator","content":"","keywords":""},{"title":"Details​","type":1,"pageTitle":"Network Animator","url":"docs/components/network-animator#details","content":"The Network Animator ensures the synchronization of game object animation across the network, meaning that all players see the animation happen at the same. There are two kinds of authority for networked animation (see documentation on Network Authority): note Animator Triggers are not synced directly. Call NetworkAnimator.SetTrigger instead. A game object with authority can use the SetTrigger function to fire an animation trigger on other clients. If the game object has authority over the client, you should animate it locally on the client that owns the game object. That client sends the animation state information to the server, which broadcasts it to all the other clients. For example, this may be suitable for player characters with client authority.If the game object has authority on the server, then you should animate it on the server. The server then sends state information to all clients. This is common for animated game objects that are not related to a specific client, such as scene objects and non-player characters, or server-authoritative clients. "},{"title":"Network Identity","type":0,"sectionRef":"#","url":"docs/components/network-identity","content":"","keywords":""},{"title":"Instantiated Network Game Objects​","type":1,"pageTitle":"Network Identity","url":"docs/components/network-identity#instantiated-network-game-objects","content":"With Mirage’s server-authoritative networking system, the server must spawn networked game objects with network identities, using NetworkServer.Spawn. This automatically creates them on clients that are connected to the server and assign them a NetId. You must put a Network Identity component on any Prefabs that spawn at runtime for the network system to use them. See Object Spawning for more information. "},{"title":"Scene-based Network Game Objects​","type":1,"pageTitle":"Network Identity","url":"docs/components/network-identity#scene-based-network-game-objects","content":"You can also network game objects that are saved as part of your Scene (for example, environmental props). Networking game objects makes them behave slightly differently because you need to have them spawn across the network. When building your game, Unity disables all Scene-based game objects with Network Identity components. When a client connects to the server, the server sends spawn messages to tell the client which Scene game objects to enable and what their most up-to-date state information is. This ensures the client’s game does not contain game objects at incorrect locations when they start playing, or that Unity does not spawn and immediately destroy game objects on the connection (for example, if an event removed the game object before that client connected). See Networked Scene Game Objects for more information. "},{"title":"Preview Pane Information​","type":1,"pageTitle":"Network Identity","url":"docs/components/network-identity#preview-pane-information","content":"This component contains network tracking information and displays that information in the preview pane. For example, the scene ID, network ID and asset ID the object has been assigned. This allows you to inspect the information which can be useful for investigation and debugging.  At runtime there is more information to display here (a disabled NetworkBehaviour is displayed non-bold):  "},{"title":"Network Discovery","type":0,"sectionRef":"#","url":"docs/components/network-discovery","content":"","keywords":""},{"title":"Quick Start​","type":1,"pageTitle":"Network Discovery","url":"docs/components/network-discovery#quick-start","content":"To use Network Discovery follow these steps: Create a game object with a NetworkManager if you have not done so alreadyDo not add a NetworkManagerHUD. Discovery has a different UI component.Add a NetworkDiscoveryHUD component to the NetworkManager game object. A NetworkDiscovery component will be automatically added and wired up to your HUD.Add a player to the NetworkManager if you have not done so.Build and run a standalone versionClick on Start HostStart play mode in the editor and click on Find ServersThe editor should find the standalone version and display a buttonClick on the button to connect to it. The NetworkDiscoveryHUD is provided as a simple and quick way to get started, but you will probably want to replace it with your own user interface. "},{"title":"Custom Network Discovery​","type":1,"pageTitle":"Network Discovery","url":"docs/components/network-discovery#custom-network-discovery","content":"You can completely replace the user interface by adding your own interface (typically Unity UI based) instead of the default NetworkDiscoveryHUD. You do still need the NetworkDiscovery component to do the heavy lifting. Sometimes you want to provide more information in the discovery messages. Some use cases could include: The client can show if the server is in PvP or PvE modeThe client can show how full the servers are.The client can show the ping to each server so the player can choose the fastest serverThe client can show the languageThe client can show if the server is password protected The message classes define what is sent between the client and server. As long as you keep your messages simple using the Data Types that Mirage can serialize, you won't need to write custom serializers for them. public class DiscoveryRequest { public string language=&quot;en&quot;; // Add properties for whatever information you want sent by clients // in their broadcast messages that servers will consume. } public class DiscoveryResponse { enum GameMode {PvP, PvE}; // you probably want uri so clients know how to connect to the server public Uri uri; public GameMode GameMode; public int TotalPlayers; public int HostPlayerName; // Add properties for whatever information you want the server to return to // clients for them to display or consume for establishing a connection. }  The custom NetworkDiscovery class contains the overrides for handling the messages above. You may want to refer to the NetworkDiscovery.cs script in the Components/Discovery folder to see how these should be implemented. public class NewNetworkDiscovery: NetworkDiscoveryBase&lt;DiscoveryRequest, DiscoveryResponse&gt; { #region Server protected override void ProcessClientRequest(DiscoveryRequest request, IPEndPoint endpoint) { base.ProcessClientRequest(request, endpoint); } protected override DiscoveryResponse ProcessRequest(DiscoveryRequest request, IPEndPoint endpoint) { // TODO: Create your response and return it return new DiscoveryResponse(); } #endregion #region Client protected override DiscoveryRequest GetRequest() { return new DiscoveryRequest(); } protected override void ProcessResponse(DiscoveryResponse response, IPEndPoint endpoint) { // TODO: a server replied, do something with the response such as invoking a unityevent } #endregion }  "},{"title":"Network Lerp Rigidbody","type":0,"sectionRef":"#","url":"docs/components/network-lerp-rigidbody","content":"Network Lerp Rigidbody caution The Network Lerp Rigidbody is marked as &quot;Experimental&quot; for now so please share any problems or bugs you find with it and use it at your own risk if production builds. The Network Lerp Rigidbody component synchronizes the position and velocity of a rigidbody across the network. This component is useful when you have a non-kinematic rigidbody that has constant forces applied to them, like gravity, but also want to apply forces or change velocity to that rigidbody or server or client with authority. For example, objects that move and jump using rigidbody using gravity. A game object with a Network Rigidbody component must also have a Network Identity component. When you add a Network Rigidbody component to a game object, Mirage also adds a Network Identity component on that game object if it does not already have one. When using the Network Lerp Rigidbody you should have NetworkTransform on the same object as the Network Lerp Rigidbody will handle syncing the position By default, Network Lerp Rigidbody is server-authoritative unless you check the box for Client Authority. Client Authority applies to character objects as well as non-character objects that have been specifically assigned to a client but only for this component. With this enabled, value changes are sent from the client to the server. Normally, changes are sent to all observers of the object this component is on. Setting Sync Mode to Owner Only makes the changes private between the server and the client owner of the object. You can use the Sync Interval to specify how often it syncs (in seconds). This applies both to Client Authority and Server Authority.","keywords":""},{"title":"Network Log Settings","type":0,"sectionRef":"#","url":"docs/components/network-log-settings","content":"","keywords":""},{"title":"Network Log Settings component​","type":1,"pageTitle":"Network Log Settings","url":"docs/components/network-log-settings#network-log-settings-component","content":"The Network Log Settings component allows you to configure logging levels and load the settings in a build. When you first add NetworkLogSettings you will have to Create a new LogSettings asset that will store the settings.  note If a LogSettings asset already exists the NetworkLogSettings component will set the Settings field when it is added to a game object. "},{"title":"Log Settings​","type":1,"pageTitle":"Network Log Settings","url":"docs/components/network-log-settings#log-settings","content":"When you first set up LogSettings the list of components may be empty or incomplete. Running the game will cause Mirage scripts to add their respective loggers to the list so their logging levels can be changed.  Log settings can also be changed using the &quot;Mirage Log Level&quot; window, which can be opened from the editor menu: Window &gt; Analysis &gt; Mirage Log Levels.  To change settings at runtime please see LogFactory. "},{"title":"Issues​","type":1,"pageTitle":"Network Log Settings","url":"docs/components/network-log-settings#issues","content":"Mirrors Logging API is currently a work in progress. If there is a bug or a feature you want to be added please make an issue here. "},{"title":"Network Manager","type":0,"sectionRef":"#","url":"docs/components/network-manager","content":"Network Manager NetworkManager is a helper class with instance references to the other major parts of the Mirage network. It provides quick access to: NetworkServerNetworkClientNetworkSceneManagerServerObjectManagerClientObjectManager","keywords":""},{"title":"Network Manager HUD","type":0,"sectionRef":"#","url":"docs/components/network-manager-hud","content":"","keywords":""},{"title":"Using the HUD​","type":1,"pageTitle":"Network Manager HUD","url":"docs/components/network-manager-hud#using-the-hud","content":"The Network Manager HUD allows you to start in Host, Server, or Client-only modes and input a network address. "},{"title":"Host (Server + Client)​","type":1,"pageTitle":"Network Manager HUD","url":"docs/components/network-manager-hud#host-server--client","content":"Click the Host (Server + Client) button to start a game as a host on the local network. This client is both the host and one of the players in the game. It uses the information from the Network Info section in the inspector to host the game. When you have started a game as a host, other players of the game can then connect to the host to join the game. Click the Stop button to disconnect from the host. Clicking Stop also returns to the main HUD menu. "},{"title":"Client​","type":1,"pageTitle":"Network Manager HUD","url":"docs/components/network-manager-hud#client","content":"To connect to a host or standalone server on the internet use the text field to specify the address of the host. The default host address is “localhost”, which means the client looks on its own computer for the game host. In addition to localhost, you can specify an IPv4 address, IPv6 address, or a fully-qualified domain name (FQDN), e.g. game.example.com, and the transport with resolve the name using DNS. Click Client to attempt to connect to the host address you have specified. Use the default “localhost” in this field if you are running multiple instances of your game on one computer, to test multiplayer interactivity. To do this, you can create a standalone build of your game, and then launch it multiple times on your computer. This is a common way to quickly test that your networked game interactions are functioning as you expect, without you needing to deploy your game to multiple computers or devices.  When you want to test your game on multiple machines you need to put the address of the computer acting as the host into the address text field. The computer acting as the host needs to tell their IP address to everyone that wants to connect so that they can type the IP into the box. For local clients on a LAN, that's the local IP address (localhost). For remote clients, that's the WAN IP address of the router of the host. Firewall rules and port-forwarding are generally required for a computer to act as the host and accept connections from other computers, whether they're on the LAN or the internet. Enter the IP address (or leave it as localhost if you are testing it on your own machine), then click Client to attempt to connect to the host. When the client is attempting to connect, the HUD displays a Cancel Connection Attempt button. Click this if you want to stop trying to connect to the host.  If the connection is successful, the HUD displays the Stop button. Click this if you want to stop the game on the client and disconnect from the host:  "},{"title":"Server Only​","type":1,"pageTitle":"Network Manager HUD","url":"docs/components/network-manager-hud#server-only","content":"Click Server Only to start a game that acts as a server that other clients can connect to, but which does not act as a client to the game itself. This type of game is often called a “dedicated server”. A user cannot play the game on this particular instance of your game. All players must connect as clients, and nobody plays on the instance that is running as the server. A dedicated server results in better performance for all connected players because the server doesn't need to process a local player's game play in addition to acting as server. You might also choose this option if you want to host a game that can be played over the internet (rather than just within a local network), but want to maintain control of the server yourself - for example, to prevent cheating by one of the clients, because only the server has authority over the game. To do this, you would need to run the game in Server Only mode on a computer with a public IP address. "},{"title":"Network Ping Display","type":0,"sectionRef":"#","url":"docs/components/network-ping-display","content":"Network Ping Display Network Ping Display shows the ping time for clients using OnGUI. The ping time is the moving average of the (RTT) Round-trip delay time. RTT is calculated by the PingMessage/PongMessage between the client and server. See Clock Synchronization for more info.","keywords":""},{"title":"Network Match Checker","type":0,"sectionRef":"#","url":"docs/components/network-match-checker","content":"Network Match Checker The Network Match Checker component controls the visibility of networked objects based on match id. Any object with this component on it will only be visible to other objects in the same match. This would be used to isolate players to their respective matches within a single game server instance. When you create a match, generate and store, in a List, for example, a new match id with System.Guid.NewGuid(); and assign the same match id to the Network Match Checker via GetComponent&lt;NetworkMatchChecker&gt;().matchId. Mirage's built-in Observers system will isolate SyncVar's and ClientRpc's on networked objects to only send updates to clients with the same match id.","keywords":""},{"title":"Network Proximity Checker","type":0,"sectionRef":"#","url":"docs/components/network-proximity-checker","content":"Network Proximity Checker The Network Proximity Checker component controls the visibility of game objects for network clients, based on proximity to players. Vis Range Define the range that the game object should be visible to observers.Vis Update Interval Define how often (in seconds) the game object should check for observers entering its visible range.Check Method Define which type of physics (2D or 3D) to use for proximity checking.Force Hidden Tick this checkbox to hide this object from all players. With the Network Proximity Checker, a game running on a client doesn’t have information about game objects that are not visible. This has two main benefits: it reduces the amount of data sent across the network, and it makes your game more secure against hacking. This component relies on physics to calculate visibility, so observer game objects must also have a collider component on them. A game object with a Network Proximity Checker component must also have a Network Identity component. When you create a Network Proximity Checker component on a game object, Mirage also creates a Network Identity component on that game object if it does not already have one. Scene objects with a Network Proximity Checker component are disabled when they're out of range, and spawned objects are destroyed when they're out of range.","keywords":""},{"title":"Network Rigidbody","type":0,"sectionRef":"#","url":"docs/components/network-rigidbody","content":"Network Rigidbody caution The Network Lerp Rigidbody is marked as &quot;Experimental&quot; for now so please share any problems or bugs you find with it and use it at your own risk if production builds. The Network Rigidbody component synchronizes velocity and other properties of a rigidbody across the network. This component is useful when you have a non-kinematic rigidbody that have constant forces applied to them, like gravity, but also want to apply forces or change velocity to that rigidbody or server or client with authority. For example, objects that move and jump using rigidbody using gravity. A game object with a Network Rigidbody component must also have a Network Identity component. When you add a Network Rigidbody component to a game object, Mirage also adds a Network Identity component on that game object if it does not already have one. Network Rigidbody works best when there is also a NetworkTransform for the object to keep position as well as velocity in sync. By default, Network Rigidbody is server-authoritative unless you check the box for Client Authority. Client Authority applies to character objects as well as non-character objects that have been specifically assigned to a client, but only for this component. With this enabled, value changes are send from the client to the server. The Sensitivity options allow you to set a minimum thresholds before values are send over network. This helps minimize network traffic for very small changes. For some object you may not want them to rotate but don't need to sync the Angular Velocity. The Clear Angular Velocity will set the Angular Velocity to zero each frame causing the minimizing when objects rotation. If Sync Angular Velocity is enabled then clear is ignored. The same can apply to Clear Velocity. Normally, changes are sent to all observers of the object this component is on. Setting Sync Mode to Owner Only makes the changes private between the server and the client owner of the object. You can use the Sync Interval to specify how often it syncs (in seconds). This applies both to Client Authority and Server Authority.","keywords":""},{"title":"Network Room Player","type":0,"sectionRef":"#","url":"docs/components/network-room-player","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Network Room Player","url":"docs/components/network-room-player#methods","content":""},{"title":"Client Virtual Methods​","type":1,"pageTitle":"Network Room Player","url":"docs/components/network-room-player#client-virtual-methods","content":"public virtual void OnClientEnterRoom() {} public virtual void OnClientExitRoom() {} public virtual void OnClientReady(bool readyState) {}  "},{"title":"Network Room Manager","type":0,"sectionRef":"#","url":"docs/components/network-room-manager","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Network Room Manager","url":"docs/components/network-room-manager#properties","content":"Show Room GUI Show the default OnGUI controls for the room.Min Players Minimum number of players needed to start a game.Room Player Prefab The prefab to create for players when they enter the room (requires Network Room Player component).Room Scene The scene to use for the room.Gameplay Scene The scene to use for main game play.pendingPlayers List\\&lt;PendingPlayer&gt; that holds players that are ready to start playing.roomSlots List\\&lt;NetworkRoomPlayer&gt; that manages the slots for connected clients in the room.allPlayersReady Bool indicating if all players are ready to start playing. This value changes as players invoke CmdChangeReadyState indicating true or false, and will be set false when a new client connects. "},{"title":"Methods​","type":1,"pageTitle":"Network Room Manager","url":"docs/components/network-room-manager#methods","content":""},{"title":"Server Virtual Methods​","type":1,"pageTitle":"Network Room Manager","url":"docs/components/network-room-manager#server-virtual-methods","content":"public virtual void OnRoomStartHost() {} public virtual void OnRoomStopHost() {} public virtual void OnRoomStartServer() {} public virtual void OnRoomServerConnect(NetworkConnection conn) {} public virtual void OnRoomServerDisconnect(NetworkConnection conn) {} public virtual void OnRoomServerSceneChanged(string sceneName) {} public virtual GameObject OnRoomServerCreateRoomPlayer(NetworkConnection conn) { return null; } public virtual GameObject OnRoomServerCreateGamePlayer(NetworkConnection conn) { return null; } public virtual bool OnRoomServerSceneLoadedForPlayer(GameObject roomPlayer, GameObject gamePlayer) { return true; } public virtual void OnRoomServerPlayersReady() { ServerChangeScene(GameplayScene); }  "},{"title":"Client Virtual Methods​","type":1,"pageTitle":"Network Room Manager","url":"docs/components/network-room-manager#client-virtual-methods","content":"public virtual void OnRoomClientEnter() {} public virtual void OnRoomClientExit() {} public virtual void OnRoomClientConnect(NetworkConnection conn) {} public virtual void OnRoomClientDisconnect(NetworkConnection conn) {} public virtual void OnRoomStartClient() {} public virtual void OnRoomStopClient() {} public virtual void OnRoomClientSceneChanged(NetworkConnection conn) {} public virtual void OnRoomClientAddPlayerFailed() {}  "},{"title":"Network Scene Manager","type":0,"sectionRef":"#","url":"docs/components/network-scene-manager","content":"","keywords":""},{"title":"How does it work​","type":1,"pageTitle":"Network Scene Manager","url":"docs/components/network-scene-manager#how-does-it-work","content":"When the NetworkServer starts it assumes the initial scene is the one you plan on running the network on. If this is not correct you can either change scenes before starting the network or after. The order on the server will likely only matter to you if you are running in Host mode. Once a NetworkClient connects and passes authentication the NetworkServer will send a message notifying them of the currently active scene and any additive scenes they should load. Once that task is complete then the server will start spawning network objects on the NetworkClient. "},{"title":"How do I change scenes​","type":1,"pageTitle":"Network Scene Manager","url":"docs/components/network-scene-manager#how-do-i-change-scenes","content":"If the scene change involves network objects then it is strongly recommended to make any scene changes via the NetworkSceneManager. Doing so via Unity's SceneManager directly may function but give undesired results with network objects. To do a network scene change you initiate the process via the server NetworkSceneManager via: sceneManager.ChangeServerScene(&quot;Assets/GameScene.unity&quot;);  note You don't have to provide the full scene path when initiating a scene change. But the 'NetworkSceneName' will be saved as the full path. "},{"title":"Network Start Position","type":0,"sectionRef":"#","url":"docs/components/network-start-position","content":"Network Start Position To control where players are spawned, you can use the Network Start Position component. To use these, attach a Network Start Position component to a game object in the scene, and position the game object where you would like one of the players to start. You can add as many start positions to your Scene as you like. The Network Manager detects all start positions in your Scene, and when it spawns each player instance, it uses the position and orientation of one of them. The Network Manager will spawn players at (0, 0, 0) by default. Adding this component to a game object will automatically register/unregister its game object's transform to the Network Manager as an available spawning position. Depending on the Network Manager Player Spawn Method setting the spawning is either Random (possible that the same spawn position will be used by two or more players) or Round Robin (use every available position, until there are more clients than spawn points).","keywords":""},{"title":"Network Scene Checker","type":0,"sectionRef":"#","url":"docs/components/network-scene-checker","content":"","keywords":""},{"title":"Use with Additive Scenes​","type":1,"pageTitle":"Network Scene Checker","url":"docs/components/network-scene-checker#use-with-additive-scenes","content":"In Mirage, the Server and connected Clients are always on the same main scene, however, the server and clients can have various combinations of smaller sub-scenes loaded additively. The server may load all sub-scenes at start, or it may dynamically load and unload sub-scenes where players or other activity is going on as needed. All character objects are always first spawned in the main scene, which may or may not have visual content, networked objects, etc. With this component attached to all networked objects, whenever the character object is moved to a sub-scene (from the main or another sub-scene), the observer's lists for objects in both the new scene and the prior scene are updated accordingly. Loading the sub-scene(s) on the server is through the normal process with SceneManager: SceneManager.LoadSceneAsync(subScene, LoadSceneMode.Additive);  Next, you will send a SceneMessage to the client telling it to load a sub-scene additively: SceneMessage msg = new SceneMessage { sceneName = subScene, sceneOperation = SceneOperation.LoadAdditive }; Owner.Send(msg);  Then, on the server only, you just move the character object to the sub-scene: // Position the character object in world space first // This assumes it has a NetworkTransform component that will update clients player.transform.position = new Vector3(100, 1, 100); // Then move the character object to the subscene SceneManager.MoveGameObjectToScene(player, subScene);  Optionally you can send another SceneMessage to the client with SceneOperation.UnloadAdditive to remove any previous additive scene the client no longer needs. This would apply to a game that has levels after a level change. A short delay may be necessary before removal to allow the client to get fully synced. Depending on the complexity of your game, you may find it helpful when switching a player between sub-scenes to move the character object to the main scene first, yield 100 ms, re-position it, and finally move it to the new sub-scene. "},{"title":"Network Transform","type":0,"sectionRef":"#","url":"docs/components/network-transform","content":"Network Transform The Network Transform component synchronizes the position, rotation, and scale of networked game objects across the network. A game object with a Network Transform component must also have a Network Identity component. When you add a Network Transform component to a game object, Mirage also adds a Network Identity component on that game object if it does not already have one. By default, Network Transform is server-authoritative unless you check the box for Client Authority. Client Authority applies to character objects as well as non-character objects that have been specifically assigned to a client but only for this component. With this enabled, position changes are sent from the client to the server. Under Sensitivity, you can set the minimum thresholds of change to the transform values in order for network messages to be generated. This helps minimize network &quot;noise&quot; for minor twitch and jitter. Normally, changes are sent to all observers of the object this component is on. Setting Sync Mode to Owner Only makes the changes private between the server and the client owner of the object. You can use the Sync Interval to specify how often it syncs (in seconds).","keywords":""},{"title":"Network Transform Child","type":0,"sectionRef":"#","url":"docs/components/network-transform-child","content":"Network Transform Child The Network Transform Child component synchronizes the position and rotation of the child game object of a game object with a Network Transform component. You should use this component in situations where you need to synchronize an independently-moving child object with a Networked game object. To use the Network Transform Child component, attach it to the same parent game object as the Network Transform, and use the Target field to define which child game object to apply the component settings to. You can have multiple Network Transform Child components on one parent game object. You can modify Compress Rotation to save some bandwidth when synchronizing the rotation. You can use the Network Sync Interval to specify how often it syncs (in seconds). This component takes authority into account, so local player game objects (which have local authority) synchronize their position from the client to the server, then out to other clients. Other game objects (with server authority) synchronize their position from the server to clients.","keywords":""},{"title":"Samples Overview","type":0,"sectionRef":"#","url":"docs/examples/","content":"","keywords":""},{"title":"Import samples​","type":1,"pageTitle":"Samples Overview","url":"docs/examples/#import-samples","content":"Sample can be imported using the Unity Package manager. They can be found inside the Samples Dropdown.  "},{"title":"Additive Scenes Example","type":0,"sectionRef":"#","url":"docs/examples/additive-scenes","content":"Additive Scenes Example IMPORTANT: Make sure you have a layer in project settings called Player for this example to work well. In Build Settings, remove all scenes and add all of the scenes from the Scenes folder in the following order: MainSceneSubScene Open the MainScene in the Editor and make sure the Sub Scenes list in the Network Manager component on the Network scene object contains the SubScene scene. This is already set-up by default, but if the MainScene was opened and saved before putting the scenes in the Build Settings list, the Sub Scenes list may be cleared accidentally. File -&gt; Build and Run Start up to 3 built instances: These will all be client players. Press Play in the Editor and click Host (Server + Client) in the HUD This will be the host and the 1st player of up to 4. You can also use Server Only if you prefer. Click Client in the built instances. WASDQE keys to move &amp; turn your player capsule.There are objects in the corners of the scene hidden by Proximity Checkers.The big area in the middle is where the sub-scene will be loaded when you get near the shelter.There are also networked objects inside the sub-scene, also with Proximity Checkers.Since sub-scenes are only loaded for individual clients, other clients that are outside the middle Zone won't see what those in the sub-scene can see.If you play a built instance as Host or Server and play as a client in the editor, you'll see the sub-scene content load and unload in the hierarchy as you move in and out of the middle Zone.","keywords":""},{"title":"Basic","type":0,"sectionRef":"#","url":"docs/examples/basic","content":"Basic General description of Basic example.","keywords":""},{"title":"Chat","type":0,"sectionRef":"#","url":"docs/examples/chat","content":"Chat","keywords":""},{"title":"ChangeScene","type":0,"sectionRef":"#","url":"docs/examples/change-scene","content":"ChangeScene","keywords":""},{"title":"Multiple Additive Scenes Example","type":0,"sectionRef":"#","url":"docs/examples/multiple-additive-scenes","content":"","keywords":""},{"title":"MultiScene Network Manager​","type":1,"pageTitle":"Multiple Additive Scenes Example","url":"docs/examples/multiple-additive-scenes#multiscene-network-manager","content":"The MultiScene Network Manager is derived from the base Network Manager and is responsible for additively loading the sub-scene instances and placing the players in their respective sub-scene instances and initializing player SyncVars. It has a Game Scene field where the Game sub-scene is assigned, and an Instances field to set how many instances are loaded on the server. In this example, the sub-scene instances are additively loaded on the server with localPhysicsMode = LocalPhysicsMode.Physics3D. Physics sub-scenes do not auto-simulate, so each scene has a game object with a generic PhysicsSimulator script on it. This script does nothing on the client, only on the server. Clients only ever have one instance of the sub-scene additively loaded (without localPhysicsMode), while the server has them all. All networked objects have a NetworkSceneChecker component which is what isolates them to their specific sub-scene. "},{"title":"Playing in the Instances​","type":1,"pageTitle":"Multiple Additive Scenes Example","url":"docs/examples/multiple-additive-scenes#playing-in-the-instances","content":"File -&gt; Build and Run Start at least 3 built instances: These will all be client players. Press Play in the Editor and click Host (Server + Client) in the HUD - This will be the host and the 1st player. You can also use Server Only if you prefer. Click Client in the built instances. WASDQE keys to move &amp; turn your player capsule, Space to jump. Colliding with the small colored spheres scores points based on their color. Colliding with the larger tumblers sends them rolling around...they're server-side non-kinematic rigidbodies. Only scores for the players in the same sub-scene are shown at the top of the game window.  "},{"title":"Room","type":0,"sectionRef":"#","url":"docs/examples/room","content":"Room General description of Room example.","keywords":""},{"title":"Pong","type":0,"sectionRef":"#","url":"docs/examples/pong","content":"","keywords":""},{"title":"Setting the number of players​","type":1,"pageTitle":"Pong","url":"docs/examples/pong#setting-the-number-of-players","content":"First of all, let's have a look at the NetworkManager object in the main scene. When adding the NetworkManager component to a game object, a few default settings are already set (Don't destroy on Load, Run in Background, ...) For playing Pong the maximum number of players is 2, so the setting Network Info/Max connections will also be 2. As there are no other scenes (room, online or offline scene) in this sample the properties for Offline Scene andOnline Scene will stay empty. "},{"title":"Creating the player​","type":1,"pageTitle":"Pong","url":"docs/examples/pong#creating-the-player","content":"Furthermore, every player needs a racket to play with. Each player who joins the game will have his own controllable object, which represents him within the game. This game object is called PlayerObject. For spawning the PlayerObjecta prefab has to be created, containing at least a NetworkIdentity component withLocal Player Authority checked. The Local Player Authority allows the player to control and modify the game objects properties (e.g. for movement). The NetworkManager needs a reference to this prefab, which is located in Spawn Info/Player Prefab. To have the player movement synchronized over the network, the player prefab also contains a NetworkTransform.  "},{"title":"Player start position​","type":1,"pageTitle":"Pong","url":"docs/examples/pong#player-start-position","content":"The main scene contains 2 game objects with only a NetworkStartPosition component (game objects RacketSpawnLeft, RacketSpawnRight in the scene). These transforms will be automatically registered by the NetworkManager as spawning positions.  "},{"title":"Setting up the network​","type":1,"pageTitle":"Pong","url":"docs/examples/pong#setting-up-the-network","content":"A very convenient component for establishing/testing connections is the NetworkManagerHUD. It provides basic functionality for starting a game as a Client, Server, or Host (Client and Server at the same time). It requires the NetworkManager component.  "},{"title":"The ball of Pong​","type":1,"pageTitle":"Pong","url":"docs/examples/pong#the-ball-of-pong","content":"The ball is the main focus of Pong, as this is the object needed to score points. Its NetworkIdentity component has neither Server Only nor Local Player Authority checked, as it's moved by the server physics engine and can be influenced by the players. As with the PlayerObject the position is synchronized via NetworkTransform. When having multiple scenes, the ball can be spawned by the NetworkManager, but to keep this sample simple, it's placed directly within the main scene. "},{"title":"Tanks","type":0,"sectionRef":"#","url":"docs/examples/tanks","content":"Tanks General description of Tanks example.","keywords":""},{"title":"Overview","type":0,"sectionRef":"#","url":"docs/general/overview","content":"","keywords":""},{"title":"Socket Layer​","type":1,"pageTitle":"Overview","url":"docs/general/overview#socket-layer","content":"The Socket Layer is concerned about sending and receiving bytes. It does not know what it is sending. There are several socket factory implementations. The default socket factory in Mirage is UDPSocketFactory. If you want to implement a socket factory, create a class that extends Mirage.SocketLayer.SocketFactory. Its primary responsibility is to send and receive data. You will also need to create a class that represents a link between Mirage and the outside world by implementing Mirage.SocketLayer.ISocket. Reliability is handled on top of the factory by Mirage. "},{"title":"Message Layer​","type":1,"pageTitle":"Overview","url":"docs/general/overview#message-layer","content":"The message layer is concerned with sending and receiving messages. If you wish to use this functionality, you will need to have a Mirage.NetworkClient in the client and a Mirage.NetworkServer for the server. These classes provide events you can subscribe to for the life cycle of connections. A connection is an implementation of Mirage.INetworkPlayer, and can send and receive messages. "},{"title":"Object Layer​","type":1,"pageTitle":"Overview","url":"docs/general/overview#object-layer","content":"This layer is the highest level layer, the classes in this layer are concerned about synchronizing state between objects, as well as sending RPC calls. The client needs a Mirage.ClientObjectManager, the server needs a Mirage.ServerObjectManager. It will spawn and destroy objects and keep the objects in the client in sync with the objects in the server Clients and Servers Mirage supports 2 modes of operation which can work at the same time. "},{"title":"Host mode​","type":1,"pageTitle":"Overview","url":"docs/general/overview#host-mode","content":"In host mode, the server and client are running in the same application and share all networked objects. There is a direct in-memory channel of communication between the Mirage.NetworkServer and Mirage.NetworkClient. Since the objects are shared, there is no need to synchronize data. Note that the host mode bypasses the Transport Layer. "},{"title":"Client / Server mode​","type":1,"pageTitle":"Overview","url":"docs/general/overview#client--server-mode","content":"In this mode, the client is connected to a separate server, which is normally in another machine and reachable through the network. In client/server mode, the objects are duplicated in the server and client. For every networked object in the server, there is a corresponding object in the client with a matching network id. Note a server can be in both host mode as well as a server for other clients.  "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/general/getting-started","content":"","keywords":""},{"title":"Video Tutorials​","type":1,"pageTitle":"Getting Started","url":"docs/general/getting-started#video-tutorials","content":"Currently, there are no Mirage-specific videos. You can use Mirror's existing videos alongside our Mirror to Mirage Conversion guide. "},{"title":"Networking Set-Up​","type":1,"pageTitle":"Getting Started","url":"docs/general/getting-started#networking-set-up","content":"Right click in the Scene, select Network → NetworkManager. This will create a new GameObject with all the necessary networking components set up for you.Add the NetworkManagerHUD component to the game object. This provides an out-of-the-box canvas UI system that you can use and create your own UI. Assign the variables to properly set up the UI so everything will interact with network code. In the future, we will be providing out-of-the-box UI that auto sets up. See Using the NetworkManager. "},{"title":"Player Prefab​","type":1,"pageTitle":"Getting Started","url":"docs/general/getting-started#player-prefab","content":"Create a new prefab in your project.Add a NetworkIdentity component to the player prefabSet the playerPrefab field on the CharacterSpawner component to the player prefab. You can find this component on the GameObject you created in the first setup. See character objects for more information. "},{"title":"Player Movements​","type":1,"pageTitle":"Getting Started","url":"docs/general/getting-started#player-movements","content":"note Attach the correct type of movement script you intended to use. NetworkTransform will move the transform component without physics calculations. If you require physics to be also part of your normal movement calculations suggestion would be to attach a NetworkRigidBody component instead. caution Currently network transform and network rigid body components cannot handle various lag and drop of packets. Jitter or lag behind may occur. We are working to improve these components and have better lag and jitter control in the future. Add the correct movement component you require.Check box client authority under the component if you want the player to be able to fully control movement without the server controlling it. caution If client authority is checked then hacking can occur due to trusting clients and accepting their movement. if you do not want this do not check client authority under the component and you will require to send commands to the server to allow movement to occur. Update input and control scripts to reflect what type of control you want. See below for different examples. note If you require a camera to run on player prefab subscribe to Identity.OnStartLocalPlayer event to take control of the Main Camera in the scene for the player. You do not need a camera on every player prefab. For example, if client authority has been checked and you trust clients. Never trust clients though. using UnityEngine; using Mirage; public class Controls : NetworkBehaviour { void Update() { if (!IsLocalPlayer) { // exit from update if this is not the local player return; } // handle player input for movement } }  For example, if server authority is going to be used. using UnityEngine; using Mirage; public class Controls : NetworkBehaviour { void Update() { if (!IsLocalPlayer) { // exit from update if this is not the local player return; } // handle player input for movement // You would call this command after handling input or you can send inputs directly to // server and let server buffer inputs up and do movements based on the buffered inputs. MovePlayer(); } [ServerRpc] void MovePlayer() { // We are now firing off some kind of movement all done by server. } }  "},{"title":"Basic Player Game State​","type":1,"pageTitle":"Getting Started","url":"docs/general/getting-started#basic-player-game-state","content":"Make scripts that contain important data into NetworkBehaviours instead of MonoBehavioursYou can sync different types of data depending on what you need to sync. See State Synchronization. "},{"title":"Remote Actions​","type":1,"pageTitle":"Getting Started","url":"docs/general/getting-started#remote-actions","content":"Make scripts that perform important actions into NetworkBehaviours instead of MonoBehavioursUpdate functions that perform important player actions to have an attribute of [ServerRpc] See Remote Actions. "},{"title":"Non-player game objects​","type":1,"pageTitle":"Getting Started","url":"docs/general/getting-started#non-player-game-objects","content":"Fix non-player prefabs such as enemies: Add the NetworkIdentify componentAdd the correct component needed to sync movement as the state above with player movement.Once all objects have a network identity. Find ClientObjectManager under the NetworkManager game object in the scene and hit register prefabs.Update scripts with game state and actions "},{"title":"Spawners​","type":1,"pageTitle":"Getting Started","url":"docs/general/getting-started#spawners","content":"Potentially change spawner scripts to be NetworkBehavioursModify spawners to only run on the server (use IsServer property or the OnStartServer callback)Call ServerObjectManager.Spawn() for created game objects "},{"title":"Spawn positions for players​","type":1,"pageTitle":"Getting Started","url":"docs/general/getting-started#spawn-positions-for-players","content":"Add a new game object and place it at the player's start locationAdd this GameObject to the CharacterSpawner's Positions list. "},{"title":"Sockets","type":0,"sectionRef":"#","url":"docs/general/sockets","content":"","keywords":""},{"title":"Available sockets​","type":1,"pageTitle":"Sockets","url":"docs/general/sockets#available-sockets","content":"The table below shows a list of available sockets and their features. \tUDP (built-in)\tSteam (Steamworks.NET, Facepunch)\tWebsocketCCU\t1000+\t?\t? Protocol\tUDP\tUDP\tTCP Unreliable\t✅\t✅\t❌ Mobile\t✅\t❌\t✅ WebGL\t❌\t❌\t✅ CPU\tLOW\tLOW\t? NAT Punch\t❌\t✅\t❌ Encryption\t❌\t✅\t✅ IPv6\t✅\t?\t? Managed\t✅\t✅\t✅ Native\t✅\t❌\t❌ Based on\tNanoSockets (native), .NET (managed)\tSteam Game Networking Sockets\tSimpleWebTransport "},{"title":"Changing a socket​","type":1,"pageTitle":"Sockets","url":"docs/general/sockets#changing-a-socket","content":"To change a socket, follow the steps below: Install the desired socket. Instructions are available on each socket's repository.Add the socket's SocketFactory as a new component on the object where you have the other Mirage components.Assign a reference to this component in the Socket Factory field of NetworkServer and NetworkClient components.Check if the socket has any required additional steps.Done. Mirage should now be using the newly added socket. "},{"title":"Implementing new socket​","type":1,"pageTitle":"Sockets","url":"docs/general/sockets#implementing-new-socket","content":"To create a new socket, you have to implement two classes - one that implements the Mirage.SocketLayer.ISocketinterface, which will represent the low-level socket and one that extends the Mirage.SocketLayer.SocketFactoryclass, which will act as the MonoBehaviour component creating new instances of the low-level class. You can check out our built-in UDP socket implementation as an inspiration: Mirage.Sockets.Udp.UdpSocket andMirage.Sockets.Udp.UdpSocketFactory. "},{"title":"Showcase","type":0,"sectionRef":"#","url":"docs/general/showcase","content":"Showcase Cubica | Showcase video | The multiplayer version of Block Story Alteros Online | Science-Fantasy Post Apo 3D MMORPG Block'Em! | Block'Em! is an action-filled block-building party game for 2 to 4 players! Hacker Field | Discord | HackerField is a multiplayer strategy tower defense in a futuristic scenario. Wolves | Wolves is a 3rd person action shooter based on MechAssault","keywords":""},{"title":"Troubleshooting","type":0,"sectionRef":"#","url":"docs/general/troubleshooting","content":"","keywords":""},{"title":"No Writer found for X​","type":1,"pageTitle":"Troubleshooting","url":"docs/general/troubleshooting#no-writer-found-for-x","content":"Mirage normally generates readers and writers for any Data TypeIn order to do so, it needs to know what types you want to read or write. You are getting this error because Mirage did not know you wanted to read or write this type. Mirage scans your code looking for calls to Send, ReceiveHandler, Write or Read. It will also recognize SyncVars and parameters of Remote Calls. If it does not find one, it assumes you are not trying to serialize the type so it does not generate the reader and writer. For example, you might get this error with this code when trying to sync the SyncList. public struct MyCustomType { public int id; public string name; } class MyBehaviour : NetworkBehaviour { private readonly SyncList&lt;MyCustomType&gt; myList = new SyncList&lt;MyCustomType&gt;(); }  In this case, there is no direct invocation to send or receive. So Mirage does not know about it. There is a simple workaround: add an [NetworkMessage] attribute to your class or struct. [NetworkMessage] // Added attribute public struct MyCustomType { public int id; public string name; }  "},{"title":"Support","type":0,"sectionRef":"#","url":"docs/general/support","content":"","keywords":""},{"title":"Discord​","type":1,"pageTitle":"Support","url":"docs/general/support#discord","content":"You can find us on Discord. "},{"title":"GitHub​","type":1,"pageTitle":"Support","url":"docs/general/support#github","content":"You can create an issue on GitHubYou can also contribute with Pull Requests...see Contributing "},{"title":"Attributes","type":0,"sectionRef":"#","url":"docs/guides/attributes","content":"Attributes Networking attributes are added to member functions of NetworkBehaviourscripts, to make them run on either the client or server. These attributes can be used for Unity game loop methods like Start or Update, as well as other implemented methods. note When using abstract or virtual methods the attributes need to be applied to the override methods too. ServerAttribute Only a server can call the method (throws an error when called on a client unless you specify error = false). ClientAttribute Only a client can call the method (throws an error when called on the server unless you specify error = false). ClientRpcAttribute The server uses a Remote Procedure Call (RPC) to run that function on clients. It has a target option allowing you to specify in which clients it should be executed, along with a channel option. See also: ClientRpc ServerRpcAttribute Call this from a client to run this function on the server. Make sure to validate the input on the server. It's not possible to call this from a server. Use this as a wrapper around another function, if you want to call it from the server too. Note that you can also return value from it. See also: ServerRpc SyncVar SyncVars are used to synchronize a variable from the server to all clients automatically.","keywords":""},{"title":"About IDs","type":0,"sectionRef":"#","url":"docs/guides/about-ids","content":"","keywords":""},{"title":"NetId​","type":1,"pageTitle":"About IDs","url":"docs/guides/about-ids#netid","content":"Mirage uses uint for NetId. Every NetworkIdentity is assigned a NetId when it is being spawned. Mirage uses the ID when passing messages between client and server to tell which object is the recipient of the message. "},{"title":"Prefab Hash​","type":1,"pageTitle":"About IDs","url":"docs/guides/about-ids#prefab-hash","content":"The prefab hash is used to uniquely identify each prefab so that it can be spawned over the network. Mirage will create the prefab hash by taking a 32-bit hash of the Asset path. The path is found using AssetDatabase.GetAssetPath "},{"title":"Scene ID​","type":1,"pageTitle":"About IDs","url":"docs/guides/about-ids#scene-id","content":"Mirage uses ulong for Scene IDss. Every game object with a NetworkIdentity in the scene (hierarchy) is assigned a scene ID in OnPostProcessScene. Mirage needs that to distinguish scene objects from each other because Unity has no unique ID for different game objects in the scene. "},{"title":"Best Practices","type":0,"sectionRef":"#","url":"docs/guides/best-practices","content":"","keywords":""},{"title":"Custom Messages​","type":1,"pageTitle":"Best Practices","url":"docs/guides/best-practices#custom-messages","content":"If you send custom message regularly then the message should be a struct so that there is no GC/allocations. struct CreateVisualEffect { public Vector3 position; public Guid prefabId; }  "},{"title":"Bit Packing","type":0,"sectionRef":"#","url":"docs/guides/bit-packing/","content":"","keywords":""},{"title":"Bit Packing in Mirage​","type":1,"pageTitle":"Bit Packing","url":"docs/guides/bit-packing/#bit-packing-in-mirage","content":"Mirage has many attributes that can be applied to SyncVars and Rpc parameters BitCount Sets the number of bits on an integerBitCountFromRange Sets the number of bits from a given range, rounding up.ZigZagEncode Encodes a value using ZigZag Encoding. Only useable with BitCount or VarIntBlocksVarInt Packs int to different sizes based on their size. Allows for 3 configurable size rangesVarIntBlocks Packs int to different sizes based on their size. Uses block size so can be used over a large range of valuesFloatPack Compresses a float valueVectorPack Compresses a Vector valueQuaternionPack Compresses a Quaternion value "},{"title":"Network Authority","type":0,"sectionRef":"#","url":"docs/guides/authority","content":"","keywords":""},{"title":"Server Authority​","type":1,"pageTitle":"Network Authority","url":"docs/guides/authority#server-authority","content":"Server authority means that the server has control of an object. The server has authority over an object by default. This means the server would manage and control all of the collectible items, moving platforms, NPCs, and any other networked objects that aren't the player. "},{"title":"Client Authority​","type":1,"pageTitle":"Network Authority","url":"docs/guides/authority#client-authority","content":"Client authority means that the client has control of an object. When a client has authority over an object it means that they can call ServerRpc and that the object will automatically be destroyed when the client disconnects. Even if a client has authority over an object the server still controls SyncVar and controls other serialization features. A component will need to use a ServerRpc to update the state on the server for it to sync to other clients. "},{"title":"How to give authority​","type":1,"pageTitle":"Network Authority","url":"docs/guides/authority#how-to-give-authority","content":"By default, the server has authority over all objects. The server can give authority to objects that a client needs to control, like the character object. If you spawn a character object using ServerObjectManager.AddCharacter then it will automatically be given authority. "},{"title":"Using NetworkServer.Spawn​","type":1,"pageTitle":"Network Authority","url":"docs/guides/authority#using-networkserverspawn","content":"You can give authority to a client when an object is spawned. This is done by passing in the connection to the spawn message GameObject go = Instantiate(prefab); ServerObjectManager.Spawn(go, owner);  "},{"title":"Using identity.AssignClientAuthority​","type":1,"pageTitle":"Network Authority","url":"docs/guides/authority#using-identityassignclientauthority","content":"You can give authority to a client at any time using AssignClientAuthority. This can be done by calling AssignClientAuthority on the object you want to give authority too Identity.AssignClientAuthority(conn);  You may want to do this when a player picks up an item // Command on character object [ServerRpc] void PickupItem(NetworkIdentity item) { item.AssignClientAuthority(connectionToClient); }  "},{"title":"How to remove authority​","type":1,"pageTitle":"Network Authority","url":"docs/guides/authority#how-to-remove-authority","content":"You can use Identity.RemoveClientAuthority to remove client authority from an object. Identity.RemoveClientAuthority();  Authority can't be removed from the character object. Instead, you will have to replace the character object using NetworkServer.ReplaceCharacter. "},{"title":"On Authority​","type":1,"pageTitle":"Network Authority","url":"docs/guides/authority#on-authority","content":"When authority is given to or removed from an object a message will be sent to that client to notify them. This will cause the OnAuthorityChanged(bool) functions to be called. "},{"title":"On Destroy​","type":1,"pageTitle":"Network Authority","url":"docs/guides/authority#on-destroy","content":"If the client has authority, then OnAuthorityChanged(false) will be called on the object when it is destroyed. "},{"title":"Check Authority​","type":1,"pageTitle":"Network Authority","url":"docs/guides/authority#check-authority","content":""},{"title":"Client Side​","type":1,"pageTitle":"Network Authority","url":"docs/guides/authority#client-side","content":"The Identity.HasAuthority property can be used to check if the local player has authority over an object. "},{"title":"Server Side​","type":1,"pageTitle":"Network Authority","url":"docs/guides/authority#server-side","content":"The Identity.Owner property can be used to check to see which client has authority over an object. If it is null then the server has authority. "},{"title":"Bit Count","type":0,"sectionRef":"#","url":"docs/guides/bit-packing/bit-count","content":"","keywords":""},{"title":"Use cases​","type":1,"pageTitle":"Bit Count","url":"docs/guides/bit-packing/bit-count#use-cases","content":"A Value with a maximum valueAn index in an array of known size eg array with 10 elements, the index can be sent as 4 bits A Random int hash where you only need to send 16 bits "},{"title":"Supported Types​","type":1,"pageTitle":"Bit Count","url":"docs/guides/bit-packing/bit-count#supported-types","content":"ByteShortUShortIntUintLongULongEnum "},{"title":"Example 1​","type":1,"pageTitle":"Bit Count","url":"docs/guides/bit-packing/bit-count#example-1","content":"Health which is between 0 and 100 public class MyNetworkBehaviour : NetworkBehaviour { [SyncVar, BitCount(7)] public int Health; }  BitCount = 7 so max value of Health is 127 health = 57 will serialize to 011_1001 health = -1 (out of range) will serialize to 111_1111 health = 130 (out of range) will serialize to 000_0010 "},{"title":"Example 2​","type":1,"pageTitle":"Bit Count","url":"docs/guides/bit-packing/bit-count#example-2","content":"Weapon index in a list of 6 weapons public class MyNetworkBehaviour : NetworkBehaviour { [SyncVar, BitCount(3)] public int WeaponIndex; }  BitCount = 3 so max value of Health is 7 WeaponIndex = 5 will serialize to 101 "},{"title":"Generated Code​","type":1,"pageTitle":"Bit Count","url":"docs/guides/bit-packing/bit-count#generated-code","content":"Source: [SyncVar, BitCount(7)] public int myValue;  Generated: public override bool SerializeSyncVars(NetworkWriter writer, bool initialState) { ulong syncVarDirtyBits = base.SyncVarDirtyBits; bool result = base.SerializeSyncVars(writer, initialize); if (initialState) { writer.Write((ulong)this.myValue, 7); return true; } writer.Write(syncVarDirtyBits, 1); if ((syncVarDirtyBits &amp; 1UL) != 0UL) { writer.Write((ulong)this.myValue, 7); result = true; } return result; } public override void DeserializeSyncVars(NetworkReader reader, bool initialState) { base.DeserializeSyncVars(reader, initialState); if (initialState) { this.myValue = reader.Read(7); return; } ulong dirtyMask = reader.Read(1); if ((dirtyMask &amp; 1UL) != 0UL) { this.myValue = reader.Read(7); } }  Last updated for Mirage v101.8.0. "},{"title":"Bit Count From Range","type":0,"sectionRef":"#","url":"docs/guides/bit-packing/bit-count-from-range","content":"","keywords":""},{"title":"Use cases​","type":1,"pageTitle":"Bit Count From Range","url":"docs/guides/bit-packing/bit-count-from-range#use-cases","content":"A Value with a minimum and maximum value "},{"title":"Supported Types​","type":1,"pageTitle":"Bit Count From Range","url":"docs/guides/bit-packing/bit-count-from-range#supported-types","content":"ByteShortUShortIntUintLongULongEnum "},{"title":"Example 1​","type":1,"pageTitle":"Bit Count From Range","url":"docs/guides/bit-packing/bit-count-from-range#example-1","content":"A modifier that can add to a character value to increase or decrease it public class MyNetworkBehaviour : NetworkBehaviour { [SyncVar, BitCountFromRange(-100, 100)] public int modifier; }  Range = 200 so bit count is 8, causing the real range to be -100 to 155 modifier = 57 will serialize to 1001_1101 modifier = -57 will serialize to 0010_1011 modifier = -110 (out of range) will serialize to 1111_0110 modifier = 130 will serialize to 1110_0110, even tho 130 is out of range there is enough range because bit count rounds up. modifier = 170 (out of range) will serialize to 0000_1110 "},{"title":"Example 2​","type":1,"pageTitle":"Bit Count From Range","url":"docs/guides/bit-packing/bit-count-from-range#example-2","content":"A Direction enum to say which way a model is facing public enum MyDirection { Backwards = -1, None = 0, Forwards = 1, } public class MyNetworkBehaviour : NetworkBehaviour { [SyncVar, BitCount(-1, 1)] public MyDirection direction; }  Range = 3 so bit count is 2, causing the real range to be -1 to 2 direction = -1 will serialize to 00 direction = 1 will serialize to 10 "},{"title":"Generated Code​","type":1,"pageTitle":"Bit Count From Range","url":"docs/guides/bit-packing/bit-count-from-range#generated-code","content":"Source: [SyncVar, BitCountFromRange(-100, 100)] public int myValue;  Generated: public override bool SerializeSyncVars(NetworkWriter writer, bool initialState) { ulong syncVarDirtyBits = base.SyncVarDirtyBits; bool result = base.SerializeSyncVars(writer, initialize); if (initialState) { writer.Write((ulong)(this.myValue - (-100)), 8); return true; } writer.Write(syncVarDirtyBits, 1); if ((syncVarDirtyBits &amp; 1UL) != 0UL) { writer.Write((ulong)(this.myValue - (-100)), 8); result = true; } return result; } public override void DeserializeSyncVars(NetworkReader reader, bool initialState) { base.DeserializeSyncVars(reader, initialState); if (initialState) { this.myValue = reader.Read(8) + (-100); return; } ulong dirtyMask = reader.Read(1); if ((dirtyMask &amp; 1UL) != 0UL) { this.myValue = reader.Read(8) + (-100); } }  last updated for Mirage v101.8.0 "},{"title":"Float Pack","type":0,"sectionRef":"#","url":"docs/guides/bit-packing/float-pack","content":"","keywords":""},{"title":"Use cases​","type":1,"pageTitle":"Float Pack","url":"docs/guides/bit-packing/float-pack#use-cases","content":"A Value with a maximum value "},{"title":"Supported Types​","type":1,"pageTitle":"Float Pack","url":"docs/guides/bit-packing/float-pack#supported-types","content":"Float "},{"title":"Example 1​","type":1,"pageTitle":"Float Pack","url":"docs/guides/bit-packing/float-pack#example-1","content":"Health which is between 0 and 100 public class MyNetworkBehaviour : NetworkBehaviour { [SyncVar, FloatPack(100f, 0.02f)] public int Health; }  Max = 100, resolution = 0.02f so bit count is 14 health = 57.2f will serialize to 01_0010_0100_1101 and deserialize to 57.197f health = -13.5f will serialize to 11_1011_1010_1110 and deserialize to -13.503f health = 120f will be clamped to 100f "},{"title":"Example 2​","type":1,"pageTitle":"Float Pack","url":"docs/guides/bit-packing/float-pack#example-2","content":"A Percent that where you only want to send 8 bits public class MyNetworkBehaviour : NetworkBehaviour { [SyncVar, FloatPack(1f, 8)] public int Percent; }  Max = 1f, bitCount = 8 so resolution will be 0.00787f "},{"title":"Generated Code​","type":1,"pageTitle":"Float Pack","url":"docs/guides/bit-packing/float-pack#generated-code","content":"Source: [SyncVar, FloatPack(100f, 0.02f)] public int myValue;  Generated:  private FloatPacker myValue__Packer = new FloatPacker(100f, 0.02f); public override bool SerializeSyncVars(NetworkWriter writer, bool initialState) { ulong syncVarDirtyBits = base.SyncVarDirtyBits; bool result = base.SerializeSyncVars(writer, initialize); if (initialState) { myValue__Packer.Pack(writer, this.myValue); return true; } writer.Write(syncVarDirtyBits, 1); if ((syncVarDirtyBits &amp; 1UL) != 0UL) { myValue__Packer.Pack(writer, this.myValue); result = true; } return result; } public override void DeserializeSyncVars(NetworkReader reader, bool initialState) { base.DeserializeSyncVars(reader, initialState); if (initialState) { this.myValue = myValue__Packer.Unpack(reader); return; } ulong dirtyMask = reader.Read(1); if ((dirtyMask &amp; 1UL) != 0UL) { this.myValue = myValue__Packer.Unpack(reader); } }  last updated for Mirage v101.8.0 "},{"title":"Quaternion Pack","type":0,"sectionRef":"#","url":"docs/guides/bit-packing/quaternion-pack","content":"","keywords":""},{"title":"Quaternion Rules​","type":1,"pageTitle":"Quaternion Pack","url":"docs/guides/bit-packing/quaternion-pack#quaternion-rules","content":"Quaternions can be packed using some of the mathematical rules they follow Quaternions should be normalized​ x^2 + y^2 + z^2 + w^2 = 1 Because of this we only need to send the smallest 3 values as we can calculate the largest one again on the other side. We also need to send the index to say which of the 4 elements was the largest largest = sqrt(1 - a^2 + b^2 + c^2) Positive and Negative Quaternions represent the same rotation​ Q(x,y,z,w) === Q(-x,-y,-z,-w) If the largest element is negative we would have to send its sign in order to calculate the correct rotation. However, because Q=-Q, if the largest element is negative we can just flip the sign of all 4 elements instead. Max of the second largest element​ The value of the 2nd largest element is when it is also equal to the largest so we have L^2 + L^2 = 1 From this, we can find the max value for the 2nd largest is L = +- 1 / sqrt(2) = +- ~0.707 This allows us to pack the smallest 3 elements in the range -0.707 to +0.707 instead of -1 to +1 Result​ Combining all this we can send each of the smallest 3 elements with 9 bits, and 2 bits for the index of the largest element. Which reduces the size of a Quaternion from 128 bits unpacked to only 29 bits. The precision of the smallest 3 can in increased or decreased to change the bit counts by multiples of 3. eg 10 bits per element will result in 32 bits total. "},{"title":"Supported Types​","type":1,"pageTitle":"Quaternion Pack","url":"docs/guides/bit-packing/quaternion-pack#supported-types","content":"Quaternion "},{"title":"Example 1​","type":1,"pageTitle":"Quaternion Pack","url":"docs/guides/bit-packing/quaternion-pack#example-1","content":"public class MyNetworkBehaviour : NetworkBehaviour { [SyncVar, QuaternionPack(9)] public Quaternion direction; }  "},{"title":"Generated Code​","type":1,"pageTitle":"Quaternion Pack","url":"docs/guides/bit-packing/quaternion-pack#generated-code","content":"Source: [SyncVar, QuaternionPack(9)] public int myValue;  Generated:  private QuaternionPacker myValue__Packer = new QuaternionPacker(9); public override bool SerializeSyncVars(NetworkWriter writer, bool initialState) { ulong syncVarDirtyBits = base.SyncVarDirtyBits; bool result = base.SerializeSyncVars(writer, initialize); if (initialState) { myValue__Packer.Pack(writer, this.myValue); return true; } writer.Write(syncVarDirtyBits, 1); if ((syncVarDirtyBits &amp; 1UL) != 0UL) { myValue__Packer.Pack(writer, this.myValue); result = true; } return result; } public override void DeserializeSyncVars(NetworkReader reader, bool initialState) { base.DeserializeSyncVars(reader, initialState); if (initialState) { this.myValue = myValue__Packer.Unpack(reader); return; } ulong dirtyMask = reader.Read(1); if ((dirtyMask &amp; 1UL) != 0UL) { this.myValue = myValue__Packer.Unpack(reader); } }  last updated for Mirage v101.8.0 "},{"title":"Variable Sized Integer","type":0,"sectionRef":"#","url":"docs/guides/bit-packing/var-int","content":"Variable Sized Integer Work In Progress This page is a work in progress","keywords":""},{"title":"Variable Sized Integer Blocks","type":0,"sectionRef":"#","url":"docs/guides/bit-packing/var-int-blocks","content":"","keywords":""},{"title":"Supported Types​","type":1,"pageTitle":"Variable Sized Integer Blocks","url":"docs/guides/bit-packing/var-int-blocks#supported-types","content":"ByteShortUShortIntUintLongULongEnum "},{"title":"Example 1​","type":1,"pageTitle":"Variable Sized Integer Blocks","url":"docs/guides/bit-packing/var-int-blocks#example-1","content":"A modifier that can be added to a character value to increase or decrease it public class MyNetworkBehaviour : NetworkBehaviour { [SyncVar, VarIntBlocks(-100, 100)] public int modifier; }  Range = 200 so bit count is 8, causing the real range to be -100 to 155 modifier = 57 will serialize to 1001_1101 modifier = -57 will serialize to 0010_1011 modifier = -110 (out of range) will serialize to 1111_0110 modifier = 130 will serialize to 1110_0110, even tho 130 is out of range there is enough range because bit count rounds up. modifier = 170 (out of range) will serialize to 0000_1110 "},{"title":"Example 2​","type":1,"pageTitle":"Variable Sized Integer Blocks","url":"docs/guides/bit-packing/var-int-blocks#example-2","content":"A Direction enum to say which way a model is facing public enum MyDirection { Backwards = -1, None = 0, Forwards = 1, } public class MyNetworkBehaviour : NetworkBehaviour { [SyncVar, BitCount(-1, 1)] public MyDirection direction; }  Range = 3 so bit count is 2, causing the real range to be -1 to 2 direction = -1 will serialize to 00 direction = 1 will serialize to 10 "},{"title":"Generated Code​","type":1,"pageTitle":"Variable Sized Integer Blocks","url":"docs/guides/bit-packing/var-int-blocks#generated-code","content":"Source: [SyncVar, BitCountFromRange(-100, 100)] public int myValue;  Generated: public override bool SerializeSyncVars(NetworkWriter writer, bool initialState) { ulong syncVarDirtyBits = base.SyncVarDirtyBits; bool result = base.SerializeSyncVars(writer, initialize); if (initialState) { writer.Write((ulong)(this.myValue - (-100)), 8); return true; } writer.Write(syncVarDirtyBits, 1); if ((syncVarDirtyBits &amp; 1UL) != 0UL) { writer.Write((ulong)(this.myValue - (-100)), 8); result = true; } return result; } public override void DeserializeSyncVars(NetworkReader reader, bool initialState) { base.DeserializeSyncVars(reader, initialState); if (initialState) { this.myValue = reader.Read(8) + (-100); return; } ulong dirtyMask = reader.Read(1); if ((dirtyMask &amp; 1UL) != 0UL) { this.myValue = reader.Read(8) + (-100); } }  last updated for Mirage v101.8.0 "},{"title":"ZigZag Encode","type":0,"sectionRef":"#","url":"docs/guides/bit-packing/zig-zag-encode","content":"","keywords":""},{"title":"Use cases​","type":1,"pageTitle":"ZigZag Encode","url":"docs/guides/bit-packing/zig-zag-encode#use-cases","content":"A value that can be negative or positive "},{"title":"Supported Types​","type":1,"pageTitle":"ZigZag Encode","url":"docs/guides/bit-packing/zig-zag-encode#supported-types","content":"ByteShortIntLongEnum "},{"title":"Example 1​","type":1,"pageTitle":"ZigZag Encode","url":"docs/guides/bit-packing/zig-zag-encode#example-1","content":"A modifier that can be added to a character value to increase or decrease it public class MyNetworkBehaviour : NetworkBehaviour { [SyncVar, BitCount(8), ZigZagEncode] public int modifier; }  Range = 200 so bit count is 8, causing the real range to be -128 to 127 modifier = 57 will serialize to 0111_0010 modifier = -57 will serialize to 0111_0001 modifier = -110 will serialize to 1101_1011, even tho -110 is out of range there is enough range because bit count rounds up. modifier = 130 (out of range) will serialize to 0000_0100 "},{"title":"Generated Code​","type":1,"pageTitle":"ZigZag Encode","url":"docs/guides/bit-packing/zig-zag-encode#generated-code","content":"Source: [SyncVar, BitCount(8), ZigZagEncode] public int myValue;  Generated: public override bool SerializeSyncVars(NetworkWriter writer, bool initialState) { ulong syncVarDirtyBits = base.SyncVarDirtyBits; bool result = base.SerializeSyncVars(writer, initialize); if (initialState) { writer.Write((ulong)ZigZag.Encode(this.myValue), 8); return true; } writer.Write(syncVarDirtyBits, 1); if ((syncVarDirtyBits &amp; 1UL) != 0UL) { writer.Write((ulong)ZigZag.Encode(this.myValue), 8); result = true; } return result; } public override void DeserializeSyncVars(NetworkReader reader, bool initialState) { base.DeserializeSyncVars(reader, initialState); if (initialState) { this.myValue = ZigZag.Decode(reader.Read(8)); return; } ulong dirtyMask = reader.Read(1); if ((dirtyMask &amp; 1UL) != 0UL) { this.myValue = ZigZag.Decode(reader.Read(8)); } }  last updated for Mirage v101.8.0 "},{"title":"Vector Pack","type":0,"sectionRef":"#","url":"docs/guides/bit-packing/vector-pack","content":"","keywords":""},{"title":"Use cases​","type":1,"pageTitle":"Vector Pack","url":"docs/guides/bit-packing/vector-pack#use-cases","content":"A Vector value with a maximum value "},{"title":"Supported Types​","type":1,"pageTitle":"Vector Pack","url":"docs/guides/bit-packing/vector-pack#supported-types","content":"Vector2 Vector2PackAttributeVector3 Vector3PackAttribute "},{"title":"Example 1​","type":1,"pageTitle":"Vector Pack","url":"docs/guides/bit-packing/vector-pack#example-1","content":"A Position in bounds +-100 in all XYZ with 0.05 precision for all axis public class MyNetworkBehaviour : NetworkBehaviour { [SyncVar, Vector3Pack(100f, 100f, 100f, 0.05f)] public Vector3 Position; }  "},{"title":"Example 2​","type":1,"pageTitle":"Vector Pack","url":"docs/guides/bit-packing/vector-pack#example-2","content":"A Position in bounds +-100 in all XZ with 0.05 precision, but with +-20 and precision 0.1 in y-axis public class MyNetworkBehaviour : NetworkBehaviour { [SyncVar, Vector3Pack(100f, 20f, 100f, 0.05f, 0.1f, 0.05f)] public Vector3 Position; }  "},{"title":"Example 3​","type":1,"pageTitle":"Vector Pack","url":"docs/guides/bit-packing/vector-pack#example-3","content":"A position in a 2D map public class MyNetworkBehaviour : NetworkBehaviour { [SyncVar, Vector2Pack(1000f, 80f, 0.05f)] public Vector2 Position; }  "},{"title":"Generated Code​","type":1,"pageTitle":"Vector Pack","url":"docs/guides/bit-packing/vector-pack#generated-code","content":"Source: [SyncVar, Vector3Pack(100f, 20f, 100f, 0.05f, 0.1f, 0.05f)] public int myValue1; [SyncVar, Vector2Pack(1000f, 80f, 0.05f)] public int myValue2;  Generated:  private Vector3Packer myValue1__Packer = new Vector3Packer(1100f, 20f, 100f, 0.05f, 0.1f, 0.05f); private Vector2Packer myValue2__Packer = new Vector2Packer(1000f, 80f, 0.05f, 0.05f); public override bool SerializeSyncVars(NetworkWriter writer, bool initialState) { ulong syncVarDirtyBits = base.SyncVarDirtyBits; bool result = base.SerializeSyncVars(writer, initialize); if (initialState) { myValue1__Packer.Pack(writer, this.myValue1); myValue2__Packer.Pack(writer, this.myValue2); return true; } writer.Write(syncVarDirtyBits, 2); if ((syncVarDirtyBits &amp; 1UL) != 0UL) { myValue1__Packer.Pack(writer, this.myValue1); result = true; } if ((syncVarDirtyBits &amp; 2UL) != 0UL) { myValue2__Packer.Pack(writer, this.myValue2); result = true; } return result; } public override void DeserializeSyncVars(NetworkReader reader, bool initialState) { base.DeserializeSyncVars(reader, initialState); if (initialState) { this.myValue1 = myValue1__Packer.Unpack(reader); this.myValue2 = myValue2__Packer.Unpack(reader); return; } ulong dirtyMask = reader.Read(2); if ((dirtyMask &amp; 1UL) != 0UL) { this.myValue1 = myValue1__Packer.Unpack(reader); } if ((dirtyMask &amp; 2UL) != 0UL) { this.myValue2 = myValue2__Packer.Unpack(reader); } }  last updated for Mirage v101.8.0 "},{"title":"Callbacks Overview","type":0,"sectionRef":"#","url":"docs/guides/callbacks/","content":"","keywords":""},{"title":"Remote Actions​","type":1,"pageTitle":"Callbacks Overview","url":"docs/guides/callbacks/#remote-actions","content":"Remote actions allow you to call a method in your script across the network. You can make the server call methods on all clients or individual clients specifically. You can also make clients call methods on the server. Using remote actions, you can pass data as parameters to your methods in a very similar way to how you call methods in local (non-multiplayer) projects. "},{"title":"Networking Callbacks​","type":1,"pageTitle":"Callbacks Overview","url":"docs/guides/callbacks/#networking-callbacks","content":"Networking callbacks allow you to hook into built-in Mirage events which occur during the course of the game, such as when players join or leave, when game objects are created or destroyed, or when a new Scene is loaded. There are two types of networking callbacks that you can implement: Network manager callbacks, for callbacks relating to the network manager itself (such as when clients connect or disconnect)Network behaviour callbacks, for callbacks relating to individual networked game objects (such as when its Start function is called, or what this particular game object should do if a new player joins the game) "},{"title":"Network Messages​","type":1,"pageTitle":"Callbacks Overview","url":"docs/guides/callbacks/#network-messages","content":"Network messages are a “lower level” approach to sending messages (although they are still classed as part of the networking &quot;High-level API&quot;). They allow you to send data directly between clients and the server using scripting. You can send basic types of data (int, string, etc) as well as most common Unity types (such as Vector3). Since you implement this yourself, these messages are not associated directly with any particular game objects or Unity events - it is up to you to decide their purpose and implement them! "},{"title":"Network Manager Callbacks","type":0,"sectionRef":"#","url":"docs/guides/callbacks/network-manager","content":"Network Manager Callbacks See also NetworkManager in the API Reference. NetworkManager is a helper class with instance references to the other major parts of the Mirage network.","keywords":""},{"title":"Network Behaviour Callbacks","type":0,"sectionRef":"#","url":"docs/guides/callbacks/network-behaviour","content":"","keywords":""},{"title":"Server Only​","type":1,"pageTitle":"Network Behaviour Callbacks","url":"docs/guides/callbacks/network-behaviour#server-only","content":"OnStartServer called when behaviour is spawned on the server OnStopServer called when behaviour is destroyed or unspawned on the server OnSerialize called when behaviour is serializing before it is sent to a client, when overriding make sure to call base.OnSerialize "},{"title":"Client only​","type":1,"pageTitle":"Network Behaviour Callbacks","url":"docs/guides/callbacks/network-behaviour#client-only","content":"OnStartClient called when behaviour is spawned on a client OnStartAuthority called when behaviour has authority when it is spawned (eg local player)called when behaviour is given authority by the sever OnStartLocalPlayer called when the behaviour is on the local character object OnStopAuthority called when authority is taken from the object (eg local player is replaced but not destroyed) OnStopClient called when an object is destroyed on a client by the ObjectDestroyMessage or ObjectHideMessage messages Example flows Below is some example call order for different modes note Start is called by Unity before the first frame, while normally this happens after Mirage's callbacks. But if you don't call NetworkServer.Spawn the same frame as Instantiate then start may be called first "},{"title":"Server mode​","type":1,"pageTitle":"Network Behaviour Callbacks","url":"docs/guides/callbacks/network-behaviour#server-mode","content":"When NetworkServer.Spawn is called (eg when new client connections and a player is created) OnStartServerOnRebuildObserversStart "},{"title":"Client mode​","type":1,"pageTitle":"Network Behaviour Callbacks","url":"docs/guides/callbacks/network-behaviour#client-mode","content":"When the local player is spawned for the client OnStartAuthorityOnStartClientOnStartLocalPlayerStart "},{"title":"Host mode​","type":1,"pageTitle":"Network Behaviour Callbacks","url":"docs/guides/callbacks/network-behaviour#host-mode","content":"These are only called on the Player Game Objects when a client connects: OnStartServerOnRebuildObserversOnStartAuthorityOnStartClientOnSetHostVisibilityOnStartLocalPlayerStart "},{"title":"Clock Synchronization","type":0,"sectionRef":"#","url":"docs/guides/clock-sync","content":"Clock Synchronization For many features, you need the clock to be synchronized between the client and the server. Mirage does that automatically for you. To get the current time use this code: double now = NetworkTime.Time; It will return the same value on the client and the server. It starts at 0 when the server starts. note The time is a double and should never be cast to a float. Casting this down to a float means the clock will lose precision after some time: after 1 day, the accuracy goes down to 8 msafter 10 days, the accuracy is 62 msafter 30 days, the accuracy is 250 mafter 60 days, the accuracy is 500 ms Mirage will also calculate the Return Trip Time as seen by the application: double rtt = NetworkTime.Rtt; note Return RTT will also be affected by the frame rate. A higher frame rate will mean less delay before the server reads the ping message and replies. You can check the precision using: double timeStandardDeviation = NetworkTime.TimeSd; For example, if this returns 0.2, it means the time measurements swing up and down roughly 0.2 seconds. Network time is smoothing out the values using Exponential moving average. You can configure how often you want the client to send pings using: NetworkTime.PingInterval = 2.0f; You can configure how quickly results will change using: NetworkTime.PingWindowSize = 10; A higher number will result in smoother results, but a longer time to adjust to changes.","keywords":""},{"title":"Community Guides","type":0,"sectionRef":"#","url":"docs/guides/community-guides/","content":"Community Guides This section contains guides written by the community rather than by the developers themselves Mirage Quick Start Guide by StephenAllenGames.co.uk tip If you want to submit a guide either create a pull request or ask in the Discord server.","keywords":""},{"title":"Data Types","type":0,"sectionRef":"#","url":"docs/guides/data-types","content":"","keywords":""},{"title":"Game Objects​","type":1,"pageTitle":"Data Types","url":"docs/guides/data-types#game-objects","content":"Game Objects in SyncVars, SyncLists, and SyncDictionaries are fragile in some cases and should be used with caution. As long as the game object already exists on both the server and the client, the reference should be fine. When the sync data arrives at the client, the referenced game object may not yet exist on that client, resulting in null values in the sync data. This is because internally Mirage passes the NetId from the NetworkIdentity and tries to look it up on the client's NetworkIdentity.World.Spawned dictionary. If the object hasn't been spawned on the client yet, no match will be found. It could be in the same payload, especially for joining clients, but after the sync data from another object. It could also be null because the game object is excluded from a client due to network visibility, e.g. NetworkProximityChecker. You may find that it's more robust to sync the NetworkIdentity.NetID (uint) instead, and do your own lookup inNetworkIdentity.World.Spawned to get the object, perhaps in a coroutine:  public GameObject target; [SyncVar(hook = nameof(OnTargetChanged))] public uint targetID; void OnTargetChanged(uint _, uint newValue) { if (NetworkIdentity.World.Spawned.TryGetValue(targetID, out NetworkIdentity identity)) target = identity.gameObject; else StartCoroutine(SetTarget()); } IEnumerator SetTarget() { while (target == null) { yield return null; if (NetworkIdentity.World.SpawnedObjects.TryGetValue(targetID, out NetworkIdentity identity)) target = identity.gameObject; } }  "},{"title":"Custom Data Types​","type":1,"pageTitle":"Data Types","url":"docs/guides/data-types#custom-data-types","content":"Sometimes you don't want Mirage to generate serialization for your own types. For example, instead of serializing quest data, you may want to serialize just the quest id, and the receiver can look up the quest by id in a predefined list. Sometimes you may want to serialize data that uses a different type not supported by Mirage, such as DateTime or System.Uri. You can add support for any type by adding extension methods to NetworkWriter and NetworkReader. For example, to add support for DateTime, add this somewhere in your project: public static class DateTimeReaderWriter { public static void WriteDateTime(this NetworkWriter writer, DateTime dateTime) { writer.WriteInt64(dateTime.Ticks); } public static DateTime ReadDateTime(this NetworkReader reader) { return new DateTime(reader.ReadInt64()); } }  ...then you can use DateTime in your [ServerRpc] or SyncList "},{"title":"Inheritance and Polymorphism​","type":1,"pageTitle":"Data Types","url":"docs/guides/data-types#inheritance-and-polymorphism","content":"Sometimes you might want to send a polymorphic data type to your commands. Mirage does not serialize the type name to keep messages small and for security reasons, therefore Mirage cannot figure out the type of object it received by looking at the message. caution This code does not work out of the box. class Item { public string name; } class Weapon : Item { public int hitPoints; } class Armor : Item { public int hitPoints; public int level; } class Player : NetworkBehaviour { [ServerRpc] void ServerRpcEquip(Item item) { // IMPORTANT: this does not work. Mirage will pass you an object of type item // even if you pass a weapon or an armor. if (item is Weapon weapon) { // The item is a weapon, // maybe you need to equip it in the hand } else if (item is Armor armor) { // you might want to equip armor in the body } } [ServerRpc] void ServerEquipArmor(Armor armor) { // IMPORTANT: this does not work either, you will receive an armor, but // the armor will not have a valid Item.name, even if you passed an armor with name } }  ServerRpcEquip will work if you provide a custom serializer for the Item type. For example:  public static class ItemSerializer { const byte WEAPON = 1; const byte ARMOR = 2; public static void WriteItem(this NetworkWriter writer, Item item) { if (item is Weapon weapon) { writer.WriteByte(WEAPON); writer.WriteString(weapon.name); writer.WritePackedInt32(weapon.hitPoints); } else if (item is Armor armor) { writer.WriteByte(ARMOR); writer.WriteString(armor.name); writer.WritePackedInt32(armor.hitPoints); writer.WritePackedInt32(armor.level); } } public static Item ReadItem(this NetworkReader reader) { byte type = reader.ReadByte(); switch(type) { case WEAPON: return new Weapon { name = reader.ReadString(), hitPoints = reader.ReadPackedInt32() }; case ARMOR: return new Armor { name = reader.ReadString(), hitPoints = reader.ReadPackedInt32(), level = reader.ReadPackedInt32() }; default: throw new Exception($&quot;Invalid weapon type {type}&quot;); } } }  "},{"title":"Scriptable Objects​","type":1,"pageTitle":"Data Types","url":"docs/guides/data-types#scriptable-objects","content":"People often want to send scriptable objects from the client or server. For example, you may have a bunch of swords created as scriptable objects and you want to put the equipped sword in a SyncVar. This will work fine, Mirage will generate a reader and writer for scriptable objects by calling ScriptableObject.CreateInstance and copy all the data. However, the generated reader and writer are not suitable for every occasion. Scriptable objects often reference other assets such as textures, prefabs, or other types that can't be serialized. Scriptable objects are often saved in the Resources folder or they can sometimes have a large amount of data in them. The generated reader and writers may not work or may be inefficient for these situations. Instead of passing the scriptable object data, you can pass the name and the other side can look up the same object by name. This way you can have any kind of data in your scriptable object. You can do that by providing a custom reader and writer. Here is an example: [CreateAssetMenu(fileName = &quot;New Armor&quot;, menuName = &quot;Armor Data&quot;)] class Armor : ScriptableObject { public int Hitpoints; public int Weight; public string Description; public Texture2D Icon; // ... } public static class ArmorSerializer { public static void WriteArmor(this NetworkWriter writer, Armor armor) { // No need to serialize the data, just the name of the armor. writer.WriteString(armor.name); } public static Armor ReadArmor(this NetworkReader reader) { // Load the same armor by name. The data will come from the asset in Resources folder. return Resources.Load&lt;Armor&gt;(reader.ReadString()); } }  "},{"title":"Mirage Quick Start Guide V0.1","type":0,"sectionRef":"#","url":"docs/guides/community-guides/mirage-quick-start-guide","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Mirage Quick Start Guide V0.1","url":"docs/guides/community-guides/mirage-quick-start-guide#installation","content":"Before everything, to install Mirage we need to add a new package manager repository to our project. To do this, we can go into Edit menu and then Project Settings. This will open a new Editor Window with multiple tabs. The one we are looking for is Package Manager, so click there. Once you click there, you should add a new Package Manager, so complete the fields as we show next and click apply Name: OpenUPM Url: https://package.openupm.com Scopes: - com.cysharp.unitask - com.openupm - com.miragenet   Once everything is ready, the next step is to close the Project Settings window, and jump into the Package Manager. So for this, we click on Window menu and then Package Manager. At this window, we will click on a small button that says (probably, at today date on Unity Editor 2021.13f) Packages: In Project, here we have to select My registries. Once, you've done that, we should be able to see Mirage and a few transport and also plugins in that list. After selecting, you can choose the version on the list below the name, otherwise, you can just click install on the bottom right part of the window and after a loading bar, that's it. You already have Mirage API on your code, congrats!  note Mirage already includes a UDP transport, so for this guide is not necessary to download anything else than Mirage. "},{"title":"Creating A Network Manager​","type":1,"pageTitle":"Mirage Quick Start Guide V0.1","url":"docs/guides/community-guides/mirage-quick-start-guide#creating-a-network-manager","content":"Here we will be following a couple of steps, so it is easier to follow me. Right-click on your Scenes folder, then click on Create new scene, save it as Main Scene, and add it to build settingsMirage already has a menu for creating a base network manager, so right-click on your Scene hierarchy then go to Create =&gt; Network =&gt; NetworkManagerNow you will see a pre-configured GameObject called NetworkManager  Important stuff about these objects CharacterSpawner is the one will be in charge of spawning your player later, so this is very important object. Since we are not changing scenes between server open or close, we could disable the NetworkSceneManager, but we can leave it as it is. UdpSocketFactory is the one that does the connection, so you can change the IP and port if necessary there. Now let's set up a few things on the scene, to make it look more like a game Add a simple Plane floor with: positions (0, -1, 0)scale (2, 2, 2) Next, we add a GameObject, name with the name StartPosition1 set position (1, 1, 1) We go back to our NetworkManager GO, over Character Spawner component we will change the Player Spawn Method from Random to Round Robin. As a second step, we will add to the Start Positions list the one we created in the previous step. (Optional) you can create more positions if you want, and you can add them to the list, is not necessary but maybe looks nice. "},{"title":"Player Movement​","type":1,"pageTitle":"Mirage Quick Start Guide V0.1","url":"docs/guides/community-guides/mirage-quick-start-guide#player-movement","content":"So after we configure the basics, we need to create our player prefab in order to be able to spawn ourselves in the network. As before, we will follow a couple of easy steps. Create a capsule in the scene hierarchy and name it PlayerAttach a NetworkIdentity and NetworkTransform component into the capsule.Tick Client Authority on the NetworkTransform This is how our Player GO components should look right now  NOTE: Is not needed to set anything else here, Server Object Manager and Client Object Manager will be set dynamically by Mirage later. Next steps: Add a new Script, call it PlayerScriptThen drag this GO with the mouse into the assets folder (You should probably create a Prefabs folder later as a good practice) and release the mouse there. That will create a Prefab for us. (You can notice this was successful because your GO icon in the scene hierarchy will be blue now)Then delete Player from the scene At this stage, our player is done, so right now we need to tell Mirage who is our player in order to spawn it. So this is very easy, just go to your NetworkManager GO and open (if it is not) Character Spawner, then drag the player prefab we created before in the Player Prefab field.  The last step we will need to do is simple: go to the script we created before (you can go into the assets folder and it will be there) and double click it and it will open your IDE. So what we will need to do is simple: tell how we are moving the user, and also to set the camera as a child of the player. We can do that simply like this: using Mirage; using UnityEngine; namespace GettingStarted { public class PlayerScript : NetworkBehaviour { private void Awake() { Identity.OnStartLocalPlayer.AddListener(OnStartLocalPlayer); } private void OnStartLocalPlayer() { Camera.main.transform.SetParent(transform); Camera.main.transform.localPosition = new Vector3(0, 0, 0); } private void Update() { if (!IsLocalPlayer) { return; } float moveX = Input.GetAxis(&quot;Horizontal&quot;) * Time.deltaTime * 110.0f; float moveZ = Input.GetAxis(&quot;Vertical&quot;) * Time.deltaTime * 4f; transform.Rotate(0, moveX, 0); transform.Translate(0, 0, moveZ); } } }  Press play in Unity editor and... what happened? Why is our player don't spawning? Well, the question is very simple. You need to start the server somehow, and that's what coming next, but before... "},{"title":"Types of servers​","type":1,"pageTitle":"Mirage Quick Start Guide V0.1","url":"docs/guides/community-guides/mirage-quick-start-guide#types-of-servers","content":"On Mirage has two types of servers: You can create a server-only game, which runs as an Authoritative kind, and takes decisions for every player and you must join always as a client (For more info you can click here).You can create a host server. Which will work as client + server and will take decisions for every other client in the network Which one is the best? That depends on your game, we can't know certainly in this guide. "},{"title":"Why are you telling me this now?​","type":1,"pageTitle":"Mirage Quick Start Guide V0.1","url":"docs/guides/community-guides/mirage-quick-start-guide#why-are-you-telling-me-this-now","content":"Because in this guide we will be working on Server + Client type, so we want you to know that there are other ways to connect to the Server besides this guide. "},{"title":"Continuing with the guide​","type":1,"pageTitle":"Mirage Quick Start Guide V0.1","url":"docs/guides/community-guides/mirage-quick-start-guide#continuing-with-the-guide","content":"Now, we need to connect to our server, so for this, we have two roads, write down a script and make the server start, or just use the HUD. "},{"title":"Initiate Server By Scripting​","type":1,"pageTitle":"Mirage Quick Start Guide V0.1","url":"docs/guides/community-guides/mirage-quick-start-guide#initiate-server-by-scripting","content":"This one is pretty simple, we just need to go to our NetworkManager GO then Create a new script, we can call it StartServerThen server starts should look like this: using Mirage; using UnityEngine; namespace GettingStarted { public class StartServer : MonoBehaviour { [SerializeField] private NetworkManager networkManager; private void Start() { if (!networkManager) { return; } networkManager.Server.StartServer(networkManager.Client); } } }  After we save the file, we go back into our NetworkManager GO, and assign the NetworkManager field to the script.  "},{"title":"Understanding Network Hud​","type":1,"pageTitle":"Mirage Quick Start Guide V0.1","url":"docs/guides/community-guides/mirage-quick-start-guide#understanding-network-hud","content":"TODO From here: This guide was written for Mirror so some information might be out-of-date for Mirage "},{"title":"Names And Colours​","type":1,"pageTitle":"Mirage Quick Start Guide V0.1","url":"docs/guides/community-guides/mirage-quick-start-guide#names-and-colours","content":"Player name above heads Inside your player Prefab, create an empty GameObjectname it something like FloatingInfo position Y to 1.5 scale X to -1 Inside that FloatingInfo, create a 3D text using Unity menu (GameObject - 3D Object - 3D Text),Set it up as shown in the picture below  Update your PlayerScript.cs with this: using Mirage; using UnityEngine; namespace QuickStart { public class PlayerScript : NetworkBehaviour { public TextMesh playerNameText; public GameObject floatingInfo; private Material playerMaterialClone; [SyncVar(hook = nameof(OnNameChanged))] public string playerName; [SyncVar(hook = nameof(OnColorChanged))] public Color playerColor = Color.white; [ServerRpc] public void CmdSetupPlayer(string _name, Color _col) { // player info sent to server, then server updates sync vars which handles it on all clients playerName = _name; playerColor = _col; } private void Awake() { Identity.OnStartLocalPlayer.AddListener(OnStartLocalPlayer); } private void OnStartLocalPlayer() { Camera.main.transform.SetParent(transform); Camera.main.transform.localPosition = new Vector3(0, 0, 0); floatingInfo.transform.localPosition = new Vector3(0, -0.3f, 0.6f); floatingInfo.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f); string name = &quot;Player&quot; + Random.Range(100, 999); Color color = new Color(Random.Range(0f, 1f), Random.Range(0f, 1f), Random.Range(0f, 1f)) CmdSetupPlayer(name, color); } private void OnNameChanged(string _Old, string _New) { playerNameText.text = playerName; } private void OnColorChanged(Color _Old, Color _New) { playerNameText.color = _New; playerMaterialClone = new Material(GetComponent&lt;Renderer&gt;().material); playerMaterialClone.color = _New; GetComponent&lt;Renderer&gt;().material = playerMaterialClone; } private void Update() { if (!IsLocalPlayer) { // make non-local players run this floatingInfo.transform.LookAt(Camera.main.transform); return; } float moveX = Input.GetAxis(&quot;Horizontal&quot;) * Time.deltaTime * 110.0f; float moveZ = Input.GetAxis(&quot;Vertical&quot;) * Time.deltaTime * 4f; transform.Rotate(0, moveX, 0); transform.Translate(0, 0, moveZ); } } }  Add the PlayerNameText and FloatingInfo objects into the script on the player prefab, as shown below.  Now if you build and run, host on one, and join on the other, you will see player names and colors synced across the network! Well done, 5 stars to you!  "},{"title":"Part 11​","type":1,"pageTitle":"Mirage Quick Start Guide V0.1","url":"docs/guides/community-guides/mirage-quick-start-guide#part-11","content":"A scene networked object all can access and adjust. Create a SceneScript.cs, and add it onto an empty GameObject in the scene called SceneScript. Then create a Canvas with text and a button, similar to the image below.  Add the sceneScript variable, Awake function, and CmdSendPlayerMessage to PlayerScript.cs Also add the new playerName joined line to CmdSetupPlayer(); private SceneScript sceneScript; void Awake() { //allow all players to run this sceneScript = GameObject.FindObjectOfType&lt;SceneScript&gt;(); Identity.OnStartLocalPlayer.AddListener(OnStartLocalPlayer); } [ServerRpc] public void CmdSendPlayerMessage() { if (sceneScript) { sceneScript.statusText = $&quot;{playerName} says hello {Random.Range(10, 99)}&quot;; } } [ServerRpc] public void CmdSetupPlayer(string _name, Color _col) { //player info sent to server, then server updates sync vars which handles it on all clients playerName = _name; playerColor = _col; sceneScript.statusText = $&quot;{playerName} joined.&quot;; } public void OnStartLocalPlayer() { sceneScript.playerScript = this; //. . . . ^ new line to add here  Add this code to SceneScript.cs using Mirage; using UnityEngine; using UnityEngine.UI; namespace QuickStart { public class SceneScript : NetworkBehaviour { public Text canvasStatusText; public PlayerScript playerScript; [SyncVar(hook = nameof(OnStatusTextChanged))] public string statusText; void OnStatusTextChanged(string _Old, string _New) { //called from sync var hook, to update info on screen for all players canvasStatusText.text = statusText; } public void ButtonSendMessage() { if (playerScript != null) { playerScript.CmdSendPlayerMessage(); } } } }  Attach the ButtonSendMessage function to your Canvas Button.Attach Canvas Scene Text to SceneScript variable. ignore SceneScript’s, playerScript variable, it automatically sets this!  Now if you build and run, host, and join, you can send messages, and have a text log for actions! Wahooo!  Experiment and adjust, have fun!  "},{"title":"Weapon Switching​","type":1,"pageTitle":"Mirage Quick Start Guide V0.1","url":"docs/guides/community-guides/mirage-quick-start-guide#weapon-switching","content":"Weapon switching! The code bits. Add the following to your PlayerScript.cs private int selectedWeaponLocal = 1; public GameObject[] weaponArray; [SyncVar(hook = nameof(OnWeaponChanged))] public int activeWeaponSynced; void OnWeaponChanged(int _Old, int _New) { // disable old weapon // in range and not null if (0 &lt; _Old &amp;&amp; _Old &lt; weaponArray.Length &amp;&amp; weaponArray[_Old] != null) { weaponArray[_Old].SetActive(false); } // enable new weapon // in range and not null if (0 &lt; _New &amp;&amp; _New &lt; weaponArray.Length &amp;&amp; weaponArray[_New] != null) { weaponArray[_New].SetActive(true); } } [ServerRpc] public void CmdChangeActiveWeapon(int newIndex) { activeWeaponSynced = newIndex; } void Awake() { // disable all weapons foreach (var item in weaponArray) { if (item != null) { item.SetActive(false); } } }  Add the weapon switch button in Update. Only the local player switches its own weapon, so it goes below the !IsLocalPlayer check. void Update() { if (!IsLocalPlayer) { // make non-local players run this floatingInfo.transform.LookAt(Camera.main.transform); return; } float moveX = Input.GetAxis(&quot;Horizontal&quot;) * Time.deltaTime * 110.0f; float moveZ = Input.GetAxis(&quot;Vertical&quot;) * Time.deltaTime * 4f; transform.Rotate(0, moveX, 0); transform.Translate(0, 0, moveZ); if (Input.GetButtonDown(&quot;Fire2&quot;)) //Fire2 is mouse 2nd click and left alt { selectedWeaponLocal += 1; if (selectedWeaponLocal &gt; weaponArray.Length) { selectedWeaponLocal = 1; } CmdChangeActiveWeapon(selectedWeaponLocal); } }  Weapon models Add the basic cube weapons first, change these later. Double click your player prefab to enter itAdd a &quot;WeaponsHolder&quot; empty GameObject, with position and rotation at 0,0,0.Inside that GameObject, create a cube from the Unity menu, (GameObject, 3D object, cube)- Remove the box colliders.Rename this Weapon1, change position and scale to match the below pictures.  Duplicate weapon 1 for Weapon 2, and change its scale and position, now you should have 2 different looking ‘weapons’!  "},{"title":"Part 14​","type":1,"pageTitle":"Mirage Quick Start Guide V0.1","url":"docs/guides/community-guides/mirage-quick-start-guide#part-14","content":"Weapon switch finale. Add these 2 GameObjects to your PlayerScript.cs weapons array.Disable weapon 2, so only weapon 1 shows when spawning.  Build and run! You should see each player switching weapons, and whatever your player has equipped, will auto show on new joining players (sync var and hook magic!)  "},{"title":"Development Servers Overview","type":0,"sectionRef":"#","url":"docs/guides/development-servers/","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Development Servers Overview","url":"docs/guides/development-servers/#introduction","content":"During your development with Mirage, you will need to test your project as a client and as a server. There are a few possible ways to test your project: Default build: Host/client as one and connect with another build/editor to the host locally on 1 computer.Server build: Server is a separate executable. You can place it on your computer run it and connect to it as a client.Dedicated Server: Same as the server build but placed on an external machine, you connect to it with the server's external IP. This guide will focus on the &quot;Dedicated Server&quot; option. There are multiple providers and even self-hosted dedicated machines. All possibilities still go through the same process to ensure connectivity to clients. A few requirements for a dedicated server: Port forwarding (Not strictly necessary but makes everything a lot easier without needing NAT punch-through)Firewall exceptionsComputer/machine that stays online and accessible whenever you need it. In the upcoming sections, we will go through setting up a provider with the free tier. Always double-check that you do not select a paid feature as this is purely meant as a short-term period to test out basic functionality during the development of your project. "},{"title":"Amazon Web Services (AWS)​","type":1,"pageTitle":"Development Servers Overview","url":"docs/guides/development-servers/#amazon-web-services-aws","content":"See this guide: AWS setup "},{"title":"Google Compute Engine​","type":1,"pageTitle":"Development Servers Overview","url":"docs/guides/development-servers/#google-compute-engine","content":"See this guide: Google cloud setup "},{"title":"Microsoft Azure​","type":1,"pageTitle":"Development Servers Overview","url":"docs/guides/development-servers/#microsoft-azure","content":"Microsoft Azure (as of the time of writing) allows setting up a windows instance during the free trial without an active payment method. To be added "},{"title":"Self-Hosted Dedicated Server​","type":1,"pageTitle":"Development Servers Overview","url":"docs/guides/development-servers/#self-hosted-dedicated-server","content":"A self-hosted dedicated server is the same as the other providers but you provide the hardware, internet connection, and costs for running the computer. Most of the time this is the cheapest option during development if you already have an extra machine. Preferably you would put the machine on a different network (to simulate the conditions as the other providers). This would mean you could connect to the machine and put your server build on whenever you need and have access to the router and security settings of the machine for port forwarding and firewall exceptions. In essence, this is the simplest setup but does require extra hardware. "},{"title":"Google Cloud Services","type":0,"sectionRef":"#","url":"docs/guides/development-servers/google-cloud","content":"","keywords":""},{"title":"Before you begin​","type":1,"pageTitle":"Google Cloud Services","url":"docs/guides/development-servers/google-cloud#before-you-begin","content":"1) In the Cloud Console, on the project selector page, select or create a Cloud project. note If you don't plan to keep the resources that you create in this procedure, create a project instead of selecting an existing project. After you finish these steps, you can delete the project, removing all resources associated with the project. Go to the project selector page 2) You may need to enable billing for your Google Cloud project. If you have free credits (see above) then these will be used first. Learn how to confirm billing is enabled for your project. "},{"title":"Setting up a new Server​","type":1,"pageTitle":"Google Cloud Services","url":"docs/guides/development-servers/google-cloud#setting-up-a-new-server","content":"Start by creating and configuring a new Compute Engine instance. 1) In the Cloud Console, go to the VM instances page: Go to the VM instances page If this is your first instance you will see a dialog prompting you to create a new virtual machine  2) Click Create to get started. 3) On the Create an instance page, configure your instance as follows: - Name your instance. This tutorial uses the instance name `mirror-instance-demo` throughout. - Select the region and zone in which you want your instance to be hosted. This tutorial uses the region `us-central1 (Iowa)` and the zone `us-central1-a` throughout. - Machine configuration depends on the size of your game. For a simple example, we can use a small server. - select `N1` for series - select `f1-micro` for machine type - In the Boot disk section, click Change. The Boot disk dialog will pop up. - Change the disk type to SSD Persistent Disk.   4) Boot disk can be left as default 10gb standard persistent disk with Debian GNU/Linux 9 (stretch) for this tutorial. You may want to change it to best fit your needs. You can instead use an SSD or increase its size, however, this will increase the monthly cost.  note The monthly estimate should be shown at the top right next to Name. 5) To configure Network settings first example the Management, security, disks, networking, solo tenancy section, then click on the Networking tab.  6) Set a Network tag, this will allow you to set up firewall rules later on. This tutorial use mirror-demo as the tag  7) Set up a static IP address for your instance a) Under **Network interfaces** click on `default` and it will bring up a config menu b) Select the **External IP** dropdown and select `Create IP address` c) Enter a name for this IP and press **Reserve**. For this tutorial, we will use `mirror-demo-ip`   8) Create your instance. Press the Create button at the bottom of the page to finish set-up and create your instance "},{"title":"Configure Firewall​","type":1,"pageTitle":"Google Cloud Services","url":"docs/guides/development-servers/google-cloud#configure-firewall","content":"This will allow other people to connect to your server using its IP and port 1) In the Cloud Console, go to the Firewall page. Go to the Firewall page 2) Click Create firewall rule. 3) On the Create a firewall rule page, fill out the form as follows: - Name: `mirror-demo-rule` - Target tags: `mirror-demo` - Source filter: IP ranges - Source IP ranges: 0.0.0.0/0 - Protocols or ports: Select UDP, and then enter port 7777 into the field provided.  note UDP and port 7777 are the default settings for the socket, if you are using a different socket you will need to find out what settings that uses.  4) Press Create to confirm the setting and create the rule. "},{"title":"Connect to your new instance​","type":1,"pageTitle":"Google Cloud Services","url":"docs/guides/development-servers/google-cloud#connect-to-your-new-instance","content":"Once your instance has finished being created you can press the SSH button to connect to your instance in your web browser  "},{"title":"Setting up the Linux instance​","type":1,"pageTitle":"Google Cloud Services","url":"docs/guides/development-servers/google-cloud#setting-up-the-linux-instance","content":"When you first connect you will need to set up a few things 1) First, update the list of packages sudo apt-get update  2) Install screen and unzip sudo apt-get install -y screen unzip  screen allows you to have multiple terminals, allows you to do other stuff while your game is running unzip unzips can be used to extract files from a ZIP file after you upload it to the instance  "},{"title":"Build your game​","type":1,"pageTitle":"Google Cloud Services","url":"docs/guides/development-servers/google-cloud#build-your-game","content":"Build your game with Target Platform Linux and Server Build ticked  "},{"title":"Upload and extract your game​","type":1,"pageTitle":"Google Cloud Services","url":"docs/guides/development-servers/google-cloud#upload-and-extract-your-game","content":"Once you have built your game zip the folder so that you can upload it to your server. In the SSH connection window click on the settings cogwheel and select Upload File then find and select your zipped build folder.  This should upload the game folder to the home directory. If you need to go to the home directory you can use: cd ~  note The destination will be /home/username where the username should be the cloud account you are logged into.  Once your file has finished the upload you can extract the files unzip ./mirror-demo.zip  "},{"title":"Run server​","type":1,"pageTitle":"Google Cloud Services","url":"docs/guides/development-servers/google-cloud#run-server","content":"1) Move into the game folder cd mirror-demo  2) Mark game as executable chmod +x ./mirror-demo.x86_64  You should now be able to run your game server! The following is optional but will most likely be useful 3) Start your server in a detached screen screen -d -m -S mirrorServer ./mirror-demo.x86_64 -logfile ~/server.log  The parts of the command above: screen -d -m will create the new terminal in detached mode-S mirrorServer name of the screen./mirror-demo.x86_64 your game server file-logfile ~/server.log unity argument for log file location, this will create a log file in the home directory 4) Create a start file so you can start your server the same way each time a) create `start.sh` ``` echo &quot;screen -d -m -S mirrorServer ./mirror-demo.x86_64 -logfile ~/server.log&quot; &gt; ./start.sh ``` b) mark as executable ```sh chmod +x ./start.sh ```  5) Run your server ./start.sh  "},{"title":"Using Screen​","type":1,"pageTitle":"Google Cloud Services","url":"docs/guides/development-servers/google-cloud#using-screen","content":"Here are a few useful commands for using screen List active screens screen -ls  Attach to existing screen, process-id is shown when calling screen -lsscreen name is given by -S when creating the screen, for this tutorial it was mirrorServer screen -r &lt;process-id | screen name&gt;  Detach from screen press CTRL A + D Stop your game Once attached to a screen you can press CTRL + C to stop the process, this will stop your game and close the screen "},{"title":"View log files​","type":1,"pageTitle":"Google Cloud Services","url":"docs/guides/development-servers/google-cloud#view-log-files","content":"You can use the -logfile ~/path/to/log.log argument for Unity when starting your game server. This will cause the logs to be written to a file instead of to the terminal. This will means recent logs won't show up in screen -r. you can use the tail command to view the end of the log file tail -n 50 ./server.log  you can use the -n argument to set how many lines to show you can use the -f argument to follow the end of the file stream showing you any new logs that are written to the file in real-time. You will need to press CTRL + C to exit follow mode "},{"title":"Clean up after tutorial​","type":1,"pageTitle":"Google Cloud Services","url":"docs/guides/development-servers/google-cloud#clean-up-after-tutorial","content":"If you used an existing project you will need to delete the following: VM instanceFirewall rule If you have created a new project you should be able to just delete the project. Go to the Manage resources page "},{"title":"Amazon Web Services (AWS)","type":0,"sectionRef":"#","url":"docs/guides/development-servers/aws","content":"","keywords":""},{"title":"1. Account Creation​","type":1,"pageTitle":"Amazon Web Services (AWS)","url":"docs/guides/development-servers/aws#1-account-creation","content":"Go to the Account creation page and sign up with your details and payment method (e.g. credit card). Adding the payment method is necessary to run a Windows instance on AWS. "},{"title":"2. Setting up an instance with the EC2 Management Console​","type":1,"pageTitle":"Amazon Web Services (AWS)","url":"docs/guides/development-servers/aws#2-setting-up-an-instance-with-the-ec2-management-console","content":"After setting up your account you should be logged in. Always make sure you're in your correct region so it's a good habit to check in the top right corner. Change it to the closest location to you now. After this click on Services in the top left corner and click on EC2. This will bring you to the EC2 instance dashboard and ready to Launch your instance! Click on &quot;Launch Instance&quot;. There are 7 steps to creating your AWS Instance: Choose an Amazon Machine Image (AMI)Choose Instance TypeConfigure InstanceAdd StorageAdd TagsConfigure Security GroupReview Step 1: Choose an Amazon Machine Image​ Scroll down until you see the Microsoft Windows Server 2019 Base (take the newest one if this is outdated). Make sure that the option you select has the &quot;Free Tier Eligible&quot; under the icon and click on &quot;Select&quot;. Step 2: Choose Instance Type​ Make sure you choose the instance type with the &quot;free tier eligible&quot;, at the time of writing this is the t2.micro instance. Click on &quot;Next: Configure Instance Details&quot;. Do not click on Review and Launch.  Step 3: Configure Instance​ Nothing has to be changed at this step. Keep it default. Click on &quot;Next: Add Storage&quot;. Step 4: Add Storage​ Nothing has to be changed. Keep it default. The 30GB is more than you need but there will be an error if you choose a lower amount. Keep in mind that you can always click &quot;Previous&quot; if you need to return, you do not need to repeat the entire process if you make a mistake (unless you click Launch at the end). Click on &quot;Next: Add Tags&quot; to continue. Step 5: Add Tags​ Nothing has to be changed. Keep it default. Click on &quot;Next: Configure Security Groups&quot; Step 6: Configure Security Groups​ IMPORTANT STEP This makes it possible to connect to your instance from outside for: RDP (needed for this example)For clients connecting through port 7777 for your Mirage Project.SSH (if needed) Create a new security group and you can give it your own name and description. Add the following rules: RDP with source &quot;Anywhere&quot;, Description can be whatever but put it as Remote Desktop Program.Custom UDP Rule with port 7777 and source &quot;Anywhere&quot;, Description can be whatever but put it as Mirage.SSH with source &quot;Anywhere&quot;, Description can be whatever but put it as SSH. SSH is not strictly necessary but can be used to remotely connect to it through other means than the RDP. You can ignore the warning about the source as this is just a testing environment. In the future, you might wish to restrict this but you will almost never know the clients' connection IP's beforehand. Click on &quot;Next: Review and Launch&quot;  Step 7: Review​ Almost there! Make sure everything is correct and you are using the free tier, then click on &quot;Launch&quot;.  One more thing: A window will pop up asking for your key pair. Just create a new one by selecting the dropdown: &quot;Create a new key pair&quot; and give it a name, click on &quot;Download Key Pair&quot;. Keep the key file (.PEM File) somewhere secure (To be 100% certain, back it up somewhere). IMPROTANT NOTICE You cannot access the created instance without this key!  Now you can (finally) click on &quot;Launch Instances&quot;! Go back to your EC2 dashboard by clicking on &quot;Services&quot; at the top left and clicking on EC2. Now you see you have &quot;Running Instances: 1&quot;. Click on &quot;Running Instances&quot; to continue.  info A new instance might take around 5-10 minutes to set up. Refresh the page after 10 minutes if nothing changes. Now you did all this but you want to get ON the dedicated server right? Perfect! The next step will get you up and running! "},{"title":"3. Configuring the server via RDP (Remote Desktop)​","type":1,"pageTitle":"Amazon Web Services (AWS)","url":"docs/guides/development-servers/aws#3-configuring-the-server-via-rdp-remote-desktop","content":"Time to get the RDP file so you can start connecting. There are a few things we'll need: RDP file with the key pair added to itConfigure RDP file once downloaded to allow getting files from our C: drive or other drives (so you can easily get your zip project)Enter the Windows Admin password once you start the RDP file Once you've done this, you should be able to continue using the same RDP file. RDP file with the key pair added to it​ caution Get the password before clicking Download!  Copy the Password for later  Now click on &quot;Download Remote Desktop File&quot;. The RDP file will be downloaded.  Configure RDP file for easy file access​ Go to your freshly downloaded RDP file and right-click it and then click &quot;Edit&quot;. Go to the third tab &quot;Local sources&quot;, at the bottom click &quot;more&quot; under local devices and sources. On the new window select your C: drive or any other drive. This is your own computer your connecting from. For easy file exchange.  Perfect! Now you can run the RDP file! The RDP file will ask for a password. If you forgot your password you can get it back by right-clicking the instance and clicking on &quot;Get Windows Password&quot;. You will be asked to re-enter your key pair (.PEM) file and decrypt the message. Once done you will be able to copy the password.   There you have it! Now you have your password and Remote Desktop should show you logging into your dedicated server! Setting up the firewall to allow connections through​ Go to the windows firewall settings, go to the advanced firewall settings, and go to inbound rules. Add a new rule and choose the port type. Select UDP and enter the 7777 port (or any other if you use another port in Mirage). Continue clicking next and keep things default. Close all the windows when done.  AWESOME! You now have everything set up to accept incoming requests on port 7777. "},{"title":"4. Testing the connection​","type":1,"pageTitle":"Amazon Web Services (AWS)","url":"docs/guides/development-servers/aws#4-testing-the-connection","content":"Before you can (finally) test out the server build of your project you need to get it on the dedicated server! Place your (zipped) server build at the root of your added drive (C: or another) to make it easier to find it fast. Go to &quot;My Computer&quot; and because of our previous changes to the RDP we should now see your local drive under &quot;Devices and Drives&quot;. Double click it and because you placed your zipped server build on that drive, you should see it immediately when it's done loading.  Now unzip the project in a new folder on the dedicated server's desktop and run it. Want to test if it sees the 7777 port is open after you started your Mirage server? Get your IPv4 public IP from the EC2 Management Console from your instance and use it on your client to connect to that IP. Go to PortChecker and enter the Dedicated Server IP address and enter port 7777. note If you are not running your game/project then the port will be closed. It's only open when the server is running. "},{"title":"FAQ","type":0,"sectionRef":"#","url":"docs/guides/faq","content":"","keywords":""},{"title":"How do I use this feature?​","type":1,"pageTitle":"FAQ","url":"docs/guides/faq#how-do-i-use-this-feature","content":"How to send/sync custom data types? Mirage can automatically create serialization functions for many custom data types when your scripts are compiled. For example, Mirage will automatically create a function for MyCustomStruct so that it can be sent without any extra work. [ClientRpc] public void RpcDoSomething(MyCustomStruct data) { // do stuff here } struct MyCustomStruct { int someNumber; Vector3 somePosition; } For More details Data TypesSerialization "},{"title":"How to Connect​","type":1,"pageTitle":"FAQ","url":"docs/guides/faq#how-to-connect","content":"How to connect to games on same PC Make sure the Network Address field on NetworkManager or the Hud is set up localHost How to connect to a different PC/Device on same network Set the Network Address field to the LAN IP of the host 192.168.x.x In some cases, you may need additional steps, check below To check IP on Windows you can open PowerShell and use the ipconfig command, then under your current adapter (ethernet/wifi/etc) look for IPv4 Address IPv4 Address. . . . . . . . . . . : 192.168.x.x How to connect to a different PC/Device over the internet Set the Network Address field to be the IP address of the host (google 'whats my IP') This section does not cover relays/dedicated vps/headless features For this to work, you will need to do some of the following, most of these depend on your set-up and router Port forward: You'll have to log in to your router. Forward your game port (default is 7777) for your PC's local IP. (192.168.1.20 for example) PC Firewalls: You can turn it off for a quick test (And turn it back on later)manually allow the editor and any builds you create in firewalls settings. Try from a build rather than the Unity Editor Some anti-virus/phones may have additional blocking. You can turn it off for a quick test (And turn it back on later) In rare cases ISPs or companies/schools block ports and connections, this is harder to adjust yourself. If you need more help it is best to google for a guide for your setup and router. An alternative to the above is to use a dedicated server (VPS) or use a relay. "},{"title":"Networked Game Objects","type":0,"sectionRef":"#","url":"docs/guides/game-objects/","content":"Networked Game Objects Networked game objects are game objects which are controlled and synchronized by Mirage’s networking system. Using synchronized networked game objects, you can create a shared experience for all the players who are playing an instance of your game. They see and hear the same events and actions - even though that may be from their own unique viewpoints within your game. Multiplayer games in Mirage are typically built using Scenes that contain a mix of networked game objects and regular (non-networked) game objects. The networked game objects are those which move or change during gameplay in a way that needs to be synchronized across all users who are playing the game together. Non-networked game objects are those that either don't move or change at all during gameplay (for example, static obstacles like rocks or fences) or game objects which have movement or changes that don’t need to be synchronized across players (for example, a gently swaying tree or clouds passing by in the background of your game). A networked game object is one that has a Network Identity component attached. However, a Network Identity component alone is not enough for your game object to be functional and active in your multiplayer game. The Network Identity component is the starting point for synchronization, and it allows the Network Manager to synchronize the creation and destruction of the game object, but other than that, it does not specify which properties of your game object should be synchronized. What exactly should be synchronized on each networked game object depends on the type of game you are making, and what each game object’s purpose is. Some examples of what you might want to synchronize are: The position and rotation of moving game objects such as the players and non-player characters.The animation state of an animated game objectThe value of a variable, for example, how much time is left in the current round of a game, or how much energy a player has. As a convenience, the initial position, rotation, and scale of the object are automatically synchronized by the NetworkIdentity. Any other state you wish to synchronize across the network needs to go in a NetworkBehaviour inside your GameObject. When an object is created in the server, you must tell Mirage to create it in the clients and keep track of it. This is known as Spawning.","keywords":""},{"title":"Lifecycle of a GameObject","type":0,"sectionRef":"#","url":"docs/guides/game-objects/lifecycle","content":"","keywords":""},{"title":"Server Instantiate​","type":1,"pageTitle":"Lifecycle of a GameObject","url":"docs/guides/game-objects/lifecycle#server-instantiate","content":"This is usually done by you using Unity's GameObject.InstantiateThis goes through the regular GameObject Lifecycle events such as Awake, Start, Enabled, etc... Basically this is outside Mirage's control. Scene Objects are normally instantiated as part of the scene. "},{"title":"Server Start​","type":1,"pageTitle":"Lifecycle of a GameObject","url":"docs/guides/game-objects/lifecycle#server-start","content":"To start a server object, spawn it. If you wish to perform some logic when the object starts in the server, add a component in your gameObject with our own method and subscribe to NetworkIdentity.OnStartServer For example: public class MyComponent : MonoBehaviour { public void Awake() { GetComponent&lt;NetworkIdentity&gt;.OnStartServer.AddListener(OnStartServer); } public void OnStartServer() { Debug.Log(&quot;The object started on the server&quot;) } }  You can also simply drag your OnStartServer method in the NetworkIdentity.OnStartServer event in the inspector. During the spawn, a message will be sent to all the clients telling them to spawn the object. The message will include all the data in SyncVars, SyncLists, SyncHashSet, SyncDictionary "},{"title":"Client Instantiate​","type":1,"pageTitle":"Lifecycle of a GameObject","url":"docs/guides/game-objects/lifecycle#client-instantiate","content":"When an object is spawned, the server will send a message to the clients telling it to spawn a GameObject and provide an asset id. By default, Mirage will look up all the known prefabs looking for that asset id. Make sure to add your prefabs to the NetworkClient list of prefabs. Then Mirage will instantiate the prefab, and it will go through the regular Unity Lifecycle events. You can customize how objects are instantiated using Spawn Handlers. Do not add Network logic to these events. Instead, use these events to subscribe to network events in NetworkIdentity. Immediately after the object is instantiated, all the data is updated to match the data in the server. "},{"title":"Client Start Authority​","type":1,"pageTitle":"Lifecycle of a GameObject","url":"docs/guides/game-objects/lifecycle#client-start-authority","content":"If the object is owned by this client, then NetworkIdentity will invoke the NetworkIdentity.OnAuthorityChangedSubscribe to this event either by using AddListener, or adding your method to the event in the inspector. Note the Authority can be revoked, and granted again. Every time the client gains authority, this event will be invoked again. "},{"title":"Start Client​","type":1,"pageTitle":"Lifecycle of a GameObject","url":"docs/guides/game-objects/lifecycle#start-client","content":"The event NetworkIdentity.OnStartClient will be invoked. Subscribe to this event by using AddListener or adding your method in the event in the inspector "},{"title":"Start Local Player​","type":1,"pageTitle":"Lifecycle of a GameObject","url":"docs/guides/game-objects/lifecycle#start-local-player","content":"If the object spawned is the character object, the event NetworkIdentity.OnStartLocalPlayeris invoked. Subscribe to this event by using AddListener or adding your method in the event in the inspector "},{"title":"Stop Authority​","type":1,"pageTitle":"Lifecycle of a GameObject","url":"docs/guides/game-objects/lifecycle#stop-authority","content":"If the object loses authority over the object, then NetworkIdentity will invoke the NetworkIdentity.OnAuthorityChangedSubscribe to this event either by using AddListener, or adding your method to the event in the inspector. Note the Authority can be revoked, and granted again. Every time the client loses authority, this event will be invoked again. "},{"title":"Server Stop​","type":1,"pageTitle":"Lifecycle of a GameObject","url":"docs/guides/game-objects/lifecycle#server-stop","content":"Either because the client disconnected, the server stopped, you called ServerObjectManager.Destroy(GameObject, Boolean) the object may stop in the server. During this state, a message is sent to all the clients to unspawn the object. The event NetworkIdentity.OnStopServer will be invoked. Subscribe to this event either by using AddListener, or by adding your method to the event in the inspector. "},{"title":"Server Destroy​","type":1,"pageTitle":"Lifecycle of a GameObject","url":"docs/guides/game-objects/lifecycle#server-destroy","content":"By default, the server will call GameObject.Destroy to destroy the object. Note that if it is a Scene Object the server will invoke GameObject.SetActive(false) instead. The regular unity lifecycle events apply. Note that the server will destroy the object, and will not wait for the clients to unspawn their objects. "},{"title":"Stop Client​","type":1,"pageTitle":"Lifecycle of a GameObject","url":"docs/guides/game-objects/lifecycle#stop-client","content":"This can be triggered either because the client received an Unspawn message or the client was disconnected The event NetworkIdentity.OnStopClient will be invoked. Subscribe to this event either by using AddListener, or by adding your method to the event in the inspector. Use it to clean up any network-related resource used by this object. "},{"title":"Client Destroy​","type":1,"pageTitle":"Lifecycle of a GameObject","url":"docs/guides/game-objects/lifecycle#client-destroy","content":"After an object is stopped on the client, by default unity will call GameObject.Destroy if it is a prefab Spawned ObjectOr it will call GameObject.SetActive(false) if it is a Scene ObjectYou can customize how objects are destroying using Spawn Handlers The normal Unity lifecycle events still apply. "},{"title":"Network Behaviour","type":0,"sectionRef":"#","url":"docs/guides/game-objects/network-behaviour","content":"","keywords":""},{"title":"Synchronized variables​","type":1,"pageTitle":"Network Behaviour","url":"docs/guides/game-objects/network-behaviour#synchronized-variables","content":"Your component can have data that is automatically synchronized from the server to the client. You can use SyncVars as well as SyncLists, SyncHashSet, and SyncDictionary inside a NetworkBehaviour. They will be automatically propagated to the clients whenever their value changes in the server. "},{"title":"Server and Client functions​","type":1,"pageTitle":"Network Behaviour","url":"docs/guides/game-objects/network-behaviour#server-and-client-functions","content":"You can tag member functions in NetworkBehaviour scripts with custom attributes to designate them as server-only or client-only functions. ServerAttributewill check that the function is called in the server. Likewise, ClientAttribute will check if the function is called in the client. For more information, see Attributes. "},{"title":"Server RPC Calls​","type":1,"pageTitle":"Network Behaviour","url":"docs/guides/game-objects/network-behaviour#server-rpc-calls","content":"To execute code on the server, you must use Server RPC calls. The high-level API is a server-authoritative system, so ServerRpc is the only way for a client to trigger some code on the server. Only player game objects can send ServerRpcs. When a client player game object sends a ServerRpc, that ServerRpc runs on the corresponding player game object on the server. This routing happens automatically, so it is impossible for a client to send a ServerRpc for a different player. To define a Server RPC Call in your code, your function must have a ServerRpc attribute. Server RPC Calls are called just by invoking the function normally on the client. Instead of the ServerRpc function running on the client, it is automatically invoked on the corresponding player game object on the server. Server RPC Calls are type-safe, have built-in security and routing to the player, and use an efficient serialization mechanism for the arguments to make calling them fast. See Server RPC and related sections for more information. "},{"title":"Client RPC Calls​","type":1,"pageTitle":"Network Behaviour","url":"docs/guides/game-objects/network-behaviour#client-rpc-calls","content":"Client RPC calls are a way for server game objects to make things happen on client game objects. Client RPC calls are not restricted to player game objects and may be called on any game object with a Network Identity component. To define a Client RPC call in your code, your function must have a ClientRpc attribute. See Client RPC and related sections for more information. "},{"title":"Network Callbacks​","type":1,"pageTitle":"Network Behaviour","url":"docs/guides/game-objects/network-behaviour#network-callbacks","content":"Callbacks can be used to make sure code is executed at the right time. The network callbacks are found inside NetworkIdentity so they can also be used outside of a NetworkBehaviour. See NetworkBehaviour Callbacks and related sections for more information. "},{"title":"Scene Game Objects","type":0,"sectionRef":"#","url":"docs/guides/game-objects/scene-objects","content":"Scene Game Objects There are two types of networked game objects in Mirage’s multiplayer system: Those that are created dynamically at runtimeThose that are saved as part of a Scene Game objects that are created dynamically at runtime use the multiplayer Spawning system, and the prefabs they are instantiated from must be registered in the Network Manager’s list of networked game object prefabs. However, networked game objects that you save as part of a Scene (and therefore already exist in the Scene when it is loaded) are handled differently. These game objects are loaded as part of the Scene on both the client and server and exist at runtime before any spawn messages are sent by the multiplayer system. When the Scene is loaded, all networked game objects in the Scene are disabled on both the client and the server. Then, when the Scene is fully loaded, the Network Manager automatically processes the Scene’s networked game objects, registering them all (and therefore causing them to be synchronized across clients), and enabling them, as if they were spawned at runtime. Networked game objects will not be enabled until a client has requested a character object. Saving networked game objects in your Scene (rather than dynamically spawning them after the scene has loaded) has some benefits: They are loaded with the level, so there will be no pause at runtime.They can have specific modifications that differ from prefabsOther game object instances in the Scene can reference them, which can avoid you having to use code to find the game objects and make references to them up at runtime. When the Network Manager spawns the networked Scene game objects, those game objects behave like dynamically spawned game objects. Mirage sends them updates and ClientRPC calls. If a Scene game object is destroyed on the server before a client joins the game, then it is never enabled on new clients that join. When a client connects, the client is sent an ObjectSpawnScene spawn message for each of the Scene game objects that exist on the server, that are visible to that client. This message causes the game object on the client to be enabled and has the latest state of that game object from the server in it. This means that only game objects that are visible to the client and not destroyed on the server, are activated on the client. Like regular non-Scene game objects, these Scene game objects are started with the latest state when the client joins the game.","keywords":""},{"title":"Spawning Game Objects","type":0,"sectionRef":"#","url":"docs/guides/game-objects/spawn-object","content":"","keywords":""},{"title":"Spawning Without Network Manager​","type":1,"pageTitle":"Spawning Game Objects","url":"docs/guides/game-objects/spawn-object#spawning-without-network-manager","content":"For more advanced users, you may find that you want to register Prefabs and spawn game objects without using the Network Manager component. To spawn game objects without using the Network Manager, you can handle the Prefab registration yourself via script. Use the ClientScene.RegisterPrefab method to register Prefabs to the Network Manager. using UnityEngine; using Mirage; public class MyNetworkManager : MonoBehaviour { public GameObject treePrefab; public ClientObjectManager; public NetworkClient; public NetworkServer; public ServerObjectManager; void Start() { ClientObjectManager = FindObjectOfType&lt;ClientObjectManager&gt;(); NetworkClient = FindObjectOfType&lt;NetworkClient&gt;(); NetworkServer = FindObjectOfType&lt;NetworkServer&gt;(); ServerObjectManager = FindObjectOfType&lt;NetworkServer&gt;(); } // Register prefab and connect to the server public void ClientConnect() { ClientObjectManager.spawnPrefabs.Add(treePrefab); NetworkClient.Connect(&quot;localhost&quot;); NetworkClient.MessageHandler.RegisterHandler&lt;ConnectMessage&gt;(OnClientConnect); } void OnClientConnect(NetworkConnection conn, ConnectMessage msg) { Debug.Log(&quot;Connected to server: &quot; + conn); } }  In this example, you create an empty game object to act as the Network Manager, then create and attach the MyNetworkManager script (above) to that game object. Create a prefab that has a Network Identity component attached to it, and drag that onto the treePrefab slot on the MyNetworkManager component in the Inspector. This ensures that when the server spawns the tree game object, it also creates the same kind of game object on the clients. Registering prefabs ensures that there is no stalling or loading time for creating the Asset. For the script to work, you also need to add code for the server. Add this to the MyNetworkManager script: public void ServerListen() { // start listening, and allow up to 4 connections NetworkServer.StartServer(); NetworkServer.MessageHandler.RegisterHandler&lt;ConnectMessage&gt;(OnServerConnect); NetworkServer.MessageHandler.RegisterHandler&lt;ReadyMessage&gt;(OnClientReady); } // When client is ready spawn a few trees void OnClientReady(NetworkConnection conn, ReadyMessage msg) { Debug.Log(&quot;Client is ready to start: &quot; + conn); SpawnTrees(); } void SpawnTrees() { int x = 0; for (int i = 0; i &lt; 5; ++i) { GameObject treeGo = Instantiate(treePrefab, new Vector3(x++, 0, 0), Quaternion.identity); ServerObjectManager.Spawn(treeGo); } } void OnServerConnect(NetworkConnection conn, ConnectMessage msg) { Debug.Log(&quot;New client connected: &quot; + conn); }  The server does not need to register anything, as it knows what game object is being spawned (and the asset ID is sent in the spawn message). The client needs to be able to look up the game object, so it must be registered on the client. When writing your own network manager, it’s important to make the client ready to receive state updates before calling the spawn command on the server, otherwise, they won’t be sent. If you’re using Mirage’s built-in Network Manager component, this happens automatically. For more advanced uses, such as object pools or dynamically created Assets, you can use the ClientObjectManager.RegisterSpawnHandler method, which allows callback functions to be registered for client-side spawning. See the documentation on Custom Spawn Functions for an example of this. If the game object has a network state like synchronized variables, then that state is synchronized with the spawn message. In the following example, this script is attached to the tree Prefab: using UnityEngine; using Mirage; public class Tree : NetworkBehaviour { [SyncVar] public int numLeaves; void Start() { Identity.OnStartClient.AddLisenter(OnStartClient); } public override void OnStartClient() { Debug.Log(&quot;Tree spawned with leaf count &quot; + numLeaves); } }  With this script attached, you can change the numLeaves variable and modify the SpawnTrees function to see it accurately reflected on the client: void SpawnTrees() { int x = 0; for (int i = 0; i &lt; 5; ++i) { GameObject treeGo = Instantiate(treePrefab, new Vector3(x++, 0, 0), Quaternion.identity); Tree tree = treeGo.GetComponent&lt;Tree&gt;(); tree.numLeaves = Random.Range(10,200); Debug.Log(&quot;Spawning leaf with leaf count &quot; + tree.numLeaves); ServerObjectManager.Spawn(treeGo); } }  Attach the Tree script to the treePrefab script created earlier to see this in action. "},{"title":"Constraints​","type":1,"pageTitle":"Spawning Game Objects","url":"docs/guides/game-objects/spawn-object#constraints","content":"A NetworkIdentity must be on the root game object of a spawnable Prefab. Without this, the Network Manager can’t register the Prefab. "},{"title":"Game Object Creation Flow​","type":1,"pageTitle":"Spawning Game Objects","url":"docs/guides/game-objects/spawn-object#game-object-creation-flow","content":"The actual flow of internal operations that takes place for spawning game objects is: Prefab with Network Identity component is registered as spawnable.A game object is instantiated from the Prefab on the server.The game code sets initial values on the instance (note that 3D physics forces applied here do not take effect immediately).ServerObjectManager.Spawn is called with the instance.The state of the SyncVars on the instance on the server is collected by calling OnSerialize on [Network Behaviour] components.A network message of the type ObjectSpawn is sent to connected clients that include the SyncVar data.OnStartServer is called on the instance on the server, and IsServer is set to trueClients receive the ObjectSpawn message and create a new instance from the registered Prefab.The SyncVar data is applied to the new instance on the client by calling OnDeserialize on Network Behaviour components.OnStartClient is called on the instance on each client, and IsClient is set to trueAs game-play progresses, changes to SyncVar values are automatically synchronized to clients. This continues until the game ends.ServerObjectManager.Destroy is called on the instance on the server.A network message of the type ObjectDestroy is sent to clients.OnNetworkDestroy is called on the instance on clients, then the instance is destroyed. "},{"title":"Player Game Objects​","type":1,"pageTitle":"Spawning Game Objects","url":"docs/guides/game-objects/spawn-object#player-game-objects","content":"Player game objects in the HLAPI work slightly differently from non-player game objects. The flow for spawning player game objects with the Network Manager is: Prefab with NetworkIdentity is registered as the PlayerPrefabThe client connects to the serverClient calls AddPlayer, network message of type MsgType.AddPlayer is sent to the serverThe server receives the message and calls CharacterSpawner.OnServerAddPlayerA game object is instantiated from the Player Prefab on the serverServerObjectManager.AddCharacter is called with the new player instance on the serverThe player instance is spawned - you do not have to call ServerObjectManager.Spawn for the player instance. The spawn message is sent to all clients like on a normal spawn.A network message of type Owner is sent to the client that added the player (only that client!)The original client receives the network messageOnStartLocalPlayer is called on the player instance on the original client, and IsLocalPlayer is set to true note OnStartLocalPlayer is called after OnStartClient, because it only happens when the ownership message arrives from the server after the player game object is spawned, so IsLocalPlayer is not set in OnStartClient. Because OnStartLocalPlayer is only called for the client’s local player game object, it is a good place to perform initialization that should only be done for the local player. This could include enabling input processing and enabling camera tracking for the player game object. "},{"title":"Spawning Game Objects with Client Authority​","type":1,"pageTitle":"Spawning Game Objects","url":"docs/guides/game-objects/spawn-object#spawning-game-objects-with-client-authority","content":"To spawn game objects and assign authority of those game objects to a particular client, use ServerObjectManager.Spawn, which takes as an argument the INetworkPlayer of the client that is to be made the authority. For these game objects, the property HasAuthority is true on the client with authority, and OnStartAuthority is called on the client with authority. That client can issue Server RPCs for that game object. On other clients (and on the host), HasAuthority is false. For example, the tree spawn example above can be modified to allow the tree to have client authority like this (note that we now need to pass in a Network Player game object for the owning client’s connection): void SpawnTrees(INetworkPlayer player) { int x = 0; for (int i = 0; i &lt; 5; ++i) { GameObject treeGo = Instantiate(treePrefab, new Vector3(x++, 0, 0), Quaternion.identity); Tree tree = treeGo.GetComponent&lt;Tree&gt;(); tree.numLeaves = Random.Range(10,200); Debug.Log(&quot;Spawning leaf with leaf count &quot; + tree.numLeaves); ServerObjectManager.Spawn(treeGo, player); } }  The Tree script can now be modified to send a Server RPC Call to the server:  public void ClientConnect() { ClientObjectManager.spawnPrefabs.Add(treePrefab); NetworkClient.Connect(&quot;localhost&quot;); NetworkClient.MessageHandler.RegisterHandler&lt;ConnectMessage&gt;(OnClientConnect); NetworkClient.Player.Identity.OnAuthorityChanged.AddListener(OnStartAuthority); } public override void OnStartAuthority(bool changed) { CmdMessageFromTree(&quot;Tree with &quot; + numLeaves + &quot; reporting in&quot;); } [ServerRpc] void CmdMessageFromTree(string msg) { Debug.Log(&quot;Client sent a tree message: &quot; + msg); }  Note that you can’t just add the CmdMessageFromTree call into OnStartClient, because at that point the authority has not been set yet, so the call would fail. "},{"title":"Pickups, Drops, and Child Objects","type":0,"sectionRef":"#","url":"docs/guides/game-objects/pickup-drop-child","content":"","keywords":""},{"title":"Child Objects​","type":1,"pageTitle":"Pickups, Drops, and Child Objects","url":"docs/guides/game-objects/pickup-drop-child#child-objects","content":"Let's start with the simple case of a single attachment point that is somewhere down the hierarchy of our Player, such as a hand at the end of an arm. In a script that inherits from NetworkBehaviour on the Player Prefab, we'd have a GameObject reference where the attachment point can be assigned in the inspector, a SyncVar enum with various choices of what the player is holding, and a Hook for the SyncVar to swap out the art of the held item based on the new value. In the image below, Kyle has an empty game object, RightHand, added to the wrist, and some prefabs to be equipped (Ball, Box, Cylinder), and a Player Equip script to handle them. The inspector shows RightHand assigned in 2 places, the Player Equip script, as well as the target of the Network Transform Child component, so we could adjust the relative position of the attachment point (not the art) for all clients as needed.  Below is the Player Equip script to handle the changing of the equipped item, and some notes for consideration: While we could just have all the art items attached at design time and just enable/disable them based on the enum, this doesn't scale well to a lot of items and if they have scripts on them for how they behave in the game, such as animations, special effects, etc. it could get ugly pretty fast, so this example locally instantiates and destroys instead as a design choice.The example makes no effort to deal with position offset between the item and the attach point, e.g. having the grip or handle of an item aligns with the hand. This is best dealt with in a MonoBehaviour script on the item that has public fields for the local position and rotation that can be set in the designer and a bit of code in Start to apply those values in local coordinates relative to the parent attach point. using UnityEngine; using System.Collections; using Mirage; public enum EquippedItem : byte { nothing, ball, box, cylinder } public class PlayerEquip : NetworkBehaviour { public GameObject sceneObjectPrefab; public GameObject rightHand; public GameObject ballPrefab; public GameObject boxPrefab; public GameObject cylinderPrefab; [SyncVar(hook = nameof(OnChangeEquipment))] public EquippedItem equippedItem; void OnChangeEquipment(EquippedItem oldEquippedItem, EquippedItem newEquippedItem) { StartCoroutine(ChangeEquipment(newEquippedItem)); } // Since Destroy is delayed to the end of the current frame, we use a coroutine // to clear out any child objects before instantiating the new one IEnumerator ChangeEquipment(EquippedItem newEquippedItem) { while (rightHand.transform.childCount &gt; 0) { Destroy(rightHand.transform.GetChild(0).gameObject); yield return null; } switch (newEquippedItem) { case EquippedItem.ball: Instantiate(ballPrefab, rightHand.transform); break; case EquippedItem.box: Instantiate(boxPrefab, rightHand.transform); break; case EquippedItem.cylinder: Instantiate(cylinderPrefab, rightHand.transform); break; } } void Update() { if (!IsLocalPlayer) return; if (Input.GetKeyDown(KeyCode.Alpha0) &amp;&amp; equippedItem != EquippedItem.nothing) CmdChangeEquippedItem(EquippedItem.nothing); if (Input.GetKeyDown(KeyCode.Alpha1) &amp;&amp; equippedItem != EquippedItem.ball) CmdChangeEquippedItem(EquippedItem.ball); if (Input.GetKeyDown(KeyCode.Alpha2) &amp;&amp; equippedItem != EquippedItem.box) CmdChangeEquippedItem(EquippedItem.box); if (Input.GetKeyDown(KeyCode.Alpha3) &amp;&amp; equippedItem != EquippedItem.cylinder) CmdChangeEquippedItem(EquippedItem.cylinder); } [ServerRpc] void CmdChangeEquippedItem(EquippedItem selectedItem) { equippedItem = selectedItem; } }  "},{"title":"Dropping Items​","type":1,"pageTitle":"Pickups, Drops, and Child Objects","url":"docs/guides/game-objects/pickup-drop-child#dropping-items","content":"Now that we can equip the items, we need a way to drop the current item into the world as a networked item. Remember that, as child art, the item prefabs have no networking components on them at all. First, let's add one more Input to the Update method above and a CmdDropItem method: void Update() { if (!IsLocalPlayer) return; if (Input.GetKeyDown(KeyCode.Alpha0) &amp;&amp; equippedItem != EquippedItem.nothing) CmdChangeEquippedItem(EquippedItem.nothing); if (Input.GetKeyDown(KeyCode.Alpha1) &amp;&amp; equippedItem != EquippedItem.ball) CmdChangeEquippedItem(EquippedItem.ball); if (Input.GetKeyDown(KeyCode.Alpha2) &amp;&amp; equippedItem != EquippedItem.box) CmdChangeEquippedItem(EquippedItem.box); if (Input.GetKeyDown(KeyCode.Alpha3) &amp;&amp; equippedItem != EquippedItem.cylinder) CmdChangeEquippedItem(EquippedItem.cylinder); if (Input.GetKeyDown(KeyCode.X) &amp;&amp; equippedItem != EquippedItem.nothing) CmdDropItem(); }  [ServerRpc] void CmdDropItem() { // Instantiate the scene object on the server Vector3 pos = rightHand.transform.position; Quaternion rot = rightHand.transform.rotation; GameObject newSceneObject = Instantiate(sceneObjectPrefab, pos, rot); // set the RigidBody as non-kinematic on the server only (isKinematic = true in prefab) newSceneObject.GetComponent&lt;Rigidbody&gt;().isKinematic = false; SceneObject sceneObject = newSceneObject.GetComponent&lt;SceneObject&gt;(); // set the child object on the server sceneObject.SetEquippedItem(equippedItem); // set the SyncVar on the scene object for clients sceneObject.equippedItem = equippedItem; // set the player's SyncVar to nothing so clients will destroy the equipped child item equippedItem = EquippedItem.nothing; // Spawn the scene object on the network for all to see ServerObjectManager.Spawn(newSceneObject); }  In the image above, there's a sceneObjectPrefab field that is assigned to a prefab that will act as a container for our item prefabs. The SceneObject prefab has a SceneObject script with a SyncVar like the Player Equip script, and a SetEquippedItem method that takes the shared enum value as a parameter. using UnityEngine; using System.Collections; using Mirage; public class SceneObject : NetworkBehaviour { [SyncVar(hook = nameof(OnChangeEquipment))] public EquippedItem equippedItem; public GameObject ballPrefab; public GameObject boxPrefab; public GameObject cylinderPrefab; void OnChangeEquipment(EquippedItem oldEquippedItem, EquippedItem newEquippedItem) { StartCoroutine(ChangeEquipment(newEquippedItem)); } // Since Destroy is delayed to the end of the current frame, we use a coroutine // to clear out any child objects before instantiating the new one IEnumerator ChangeEquipment(EquippedItem newEquippedItem) { while (transform.childCount &gt; 0) { Destroy(transform.GetChild(0).gameObject); yield return null; } // Use the new value, not the SyncVar property value SetEquippedItem(newEquippedItem); } // SetEquippedItem is called on the client from OnChangeEquipment (above), // and on the server from CmdDropItem in the PlayerEquip script. public void SetEquippedItem(EquippedItem newEquippedItem) { switch (newEquippedItem) { case EquippedItem.ball: Instantiate(ballPrefab, transform); break; case EquippedItem.box: Instantiate(boxPrefab, transform); break; case EquippedItem.cylinder: Instantiate(cylinderPrefab, transform); break; } } }  In the run-time image below, the Ball(Clone) is attached to the RightHand object, and the Box(Clone) is attached to the SceneObject(Clone), which is shown in the inspector. The art prefabs have simple colliders on them (sphere, box, capsule). If your art item has a mesh collider, it must be marked as Convex to work with the RigidBody on the SceneObject container.  "},{"title":"Pickup Items​","type":1,"pageTitle":"Pickups, Drops, and Child Objects","url":"docs/guides/game-objects/pickup-drop-child#pickup-items","content":"Now that we have a box dropped in the scene, we need to pick it up again. To do that, a CmdPickupItem method is added to the Player Equip script: // CmdPickupItem is public because it's called from a script on the SceneObject [ServerRpc] public void CmdPickupItem(GameObject sceneObject) { // set the player's SyncVar so clients can show the equipped item equippedItem = sceneObject.GetComponent&lt;SceneObject&gt;().equippedItem; // Destroy the scene object ServerObjectManager.Destroy(sceneObject); }  This method is simply called from OnMouseDown in the Scene Object script: private void OnMouseDown() { Client.Player.Identity.GetComponent&lt;PlayerEquip&gt;().CmdPickupItem(gameObject); }  Since the SceneObject(Clone) is networked, we can pass it directly through to CmdPickupItem on the character object to set the equipped item SyncVar and destroy the scene object. For this entire example, the only prefab that needs to be registered with Network Manager besides the Player is the SceneObject prefab.  "},{"title":"Custom Spawn Functions","type":0,"sectionRef":"#","url":"docs/guides/game-objects/spawn-object-custom","content":"","keywords":""},{"title":"Setting Up a Game Object Pool with Custom Spawn Handlers​","type":1,"pageTitle":"Custom Spawn Functions","url":"docs/guides/game-objects/spawn-object-custom#setting-up-a-game-object-pool-with-custom-spawn-handlers","content":"you can use custom spawn handlers in order set up object pooling so you dont need to instantiate and destroy objects each time you use them. A full guide on pooling can be found here: Spawn Object Pooling void ClientConnected() { clientObjectManager.RegisterPrefab(prefab, PoolSpawnHandler, PoolUnspawnHandler); } // used by clientObjectManager.RegisterPrefab NetworkIdentity PoolSpawnHandler(SpawnMessage msg) { return GetFromPool(msg.position, msg.rotation); } // used by clientObjectManager.RegisterPrefab void PoolUnspawnHandler(NetworkIdentity spawned) { PutBackInPool(spawned); }  "},{"title":"Dynamic spawning​","type":1,"pageTitle":"Custom Spawn Functions","url":"docs/guides/game-objects/spawn-object-custom#dynamic-spawning","content":"Some times you may want to create objects at runtime and you might not know the prefab hash ahead of time. For this you can use Dynamic Spawn Handlers to return a spawn handler for a prefab hash. Below is an example where client pre-spawns objects while loading, and then network spawns them when receiving a SpawnMessage from server. Dynamic Handler avoid the need to add 1 spawn handler for each prefab hash. Instead you can just add a single dynamic handler that can then be used to find and return objects. // store handler in field so that you dont need to allocate a new one for each DynamicSpawn call SpawnHandler _handler; List&lt;NetworkIdentity&gt; _preSpawnedObjects = new List&lt;NetworkIdentity&gt;(); void Start() { _handler = new SpawnHandler(FindPreSpawnedObject, null); // fill _preSpawnedObjects here with objects _preSpawnedObjects.Add(new GameObject(&quot;name&quot;).AddComponent&lt;NetworkIdentity&gt;()); } public SpawnHandler DynamicSpawn(int prefabHash) { if (IsPreSpawnedId(prefabHash)) // return a handler that is using FindPreSpawnedObject return _handler; else return null; } bool IsPreSpawnedId(int prefabHash) { // prefabHash starts with 16 bits of 0, then it an id we are using for spawning // this chance of this happening randomly is very low // you can do more validation on the hash based on use case return (prefabHash &amp; 0xFFFF) == 0; } // finds object based on hash and returns it public NetworkIdentity FindPreSpawnedObject(SpawnMessage spawnMessage) { var prefabHash = spawnMessage.prefabHash.Value; // we stored index in last 16 bits on hash var index = prefabHash &gt;&gt; 16; var identity = _preSpawnedObjects[index]; return identity; }  "},{"title":"Player Game Objects","type":0,"sectionRef":"#","url":"docs/guides/game-objects/spawn-player","content":"Player Game Objects Mirage’s multiplayer HLAPI system handles player game objects differently than non-player game objects. When a new player joins the game (when a new client connects to the server), that player’s game object becomes a &quot;local player&quot; game object on the client of that player, and Unity associates the player’s connection with the player’s game object. Unity associates one player game object for each person playing the game, and routes networking Server RPC Calls to that individual game object. A player cannot invoke a Server RPC Call on another player’s game object, only their own. The NetworkBehaviour class (which you derive from to create your network scripts) has a property called IsLocalPlayer. On each client’s player game object, Mirage sets that property to true on the NetworkBehaviour script and invokes the OnStartLocalPlayer callback on the object's NetworkIdentity. This means each client has a different game object set up like this because on each client a different game object is the one that represents the local player. The diagram below shows two clients and their local players. Only the player game object that is &quot;yours&quot; (from your point of view as the player) has the IsLocalPlayer flag set. Usually, you should set this flag in the script to determine whether to process input, whether to make the camera track the game object or do any other client-side things that should only occur for the player belonging to that client. Player game objects represent the player (that is, the person playing the game) on the server, and run Server RPC Calls from the player’s client. These Server RPC Calls are secure client-to-server remote procedure calls. In this server-authoritative system, other non-player server-side game objects cannot receive Server RPC Calls directly from client-side game objects. This is both for security, and to reduce the complexity of building your game. By routing all incoming Server RPC Calls from users through the player game object, you can ensure that these messages come from the right place, the right client, and can be handled in a central location. The CharacterSpawner component adds a player every time a client connects to the server. In some situations though, you might want it not to add players until an input event happens - such as a user pressing a “start” button on the controller. To disable automatic player creation, you may want to write your own CharacterSpawner component and wait for the AddPlayerMessage message to be sent from the client.","keywords":""},{"title":"Custom Character Spawning","type":0,"sectionRef":"#","url":"docs/guides/game-objects/spawn-player-custom","content":"","keywords":""},{"title":"Ready State​","type":1,"pageTitle":"Custom Character Spawning","url":"docs/guides/game-objects/spawn-player-custom#ready-state","content":"Out of date! This is out of date and needs to be updated! In addition to characters, players also have a &quot;scene is ready&quot; state. The server sends clients that are ready information about spawned game objects and state synchronization updates; clients which are not ready are not sent these updates. When a client initially connects to a server, their SceneIsReady property will be true. However initial spawning will not happen until a character has been added or you manually tell the server to send spawned objects. Once a client has completed all its pre-game setup, and all its Assets are loaded, it can send a character message. As seen in the example above this will tell the server to spawn the player's character using ServerObjectManager.AddCharacter. After the character is spawned mirage will automatically send a spawn message for the other spawned object to the client. "},{"title":"Switching Characters​","type":1,"pageTitle":"Custom Character Spawning","url":"docs/guides/game-objects/spawn-player-custom#switching-characters","content":"To replace the character game object for a player, use ServerObjectManager.ReplaceCharacter. This is useful for having different game objects for the player at different times, such as in-game and a pregame lobby. The function takes the same arguments as AddCharacter, but allows there to already be a character for that player. The old character game object is not destroyed when ReplaceCharacter is called. The NetworkRoomManager uses this technique to switch from the NetworkRoomPlayer game object to a game-play player game object when all the players in the room are ready. You can also use ReplaceCharacter to respawn a player or change the object that represents the player. In some cases, it is better to just disable a game object and reset its game attributes on respawn. The following code sample demonstrates how to replace the player game object with a new game object: public class CustomCharacterSpawner : MonoBehaviour { public NetworkServer Server; public ServerObjectManager ServerObjectManager; public void Respawn(NetworkPlayer player, GameObject newPrefab) { // Cache a reference to the current character object GameObject oldPlayer = player.Identity.gameObject; var newCharacter = Instantiate(newPrefab); // Instantiate the new character object and broadcast to clients // NOTE: here we can use `keepAuthority: true` because we are calling Destroy on the old prefab immediately after. ServerObjectManager.ReplaceCharacter(player, newCharacter, keepAuthority: true); // Remove the previous character object that's now been replaced Server.Destroy(oldPlayer); } }  "},{"title":"Destroying Characters​","type":1,"pageTitle":"Custom Character Spawning","url":"docs/guides/game-objects/spawn-player-custom#destroying-characters","content":"Once the character is finished (eg game over, or player died) you can remove the character using ServerObjectManager.DestroyCharacter. public void OnPlayerDeath(INetworkPlayer player) { ServerObjectManager.DestroyCharacter(player); }  Alternatively, you can use ServerObjectManager.RemoveCharacter to remove it as the player's character without destroying it. "},{"title":"Spawn Object - Pooling","type":0,"sectionRef":"#","url":"docs/guides/game-objects/spawn-object-pooling","content":"","keywords":""},{"title":"Setting Up a Game Object Pool with Custom Spawn Handlers​","type":1,"pageTitle":"Spawn Object - Pooling","url":"docs/guides/game-objects/spawn-object-pooling#setting-up-a-game-object-pool-with-custom-spawn-handlers","content":"Here is an example of how you might set up a simple game object pooling system with custom spawn handlers. Spawning and unspawning then puts game objects in or out of the pool. using System.Collections.Generic; using Mirage; using UnityEngine; namespace Mirage.Examples { public class PrefabPoolManager : MonoBehaviour { [Header(&quot;Settings&quot;)] public ClientObjectManager clientObjectManager; public int startSize = 5; public int maxSize = 20; public NetworkIdentity prefab; [Header(&quot;Debug&quot;)] [SerializeField] int currentCount; Queue&lt;NetworkIdentity&gt; pool; void Start() { InitializePool(); clientObjectManager.RegisterPrefab(prefab, SpawnHandler, UnspawnHandler); } // used by clientObjectManager.RegisterPrefab NetworkIdentity SpawnHandler(SpawnMessage msg) { return GetFromPool(msg.position, msg.rotation); } // used by clientObjectManager.RegisterPrefab void UnspawnHandler(NetworkIdentity spawned) { PutBackInPool(spawned); } void OnDestroy() { clientObjectManager.UnregisterPrefab(prefab); } private void InitializePool() { pool = new Queue&lt;NetworkIdentity&gt;(); for (int i = 0; i &lt; startSize; i++) { NetworkIdentity next = CreateNew(); pool.Enqueue(next); } } NetworkIdentity CreateNew() { if (currentCount &gt; maxSize) { Debug.LogError($&quot;Pool has reached max size of {maxSize}&quot;); return null; } // use this object as parent so that objects dont crowd hierarchy NetworkIdentity next = Instantiate(prefab, transform); next.name = $&quot;{prefab.name}_pooled_{currentCount}&quot;; next.gameObject.SetActive(false); currentCount++; return next; } /// &lt;summary&gt; /// Used to take Object from Pool. /// &lt;para&gt;Should be used on server to get the next Object&lt;/para&gt; /// &lt;/summary&gt; /// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;rotation&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public NetworkIdentity GetFromPool(Vector3 position, Quaternion rotation) { NetworkIdentity next = pool.Count &gt; 0 ? pool.Dequeue() // take from pool : CreateNew(); // create new because pool is empty // CreateNew might return null if max size is reached if (next == null) { return null; } // set position/rotation and set active next.transform.position = position; next.transform.rotation = rotation; next.gameObject.SetActive(true); return next; } /// &lt;summary&gt; /// Used to put object back into pool so they can b /// &lt;para&gt;Should be used on server after unspawning an object&lt;/para&gt; /// &lt;/summary&gt; /// &lt;param name=&quot;spawned&quot;&gt;&lt;/param&gt; public void PutBackInPool(NetworkIdentity spawned) { // disable object spawned.gameObject.SetActive(false); // add back to pool pool.Enqueue(spawned); } } }  To use this manager, create a new empty game object and add the PrefabPoolManager component (code above). Next, drag a prefab you want to spawn multiple times to the Prefab field, and set startSize and maxSize fields. startSize is how many will be spawned when your game starts. maxSize is the max number that can be spawned, if this number is reached then an error will be given when trying to more new objects. Finally, set up a reference to the PrefabPoolManager in the script you are using for player movement: PrefabPoolManager prefabPoolManager; void Start() { prefabPoolManager = FindObjectOfType&lt;PrefabPoolManager&gt;(); }  Your player logic might contain something like this, which moves and fires coins: void Update() { if (!isLocalPlayer) return; // move var x = Input.GetAxis(&quot;Horizontal&quot;) * 0.1f; var z = Input.GetAxis(&quot;Vertical&quot;) * 0.1f; transform.Translate(x, 0, z); // shoot if (Input.GetKeyDown(KeyCode.Space)) { // Server RPC Call function is called on the client, but invoked on the server CmdFire(); } }  In the firing logic on the player, make it use the game object pool: [ServerRpc] void CmdFire() { // Set up bullet on server NetworkIdentity bullet = prefabPoolManager.GetFromPool(transform.position + transform.forward, Quaternion.identity); Rigidbody rigidBody = bullet.GetComponent&lt;Rigidbody&gt;(); rigidBody.velocity = transform.forward * 4; // tell server to send SpawnMessage, which will call SpawnHandler on client ServerObjectManager.Spawn(bullet); // destroy bullet after 2 seconds StartCoroutine(DestroyDelay(bullet, 2.0f)); } IEnumerator DestroyDelay(NetworkIdentity go, float delay) { yield return new WaitForSeconds(delay); // return object to pool on server prefabPoolManager.PutBackInPool(go); // tell server to send ObjectDestroyMessage, which will call UnspawnHandler on client ServerObjectManager.Destroy(go, destroyServerObject: false); }  The Destroy method above shows how to return game objects to the pool so that they can be re-used when you fire again "},{"title":"Generics","type":0,"sectionRef":"#","url":"docs/guides/generics","content":"","keywords":""},{"title":"NetworkBehaviour​","type":1,"pageTitle":"Generics","url":"docs/guides/generics#networkbehaviour","content":"By making a NetworkBehaviour generic you can then use generic SyncVar fields or use the generic in an RPC. public class MyGenericBehaviour&lt;T&gt; : NetworkBehaviour { [SyncVar] public T Value; public void MyRpc(T value) { // do stuff } }  danger Making the RPC itself generic does not work. For example, MyRpc&lt;T&gt;(T value) will not work. This is because the receiver will have no idea what generic to invoke the type as. "},{"title":"Ensure Type has Write and Read functions​","type":1,"pageTitle":"Generics","url":"docs/guides/generics#ensure-type-has-write-and-read-functions","content":"For a type to work as a generic, it must have a write and read that Mirage can find. For built-in types, this is done automatically (see Serialization). For custom types Mirage will try to automatically find them and generate functions, however, this does not always work. Adding [NetworkMessage] to the type will tell Mirage to generate functions for it. [NetworkMessage] public struct MyCustomType { public int Value; }  Alternatively, you can manually create Write and Read functions for your type public static class MyCustomTypeExtensions { public static void Write(this NetworkWriter writer, MyCustomType value) { // write here } public static MyCustomType Read(this NetworkReader reader) { // read here } }  "},{"title":"Network Messages and other types​","type":1,"pageTitle":"Generics","url":"docs/guides/generics#network-messages-and-other-types","content":"Generic messages are partly supported. Generic instances can be used as messages, For example, using MyMessage&lt;int&gt; in the example below. This also includes using generic types in RPC or inside other types as long they are generic instances. public struct MyMessage&lt;T&gt; { public T Value; } class Manager { void Start() { Server.MessageHandler.RegisterHandler&lt;MyMessage&lt;int&gt;&gt;(HandleMessage); } void HandleIntMessage(INetworkPlayer player, MyMessage&lt;int&gt; msg) { // do stuff } }  note Generic message should not have [NetworkMessage] because this cause Mirage to try to make a writer for the generic itself. Only generic instances (eg MyMessage&lt;int&gt;) can have serialize functions "},{"title":"SyncList, SyncDictionary, SyncSet​","type":1,"pageTitle":"Generics","url":"docs/guides/generics#synclist-syncdictionary-syncset","content":"SyncList, SyncDictionary, and SyncSet can have generic types as their element type as long as it is a generic instance (eg MyType&lt;int&gt; not MyType&lt;T&gt;). public struct MyType&lt;T&gt; { public bool Option; public T Value; } public class MyBehaviour : NetworkBehaviour { public SyncList&lt;MyType&lt;float&gt;&gt; myList; }  "},{"title":"Network Visibility","type":0,"sectionRef":"#","url":"docs/guides/network-visibility","content":"","keywords":""},{"title":"Network Proximity Checker Component​","type":1,"pageTitle":"Network Visibility","url":"docs/guides/network-visibility#network-proximity-checker-component","content":"Mirage’s Network Proximity Checker component is the simplest way to implement network visibility for players. It works in conjunction with the physics system to determine whether game objects are close enough (that is, &quot;visible&quot; to send network messages in your multiplayer game). "},{"title":"Network Scene Checker Component​","type":1,"pageTitle":"Network Visibility","url":"docs/guides/network-visibility#network-scene-checker-component","content":"Mirage's Network Scene Checker component can be used to isolate players and networked objects on the server in additive scene instances. "},{"title":"Network Visibility on Remote Clients​","type":1,"pageTitle":"Network Visibility","url":"docs/guides/network-visibility#network-visibility-on-remote-clients","content":"When a player on a remote client joins a networked game, only game objects that are network-visible to the player will be spawned on that remote client. This means that even if the player enters a large world with many networked game objects, the game can start quickly because it does not need to spawn every game object that exists in the world. Note that this applies to networked game objects in your scene, but does not affect the loading of Assets. Unity still takes time to load the Assets for registered Prefabs and Scene game objects. When a player moves within the world, the set of network-visible game objects changes. The player’s client is told about these changes as they happen. The ObjectHide message is sent to clients when a game object becomes no longer network-visible. By default, Mirage destroys the game object when it receives this message. When a game object becomes visible, the client receives an ObjectSpawn message, as if Mirage has spawned the game object for the first time. By default, the game object is instantiated like any other spawned game object. "},{"title":"Network Visibility on the Host​","type":1,"pageTitle":"Network Visibility","url":"docs/guides/network-visibility#network-visibility-on-the-host","content":"The host shares the same Scene as the server because it acts as both the server and the client to the player hosting the game. For this reason, it cannot destroy game objects that are not visible to the local player. Instead, there is the virtual method OnSetLocalVisibility in the NetworkVisibility class that is invoked. This method is invoked on all scripts that inherit from NetworkVisibility on game objects that change the visibility state on the host. The default implementation of OnSetLocalVisibility disables or enables all renderer components on the game object. If you want to customize this implementation, you can override the method in your script, and provide new behavior for how the host (and therefore the local client) should respond when a game object becomes network-visible or invisible (such as disabling HUD elements or renderers). "},{"title":"Customizing Network Visibility​","type":1,"pageTitle":"Network Visibility","url":"docs/guides/network-visibility#customizing-network-visibility","content":"Sometimes you might want to use other kinds of visibility checks, such as grid-based rules, line-of-sight tests, navigation path tests, or any other type of test that suits your game. It may be helpful to understand how the Network Proximity Checker works. The Network Proximity Checker is implemented using the public visibility interface of Mirage’s HLAPI. Using this same interface, you can implement any kind of visibility rules you desire. Each NetworkIdentity keeps track of the set of players that it is visible to. The players that a NetworkIdentity game object is visible to are called the “observers” of the NetworkIdentity. The Network Proximity Checker calls the RebuildObservers method on the Network Identity component at a fixed interval (set using the “Vis Update Interval” value in the inspector), so that the set of network-visible game objects for each player is updated as they move around. In the NetworkVisibility class (which your custom observer scripts inherit from), there are some virtual functions for determining visibility. These are: OnCheckObserver This method is called on the server, on each networked game object when a new player enters the game. If it returns true, that player is added to the object’s observers. The Network Proximity Checker does a simple distance check in its implementation of this function and uses Physics.OverlapSphereNonAlloc to find the players that are within the visibility distance for this object.OnRebuildObservers This method is called on the server when RebuildObservers is invoked. This method expects the set of observers to be populated with the players that can see the object. The NetworkServer then handles sending ObjectHide and ObjectSpawn messages based on the differences between the old and new visibility sets.OnSetHostVisibility This method is called on the server by the visibility system for objects on a host. Objects on a host (with a local client) cannot be disabled or destroyed when they are not visible to the local client. So this function is called to allow custom code to hide these objects. A typical implementation will disable renderer components on the object. This is only called on local clients on a host. You can check whether any given networked game object is a player by checking if its NetworkIdentity has a valid Owner. For example: int hitCount = Physics.OverlapSphereNonAlloc(transform.position, visRange, hitsBuffer3D, castLayers); for (int i = 0; i &lt; hitCount; i++) { Collider hit = hitsBuffer3D[i]; NetworkIdentity identity = hit.GetComponent&lt;NetworkIdentity&gt;(); if (identity != null &amp;&amp; identity.Owner != null) observers.Add(identity.Owner); }  "},{"title":"Mirror Migration Guide","type":0,"sectionRef":"#","url":"docs/guides/mirror-migration","content":"","keywords":""},{"title":"Namespace​","type":1,"pageTitle":"Mirror Migration Guide","url":"docs/guides/mirror-migration#namespace","content":"First of all, Mirror namespace needs to be changed to Mirage. So in your code, replace all: using Mirror;  with using Mirage;  "},{"title":"Components​","type":1,"pageTitle":"Mirror Migration Guide","url":"docs/guides/mirror-migration#components","content":"Many roles that NetworkManager fulfilled in Mirror were split into multiple simpler components in Mirage, such as NetworkClient, NetworkServer, and NetworkSceneManager. Those classes are no longer static singletons, they are MonoBehaviours instead, so you need to add them to your scene and reference them. NetworkManager in Mirage only serves as a reference holder for server and client. tip The easiest way to get started is to right-click in the Hierarchy &gt; Network &gt; NetworkManager. This will create a GameObject with all the necessary components and references already set up. "},{"title":"Accessing Mirage components from NetworkBehaviour​","type":1,"pageTitle":"Mirror Migration Guide","url":"docs/guides/mirror-migration#accessing-mirage-components-from-networkbehaviour","content":"Despite Mirage removing all static states, you can still access the important networking components from within NetworkBehaviour easily. This table shows how to access different components in comparison to Mirror: Mirror (static)\tMirage (property of NetworkBehaviour)NetworkServer\tServer NetworkClient\tClient NetworkTime\tNetworkTime doesn't exist\tClientObjectManager doesn't exist\tServerObjectManager "},{"title":"Network Events Lifecycle​","type":1,"pageTitle":"Mirror Migration Guide","url":"docs/guides/mirror-migration#network-events-lifecycle","content":"Lifecycle management is no longer based on overrides. Instead, there are many UnityEvents that can be hooked into without direct coupling. They can also be used to hook callbacks via Unity Inspector. tip This guide only shows the Mirror counterpart events, but Mirage has more events available, so be sure to check them out as they might be useful. "},{"title":"Server and client events​","type":1,"pageTitle":"Mirror Migration Guide","url":"docs/guides/mirror-migration#server-and-client-events","content":"The table below shows the override method names from Mirror's NetworkManager and the corresponding events from Mirage. Mirror (override)\tMirage (event)OnStartServer\tNetworkServer.Started OnServerConnect\tNetworkServer.Authenticated OnServerDisconnect\tNetworkServer.Disconnected OnStopServer\tNetworkServer.Stopped OnClientConnect\tNetworkClient.Authenticated OnClientDisconnect\tNetworkClient.Disconnected For example, this code from Mirror: using Mirror; public class MyNetworkManager : NetworkManager { public override void OnStartServer() { // Server started } public override void OnServerConnect(NetworkConnection conn) { // Client connected and authenticated on server } public override void OnStopServer() { // Server stopped } public override void OnStartClient() { // Client started } public override void OnClientConnect(NetworkConnection conn) { // Client connected and authenticated } public override void OnClientDisconnect(NetworkConnection conn) { // Client disconnected } }  should be changed to: using Mirage; public class MyNetworkManager : NetworkManager { void Awake() { Server.Started.AddListener(OnStartServer); Server.Authenticated.AddListener(OnServerConnect); Server.Stopped.AddListener(OnStopServer); Client.Started.AddListener(OnClientStarted); Client.Authenticated.AddListener(OnClientConnect); Client.Disconnected.AddListener(OnClientDisconnected); } void OnStartServer() { // Server started } void OnServerConnect(INetworkPlayer conn) { // Client connected (and authenticated) on server } void OnStopServer() { // Server stopped } void OnClientStarted() { // Client started } void OnClientConnect(INetworkPlayer conn) { // Client connected } void OnClientDisconnected(ClientStoppedReason reason) { // Client disconnected } }  "},{"title":"NetworkBehaviour events​","type":1,"pageTitle":"Mirror Migration Guide","url":"docs/guides/mirror-migration#networkbehaviour-events","content":"The table below shows the Mirror's NetworkBehaviour override method names on the left and the Mirage events on the right. Mirror (override)\tMirage (event)OnStartServer\tIdentity.OnStartServer OnStopServer\tIdentity.OnStopServer OnStartClient\tIdentity.OnStartClient OnStopClient\tIdentity.OnStopClient OnStartLocalPlayer\tIdentity.OnStartLocalPlayer OnStartAuthority\tIdentity.OnAuthorityChanged OnStopAuthority\tIdentity.OnAuthorityChanged Let's take this Player class as an example. In Mirror, you would do: using Mirror; public class Player : NetworkBehaviour { public override void OnStartServer() { // Player started on server } public override void OnStartClient() { // Player started on client } }  Which should be changed like so in Mirage: using Mirage; public class Player : NetworkBehaviour { void Awake() { Identity.OnStartServer.AddListener(OnStartServer); Identity.OnStartClient.AddListener(OnStartClient); } void OnStartServer() { // Player started on server } void OnStartClient() { // Player started on client } }  note Please note that due to timing all event callbacks should be registered in Awake method or via Unity inspector for them to be invoked consistently. "},{"title":"Method Attributes​","type":1,"pageTitle":"Mirror Migration Guide","url":"docs/guides/mirror-migration#method-attributes","content":"The table below shows the new attribute names in Mirage. Mirror\tMirage[Command]\t[ServerRpc] [TargetRpc]\t[ClientRpc(target = Mirage.RpcTarget enum)] [ServerCallback]\t[Server(error = false)] [ClientCallback]\t[Client(error = false)] doesn't exist\t[HasAuthority(error = false)] doesn't exist\t[LocalPlayer(error = false)] "},{"title":"Renames​","type":1,"pageTitle":"Mirror Migration Guide","url":"docs/guides/mirror-migration#renames","content":"These fields/properties have been renamed: Mirror\tMirageClientScene.localPlayer\tNetworkPlayer.Identity ClientScene.ready\tClient.Player.SceneIsReady NetworkIdentity.assetId\tNetworkIdentity.PrefabHash NetworkIdentity.netId\tNetworkIdentity.NetId NetworkIdentity.connectionToClient\tNetworkIdentity.Owner NetworkBehaviour.isServer\tNetworkBehaviour.IsServer NetworkBehaviour.connectionToClient\tNetworkBehaviour.Owner NetworkBehaviour.connectionToServer\tRemoved, use Client.Player instead NetworkBehaviour.hasAuthority\tNetworkBehaviour.HasAuthority NetworkBehaviour.Identity\tNetworkBehaviour.Identity NetworkBehaviour.netId\tNetworkBehaviour.NetId NetworkBehaviour.isClientOnly\tNetworkBehaviour.IsClientOnly NetworkBehaviour.islocalPlayer\tNetworkBehaviour.IsLocalPlayer NetworkConnection.isReady\tNetworkPlayer.SceneIsReady NetworkConnection.identity\tNetworkPlayer.Identity NetworkServer.active\tNetworkServer.Active NetworkServer.localConnection\tNetworkServer.LocalPlayer NetworkClient.connection\tNetworkClient.Player NetworkTime.time\tNetworkTime.Time "},{"title":"Object Management​","type":1,"pageTitle":"Mirror Migration Guide","url":"docs/guides/mirror-migration#object-management","content":"Registered spawnable prefabs were moved from NetworkManager to the ClientObjectManager component. You can use the Inspector to register all NetworkIdentities via a single click. "},{"title":"Spawning and destroying​","type":1,"pageTitle":"Mirror Migration Guide","url":"docs/guides/mirror-migration#spawning-and-destroying","content":"Table below shows how to spawn objects in Mirage from NetworkBehaviour: Mirror\tMirageNetworkServer.Spawn\tServerObjectManager.Spawn NetworkServer.Destroy\tServerObjectManager.Destroy "},{"title":"Networking Concepts Overview","type":0,"sectionRef":"#","url":"docs/guides/overview","content":"","keywords":""},{"title":"High-level scripting API​","type":1,"pageTitle":"Networking Concepts Overview","url":"docs/guides/overview#high-level-scripting-api","content":"Mirage’s networking has a &quot;high-level&quot; scripting API (which we’ll refer to as the HLAPI). Using this means you get access to commands which cover most of the common requirements for multiuser games without needing to worry about the &quot;lower level&quot; implementation details. The HLAPI allows you to: Control the networked state of the game using a &quot;Network Manager&quot;Operate &quot;client hosted&quot; games, where the host is also a player clientSerialize data using a general-purpose serializerSend and receive network messagesSend networked commands from clients to serversMake remote procedure calls (RPCs) from servers to clientsSend networked events from servers to clients "},{"title":"Engine and Editor integration​","type":1,"pageTitle":"Networking Concepts Overview","url":"docs/guides/overview#engine-and-editor-integration","content":"Mirage’s networking is integrated into the engine and the editor, allowing you to work with components and visual aids to build your multiplayer game. It provides: A NetworkIdentity component for networked objectsA NetworkBehaviour for networked scriptsConfigurable automatic synchronization of object transformsAutomatic synchronization of script variablesSupport for placing networked objects in Unity scenesNetwork components "},{"title":"Remote Actions Overview","type":0,"sectionRef":"#","url":"docs/guides/remote-actions/","content":"","keywords":""},{"title":"Arguments to Remote Actions​","type":1,"pageTitle":"Remote Actions Overview","url":"docs/guides/remote-actions/#arguments-to-remote-actions","content":"Mirage serializes RPC arguments to send them over the network. You can use any supported Mirage type. There are limits to what can be arguments. GameObject, NetworkIdentity, and NetworkBehaviour can be sent because they have a Network ID. But, Mirage can't send other Unity Objects by itself because it will have no way to find them on the other side. It is also possible to create serializer functions for unsupported types. You can find out more information here. "},{"title":"Network Messages","type":0,"sectionRef":"#","url":"docs/guides/remote-actions/network-messages","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"Network Messages","url":"docs/guides/remote-actions/network-messages#usage","content":"Define a new struct (rather than a class to prevent GC allocations) that will represent your message.Add any supported Mirage types as public fields of that struct. This will be the data you want to send.Register a handler for that message on the NetworkServer and/or NetworkClient's MessageHandler depending on where you want to listen for that message being received.Use the Send() method on the NetworkClient, NetworkServer, or NetworkPlayer classes depending on which way you want to send the message. "},{"title":"Example​","type":1,"pageTitle":"Network Messages","url":"docs/guides/remote-actions/network-messages#example","content":"using UnityEngine; using Mirage; public class Scores : MonoBehaviour { // attach these in the inspector public NetworkServer Server; public NetworkClient Client; // using structs to prevent GC allocations public struct ScoreMessage { public int score; public Vector3 scorePos; public int lives; } private void Awake() { Client.MessageHandler.RegisterHandler&lt;ScoreMessage&gt;(OnScore); // Register Client to listen for the ScoreMessage } public void SendScore(int score, Vector3 scorePos, int lives) { ScoreMessage msg = new ScoreMessage() { score = score, scorePos = scorePos, lives = lives }; Server.SendToAll(msg); } private void OnScore(INetworkPlayer player, ScoreMessage msg) { Debug.Log(&quot;ScoreMessage received on client with score &quot; + msg.score); } }  Note that there is no serialization code for the ScoreMessage struct in this source code example. Mirage will generate a reader and writer for ScoreMessage when it sees that it is being sent. "},{"title":"Client RPC","type":0,"sectionRef":"#","url":"docs/guides/remote-actions/client-rpc","content":"","keywords":""},{"title":"RpcTarget​","type":1,"pageTitle":"Client RPC","url":"docs/guides/remote-actions/client-rpc#rpctarget","content":"There are 3 target modes for ClientRpc: Observers (default)OwnerPlayer "},{"title":"RpcTarget.Observers​","type":1,"pageTitle":"Client RPC","url":"docs/guides/remote-actions/client-rpc#rpctargetobservers","content":"This is the default target. This will send the RPC message to only the observers of an object according to its Network Visibility. If there is no Network Visibility on the object it will send to all players. "},{"title":"RpcTarget.Owner​","type":1,"pageTitle":"Client RPC","url":"docs/guides/remote-actions/client-rpc#rpctargetowner","content":"This will send the RPC message to only the owner of the object. "},{"title":"RpcTarget.Player​","type":1,"pageTitle":"Client RPC","url":"docs/guides/remote-actions/client-rpc#rpctargetplayer","content":"This will send the RPC message to the NetworkPlayer that is passed into the call. [ClientRpc(target = RpcTarget.Player)] public void MyRpcFunction(NetworkPlayer target) { // Code to invoke on client }  Mirage will use the NetworkPlayer target to know where to send it, but it will not send the target value. Because of this, its value will always be null for the client. "},{"title":"Exclude owner​","type":1,"pageTitle":"Client RPC","url":"docs/guides/remote-actions/client-rpc#exclude-owner","content":"You may want to exclude the owner client when calling a ClientRpc. This is done with the excludeOwner option: [ClientRpc(excludeOwner = true)]. "},{"title":"Channel​","type":1,"pageTitle":"Client RPC","url":"docs/guides/remote-actions/client-rpc#channel","content":"RPC can be sent using either the Reliable or Unreliable channels. [ClientRpc(channel = Channel.Reliable)] Examples public class Player : NetworkBehaviour { private int health; public void TakeDamage(int amount) { if (!IsServer) { return; } health -= amount; Damage(amount); } [ClientRpc] private void Damage(int amount) { Debug.Log(&quot;Took damage:&quot; + amount); } }  When running a game as a host with a local client, ClientRpc calls will be invoked on the local client even though it is in the same process as the server. So the behaviors of local and remote clients are the same for ClientRpc calls. You can also specify which client gets the call with the target parameter. If you only want the client that owns the object to be called, use [ClientRpc(target = RpcTarget.Owner)] or you can specify which client gets the message by using [ClientRpc(target = RpcTarget.Player)] and passing the player as a parameter. For example: public class Player : NetworkBehaviour { private int health; [Server] private void Magic(GameObject target, int damage) { target.GetComponent&lt;Player&gt;().health -= damage; NetworkIdentity opponentIdentity = target.GetComponent&lt;NetworkIdentity&gt;(); DoMagic(opponentIdentity.Owner, damage); } [ClientRpc(target = RpcTarget.Player)] public void DoMagic(INetworkPlayer target, int damage) { // This will appear on the opponent's client, not the attacking player's Debug.Log($&quot;Magic Damage = {damage}&quot;); } [Server] private void HealMe() { health += 10; Healed(10); } [ClientRpc(target = RpcTarget.Owner)] public void Healed(int amount) { // No NetworkPlayer parameter, so it goes to owner Debug.Log($&quot;Health increased by {amount}&quot;); } }  "},{"title":"RPC Examples","type":0,"sectionRef":"#","url":"docs/guides/remote-actions/rpc-examples","content":"","keywords":""},{"title":"Example 1​","type":1,"pageTitle":"RPC Examples","url":"docs/guides/remote-actions/rpc-examples#example-1","content":"Set a player's name from a client and have it synced to other players. public class Player : NetworkBehaviour { [SyncVar] public string PlayerName; [ServerRpc] public void RpcChangeName(string newName) { PlayerName = newName; } }  "},{"title":"Generated code​","type":1,"pageTitle":"RPC Examples","url":"docs/guides/remote-actions/rpc-examples#generated-code","content":"Weaver moves the user code into a new function and then replaces the body of the RPC with an internal send call. RPCs are registered using the classes static constructor with methods that will read all the parameters and then invoke the user code method. public class Player : NetworkBehaviour { [SyncVar] public string PlayerName; [ServerRpc] public void RpcChangeName(string newName) { if (this.IsServer) { UserCode_RpcChangeName_123456789(newName); } else { using (PooledNetworkWriter writer = NetworkWriterPool.GetWriter()) { writer.WriteString(newName); ServerRpcSender.Send(this, 123456789, writer, 0, true); } } } public void UserCode_RpcChangeName_123456789(string newName) { PlayerName = newName; } protected void Skeleton_RpcChangeName_123456789(NetworkReader reader, INetworkPlayer senderConnection, int replyId) { this.UserCode_RpcChangeName_123456789(reader.ReadString()); } public Player() { this.remoteCallCollection.Register(0, typeof(Player), &quot;Player.RpcChangeName&quot;, RpcInvokeType.ServerRpc, new CmdDelegate(Skeleton_RpcChangeName), true); } protected override int GetRpcCount() { return 1; } }  "},{"title":"Resources","type":0,"sectionRef":"#","url":"docs/guides/resources","content":"","keywords":""},{"title":"Video Tutorials Playlists​","type":1,"pageTitle":"Resources","url":"docs/guides/resources#video-tutorials-playlists","content":"note These videos are meant for Mirror but much of what they teach also applies to Mirage. Unity - Mirror Networking by First Gear GamesMirror Multiplayer by Dapper Dino "},{"title":"Object Pooling​","type":1,"pageTitle":"Resources","url":"docs/guides/resources#object-pooling","content":"Simple object pooling scriptAdvanced object pooling scripts "},{"title":"Loading scenes in Mirage","type":0,"sectionRef":"#","url":"docs/guides/scene-loading/","content":"Loading scenes in Mirage Use NetworkSceneManager to help load scenes and sync them between server and client. To customize scene handling you can make a subclass and override the virtual methods. If you need more unique logic to load scenes you can have full control by following this guide.","keywords":""},{"title":"Server RPC","type":0,"sectionRef":"#","url":"docs/guides/remote-actions/server-rpc","content":"","keywords":""},{"title":"Returning values​","type":1,"pageTitle":"Server RPC","url":"docs/guides/remote-actions/server-rpc#returning-values","content":"ServerRpcs can return values. It can take a long time for the server to reply, so they must return a UniTask which the client can await. To return a value, add a return value using UniTask&lt;MyReturnType&gt; where MyReturnType is any supported Mirage type. In the server, you can make your method async, or you can use UniTask.FromResult(myResult);. For example: public class Shop: NetworkBehavior { [ServerRpc] public UniTask&lt;int&gt; GetPrice(string item) { switch (item) { case &quot;turnip&quot;: return UniTask.FromResult(10); case &quot;apple&quot;: return UniTask.FromResult(3); default: return UniTask.FromResult(int.MaxValue); } } [Client] public async UniTaskVoid DisplayTurnipPrice() { // Call the RPC and wait for the response without blocking the main thread int price = await GetPrice(&quot;turnip&quot;); Debug.Log($&quot;Turnips price {price}&quot;); } }  "},{"title":"ServerRpc and Authority​","type":1,"pageTitle":"Server RPC","url":"docs/guides/remote-actions/server-rpc#serverrpc-and-authority","content":"It is possible to invoke ServerRpcs on non-character objects if any of the following are true: The object was spawned with client authorityThe object has client authority set with NetworkIdentity.AssignClientAuthoritythe Server RPC Call has the requireAuthority option set false. You can include an optional INetworkPlayer sender = null parameter in the Server RPC Call method signature and Mirage will fill in the sending client for you.Do not try to set a value for this optional parameter...it will be ignored. Server RPC Calls sent from these objects are run on the server instance of the object, not on the associated character object for the client. public enum DoorState : byte { Open, Closed } public class Door : NetworkBehaviour { [SyncVar] public DoorState doorState; [ServerRpc(requireAuthority = false)] public void CmdSetDoorState(DoorState newDoorState, INetworkPlayer sender = null) { if (sender.identity.GetComponent&lt;Player&gt;().hasDoorKey) { doorState = newDoorState; } } }  "},{"title":"Manual Scene Loading","type":0,"sectionRef":"#","url":"docs/guides/scene-loading/manual-scene-loading","content":"","keywords":""},{"title":"Using Messages​","type":1,"pageTitle":"Manual Scene Loading","url":"docs/guides/scene-loading/manual-scene-loading#using-messages","content":"These messages are built-in and used by NetworkSceneManager. If you are creating your own scene logic then you can re-use these messages for your purpose. SceneMessage: Sent to the client to load a sceneSceneReadyMessage: Sent to either client or server when they have finished loading "},{"title":"Loading a Scene​","type":1,"pageTitle":"Manual Scene Loading","url":"docs/guides/scene-loading/manual-scene-loading#loading-a-scene","content":"Server Mark Player as not ready, using NetworkPlayer.SceneIsReadySend SceneMessage to clients Client After receiving SceneMessage (optional) Mark local player as not ready Load the scene After loading finished Call ClientObjectManager.PrepareToSpawnSceneObjects (This will tell Mirage about any new scene objects)(optional) Mark local player as ready Send SceneReadyMessage to the server Server After receiving SceneReadyMessage Mark the player as ready using: player.SceneIsReady = trueCall ServerObjectManager.SpawnVisibleObjects or ServerObjectManager.AddCharacter (Mirage will send spawn message to client) "},{"title":"SpawnVisibleObjects vs AddCharacter​","type":1,"pageTitle":"Manual Scene Loading","url":"docs/guides/scene-loading/manual-scene-loading#spawnvisibleobjects-vs-addcharacter","content":"When calling SpawnVisibleObjects it will only spawn objects if the player has a character. This check can be avoided by using the IgnoreHasCharacter argument. When AddCharacter is called it will send a spawn message for the new character to the client. After that, it will call SpawnVisibleObjects to spawn any objects that are visible to the new character. If your game has a player character you'll want to use AddCharacter most of the time. But if your game does not have a player character or you want to spawn objects earlier then you should use SpawnVisibleObjects with IgnoreHasCharacter set up true. You can also use SpawnVisibleObjects(player, true) to spawn scene objects before the player character by calling it before AddCharacter. note Make sure to call ClientObjectManager.PrepareToSpawnSceneObjects client side before calling SpawnVisibleObjects or AddCharacter. If that function is not called the client will not be able to find scene objects when spawn messages are received. "},{"title":"Host mode​","type":1,"pageTitle":"Manual Scene Loading","url":"docs/guides/scene-loading/manual-scene-loading#host-mode","content":"If using this setup in Host mode make sure you only load the Scene once, this can be done by checking if the server is active before loading the scene on the client. The rest of the setup should stay the same. In host mode, there will be 2 copies of the NetworkPlayer one for the client-side and one for the server-side. When using player.SceneIsReady you will need to make sure you are setting it on both copies of the player. The easiest way to do this is just to treat the host client as a normal client and send the message, but be aware of any functions you don't want to be called twice. "},{"title":"Using Network Scene Manager","type":0,"sectionRef":"#","url":"docs/guides/scene-loading/network-scene-manager","content":"","keywords":""},{"title":"How to use​","type":1,"pageTitle":"Using Network Scene Manager","url":"docs/guides/scene-loading/network-scene-manager#how-to-use","content":"The Network Scene Manager takes care of most of the grunt work that is needed to load unload and network scenes between server and client. The examples below show exactly how to use the network scene manager. "},{"title":"Load Scene Normally​","type":1,"pageTitle":"Using Network Scene Manager","url":"docs/guides/scene-loading/network-scene-manager#load-scene-normally","content":"This will load up a new scene on the server and tell all current player's loaded on the server to load the scene up. public class LoadScene : MonoBehaviour { public void Start() { NetworkSceneManager sceneManager = GetComponent&lt;NetworkSceneManager&gt;(); sceneManager.ServerLoadSceneNormal(&quot;path to scene asset file.&quot;) } }  note If you require physics scenes to load up on the server you can override the default parameter like so. sceneManager.ServerLoadSceneNormal(&quot;path to scene asset file.&quot;, new LoadSceneParameters { loadSceneMode = LoadSceneMode.Normal, localPhysicsMode = LocalPhysicsMode.Physics2D });  "},{"title":"Load Scene Additively​","type":1,"pageTitle":"Using Network Scene Manager","url":"docs/guides/scene-loading/network-scene-manager#load-scene-additively","content":"This will load a scene additively on the server and tell specific clients to do the same. Example shows send to everyone. public class LoadSceneAdditively : MonoBehaviour { public void Start() { NetworkSceneManager sceneManager = GetComponent&lt;NetworkSceneManager&gt;(); sceneManager.ServerLoadSceneAdditively(&quot;path to scene asset file.&quot;, sceneManager.Server.Players) } }  note If you want to send the additive scene to only specific players we can do it like so. You must get the player on your own. sceneManager.ServerLoadSceneAdditively(&quot;path to scene asset file.&quot;, Player)  note Also if you want to load the scene normally to specific players versus additively like the server you can override the parameter to do so also. The server will still load additively, the reason is if you need fully normal loading you can use the above method instead to do it. sceneManager.ServerLoadSceneAdditively(&quot;path to scene asset file.&quot;, Player, true)  note Also if you want to load the scene in physic's mode you can override another parameter also to do so. You can also make clients load normally in the example below we keep it false to load the client side additively too. sceneManager.ServerLoadSceneAdditively(&quot;path to scene asset file.&quot;, Player, false, new LoadSceneParameters { loadSceneMode = LoadSceneMode.Additively, localPhysicsMode = LocalPhysicsMode.Physics2D )  This will unload a scene additively on the server and tell specific clients to do the same. Example shows send to everyone. public class UnLoadSceneAdditively : MonoBehaviour { public void Start() { NetworkSceneManager sceneManager = GetComponent&lt;NetworkSceneManager&gt;(); sceneManager.ServerUnloadSceneAdditively(&quot;path to scene asset file.&quot;, sceneManager.Server.Players) } }  note If you want to send the additive scene to only specific players we can do it like so. You must get the player on your own. sceneManager.ServerLoadSceneAdditively(&quot;path to scene asset file.&quot;, Player)  "},{"title":"Virtual Methods​","type":1,"pageTitle":"Using Network Scene Manager","url":"docs/guides/scene-loading/network-scene-manager#virtual-methods","content":"Some of the methods in NetworkSceneManager can be overridden to customize how it works StartOnDestroyClientStartSceneMessageClientFinishedLoadingSceneMessageClientNotReadyMessageOnServerAuthenticatedOnServerPlayerDisconnected "},{"title":"Example - OnServerAuthenticated​","type":1,"pageTitle":"Using Network Scene Manager","url":"docs/guides/scene-loading/network-scene-manager#example---onserverauthenticated","content":"By default OnServerAuthenticated sends the active scene and all additive scenes to the client, It can be overridden to only send the active scene: public class MySceneManager : NetworkSceneManager { protected internal override void OnServerAuthenticated(INetworkPlayer player) { // just load server's active scene instead of all additive scenes as well player.Send(new SceneMessage { MainActivateScene = ActiveScenePath }); player.Send(new SceneReadyMessage()); } }  "},{"title":"Example - Start​","type":1,"pageTitle":"Using Network Scene Manager","url":"docs/guides/scene-loading/network-scene-manager#example---start","content":"By default, Start registers all our listeners for scene management handling. If you need to override it then do this and add your stuff. public class MySceneManager : NetworkSceneManager { protected internal override void Start() { // add your stuff before. base.Start(); // add your stuff after. } }  "},{"title":"Example - OnDestroy​","type":1,"pageTitle":"Using Network Scene Manager","url":"docs/guides/scene-loading/network-scene-manager#example---ondestroy","content":"By default OnDestroy de-registers all our listener's for scene management handling. If you need to override it then do this and add your stuff. public class MySceneManager : NetworkSceneManager { protected internal override void OnDestroy() { // add your stuff before. base.OnDestroy(); // add your stuff after. } }  "},{"title":"Serialization","type":0,"sectionRef":"#","url":"docs/guides/serialization","content":"","keywords":""},{"title":"Rules And Tips​","type":1,"pageTitle":"Serialization","url":"docs/guides/serialization#rules-and-tips","content":"There are some rules and limits for what Weaver can do. Some features add complexity and are hard to maintain so have not been implemented. These features are not impossible to implement and could be added if there is a high demand for them. You should be able to write Custom Read/Write functions for any type, and Weaver will use them. This means if there is an unsupported type like int[][] creating a custom Read/Write function will allow you to sync int[][] in SyncVar/ClientRpc/etc If you have a type that has a field that is not able to be serialized, you can mark that field with[System.NonSerialized] and weaver will ignore it "},{"title":"Unsupported Types​","type":1,"pageTitle":"Serialization","url":"docs/guides/serialization#unsupported-types","content":"Some of these types are unsupported due to the complexity they would add, as mentioned above. note Types in this list can have custom writers. Jagged and Multidimensional arrayTypes that Inherit from UnityEngine.ComponentUnityEngine.ObjectUnityEngine.ScriptableObjectGeneric Types, eg MyData&lt;T&gt; Custom Read/Write must declare T, eg MyData&lt;int&gt; InterfacesTypes that reference themselves "},{"title":"Built-in Read Write Functions​","type":1,"pageTitle":"Serialization","url":"docs/guides/serialization#built-in-read-write-functions","content":"Mirage provides some built-in Read/Write Functions. They can be found in NetworkReaderExtensions and NetworkWriterExtensions. This is a non-compete list of types that have built-in functions, check the classes above to see the full list. Most C# primitive types Common Unity structs Vector3QuaternionRectRayGuid NetworkIdentity, GameObject, Transform NetworkIdentity, GameObject, Transform​ The NetId of the object is sent over the network, and the object with the same NetId is returned on the other side. If the NetId is zero or an object is not found then null will be returned. "},{"title":"Generated Read Write Functions​","type":1,"pageTitle":"Serialization","url":"docs/guides/serialization#generated-read-write-functions","content":"Weaver will generate read/write functions for: Classes or StructsEnumsArrays eg int[] ArraySegments eg ArraySegment&lt;int&gt; Lists eg List&lt;int&gt; Classes and Structs​ Weaver will read/write every public field in the type unless the field is marked with [System.NonSerialized]. If there is an unsupported type in the class or struct Weaver will fail to make read/write functions for it. caution The weaver does not check properties Enums​ Weaver will use the underlying type of an enum to read and write them. By default this is int. For example, Switch will use the byte read/write functions to be serialized public enum Switch : byte { Left, Middle, Right, }  Collections​ Weaver will generate writes for the collections listed above. Weaver will use the element's read/write function, so it must be a supported type or have a custom read/write function. For example: float[] is a supported type because Mirage has a built-in read/write function for float.MyData[] is a supported type as Weaver is able to generate a read/write function for MyData  public struct MyData { public int someValue; public float anotherValue; }  "},{"title":"Adding Custom Read Write functions​","type":1,"pageTitle":"Serialization","url":"docs/guides/serialization#adding-custom-read-write-functions","content":"Custom read/write functions are static methods like this: public static void WriteMyType(this NetworkWriter writer, MyType value) { // write MyType data here } public static MyType ReadMyType(this NetworkReader reader) { // read MyType data here }  It is best practice to make read/write extension methods so they can be called like writer.WriteMyType(value). It is a good idea to call them ReadMyType and WriteMyType so it is obvious what type they are for. However the name of the function doesn't matter, weaver should be able to find it no matter what it is called. Properties Example​ Weaver won't write properties, but a custom writer can be used to send them over the network. This can be useful if you want to have private set for your properties public struct MyData { public int someValue { get; private set; } public float anotherValue { get; private set; } public MyData(int someValue, float anotherValue) { this.someValue = someValue; this.anotherValue = anotherValue; } } public static class CustomReadWriteFunctions { public static void WriteMyType(this NetworkWriter writer, MyData value) { writer.WriteInt32(value.someValue); writer.WriteSingle(value.anotherValue); } public static MyData ReadMyType(this NetworkReader reader) { return new MyData(reader.ReadInt32(), reader.ReadSingle()); } }  Unsupported type Example​ Rigidbody is an unsupported type because it inherits from Component. But a custom writer can be added so that it is synced using a NetworkIdentity if one is attached. public struct MyCollision { public Vector3 force; public Rigidbody rigidbody; } public static class CustomReadWriteFunctions { public static void WriteMyCollision(this NetworkWriter writer, MyCollision value) { writer.WriteVector3(value.force); NetworkIdentity networkIdentity = value.rigidbody.GetComponent&lt;NetworkIdentity&gt;(); writer.WriteNetworkIdentity(networkIdentity); } public static MyCollision ReadMyCollision(this NetworkReader reader) { Vector3 force = reader.ReadVector3(); NetworkIdentity networkIdentity = reader.ReadNetworkIdentity(); Rigidbody rigidBody = networkIdentity != null ? networkIdentity.GetComponent&lt;Rigidbody&gt;() : null; return new MyCollision { force = force, rigidbody = rigidBody, }; } }  Above are functions for MyCollision, but instead, you could add functions for Rigidbody and let weaver would generate a writer for MyCollision. public static class CustomReadWriteFunctions { public static void WriteRigidbody(this NetworkWriter writer, Rigidbody rigidbody) { NetworkIdentity networkIdentity = rigidbody.GetComponent&lt;NetworkIdentity&gt;(); writer.WriteNetworkIdentity(networkIdentity); } public static Rigidbody ReadRigidbody(this NetworkReader reader) { NetworkIdentity networkIdentity = reader.ReadNetworkIdentity(); Rigidbody rigidBody = networkIdentity != null ? networkIdentity.GetComponent&lt;Rigidbody&gt;() : null; return rigidBody; } }  "},{"title":"Debugging​","type":1,"pageTitle":"Serialization","url":"docs/guides/serialization#debugging","content":"You can use tools like dnSpy or ILSpy to view the complied code after Weaver has altered it. This can help with understanding and debug what Mirage and Weaver does. "},{"title":"Sync Dictionary","type":0,"sectionRef":"#","url":"docs/guides/sync/sync-dictionary","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"Sync Dictionary","url":"docs/guides/sync/sync-dictionary#usage","content":"Add a field of type SyncDictionary on any NetworkBehaviour where TKey and TValue can be any supported Mirage type and initialize it. IMPORTANT You need to initialize the SyncDictionary immediately after the definition for them to work. You can mark them as readonly to enforce proper usage. "},{"title":"Basic example​","type":1,"pageTitle":"Sync Dictionary","url":"docs/guides/sync/sync-dictionary#basic-example","content":"using UnityEngine; using Mirage; using Mirage.Collections; [System.Serializable] public struct Item { public string name; public int hitPoints; public int durability; } public class Player : NetworkBehaviour { public readonly SyncDictionary&lt;stirng, Item&gt; equipment = new SyncDictionary&lt;string, Item&gt;(); private void Awake() { Identity.OnStartServer.AddListener(OnStartServer); } private void OnStartServer() { equipment.Add(&quot;head&quot;, new Item { name = &quot;Helmet&quot;, hitPoints = 10, durability = 20 }); equipment.Add(&quot;body&quot;, new Item { name = &quot;Epic Armor&quot;, hitPoints = 50, durability = 50 }); equipment.Add(&quot;feet&quot;, new Item { name = &quot;Sneakers&quot;, hitPoints = 3, durability = 40 }); equipment.Add(&quot;hands&quot;, new Item { name = &quot;Sword&quot;, hitPoints = 30, durability = 15 }); } }  "},{"title":"Callbacks​","type":1,"pageTitle":"Sync Dictionary","url":"docs/guides/sync/sync-dictionary#callbacks","content":"You can detect when a SyncDictionary changes on the client and/or server. This is especially useful for refreshing your UI, character appearance, etc. There are different callbacks for different operations, such as OnChange (any change to the dictionary), OnInsert (adding a new element), etc. Please check the SyncDictionary API reference for the complete list of callbacks. Depending on where you want to invoke the callbacks, you can use these methods to register them: Awake for both client and serverIdentity.OnStartServer event for server-onlyIdentity.OnStartClient event for client-only note By the time you subscribe, the dictionary will already be initialized, so you will not get a call for the initial data, only updates. "},{"title":"Example​","type":1,"pageTitle":"Sync Dictionary","url":"docs/guides/sync/sync-dictionary#example","content":"using Mirage; using Mirage.Collections; public class Player : NetworkBehaviour { public readonly SyncDictionary&lt;stirng, Item&gt; equipment = new SyncDictionary&lt;string, Item&gt;(); public readonly SyncDictionary&lt;stirng, Item&gt; hotbar = new SyncDictionary&lt;string, Item&gt;(); // This will hook the callback on both server and client private void Awake() { equipment.OnChange += UpdateEquipment; Identity.OnStartClient.AddListener(OnStartClient); } // Hotbar changes will only be invoked on clients private void OnStartClient() { hotbar.OnChange += UpdateHotbar; } private void UpdateEquipment() { // Here you can refresh your UI for instance } private void UpdateHotbar() { // Here you can refresh your UI for instance } }  By default, SyncDictionary uses a Dictionary to store its data. If you want to use a different dictionary implementation, add a constructor and pass the dictionary implementation to the parent constructor. For example: public SyncDictionary&lt;string, Item&gt; myDict = new SyncIDictionary&lt;string, Item&gt;(new MyDictionary&lt;string, Item&gt;());  "},{"title":"State Synchronization","type":0,"sectionRef":"#","url":"docs/guides/sync/","content":"","keywords":""},{"title":"Sync To Owner​","type":1,"pageTitle":"State Synchronization","url":"docs/guides/sync/#sync-to-owner","content":"It is often the case when you don't want some player data visible to other players. In the inspector change the &quot;Network Sync Mode&quot; from &quot;Observers&quot; (default) to &quot;Owner&quot; to let Mirage know to synchronize the data only with the owning client. For example, suppose you are making an inventory system. Suppose players A, B, and C are in the same area. There will be a total of 12 objects in the entire network: Client A has Player A (himself), Player B, and Player CClient B has Player A, Player B (himself), and Player CClient C has Player A, Player B, and Player C (himself)The server has Player A, Player B, Player C each one of them would have an Inventory component Suppose Player A picks up some loot. The server adds the loot to Player's A inventory, which would have a SyncLists of Items. By default, Mirage now has to synchronize player A's inventory everywhere, which means sending an update message to client A, client B, and client C, because they all have a copy of Player A. This is wasteful, Client B and Client C do not need to know about Player's A inventory, they never see it on screen. It is also a security problem, someone could hack the client and display other people's inventory and use it to their advantage. If you set the &quot;Network Sync Mode&quot; in the Inventory component to &quot;Owner&quot;, then Player A's inventory will only be synchronized with Client A. Now, suppose instead of 3 people you have 50 people in an area and one of them picks up loot. It means that instead of sending 50 messages to 50 different clients, you would only send 1. This can have a big impact on the bandwidth in your game. Other typical use cases include quests, player's hand in a card game, skills, experience, or any other data you don't need to share with other players. "},{"title":"Advanced State Synchronization​","type":1,"pageTitle":"State Synchronization","url":"docs/guides/sync/#advanced-state-synchronization","content":"In most cases, the use of SyncVars is enough for your game scripts to serialize their state to clients. However, in some cases, you might require more complex serialization code. This page is only relevant for advanced developers who need customized synchronization solutions that go beyond Mirage’s normal SyncVar feature. "},{"title":"Custom Serialization Functions​","type":1,"pageTitle":"State Synchronization","url":"docs/guides/sync/#custom-serialization-functions","content":"To perform your own custom serialization, you can implement virtual functions on NetworkBehaviour to be used for SyncVar serialization. These functions are: public virtual bool OnSerialize(NetworkWriter writer, bool initialState);  public virtual void OnDeserialize(NetworkReader reader, bool initialState);  Use the initialState flag to differentiate between the first time a game object is serialized and when incremental updates can be sent. The first time a game object is sent to a client, it must include a full state snapshot, but subsequent updates can save on bandwidth by including only incremental changes. The OnSerialize function should return true to indicate that an update should be sent. If it returns true, the dirty bits for that script are set to zero. If it returns false, the dirty bits are not changed. This allows multiple changes to a script to be accumulated over time and sent when the system is ready, instead of every frame. The OnSerialize function is only called for initialState or when the NetworkBehaviour is dirty. A NetworkBehaviour will only be dirty if a SyncVar or SyncObject (e.g. SyncList) has changed since the last OnSerialize call. After data has been sent the NetworkBehaviour will not be dirty again until the next syncInterval (set in the inspector). A NetworkBehaviour can also be marked as dirty by manually calling SetDirtyBit (this does not bypass the syncInterval limit). Although this works, it is usually better to let Mirage generate these methods and provide custom serializers for your specific field. "},{"title":"Serialization Flow​","type":1,"pageTitle":"State Synchronization","url":"docs/guides/sync/#serialization-flow","content":"Game objects with the Network Identity component attached can have multiple scripts derived from NetworkBehaviour. The flow for serializing these game objects is: On the server: Each NetworkBehaviour has a dirty mask. This mask is available inside OnSerialize as syncVarDirtyBitsEach SyncVar in a NetworkBehaviour script is assigned a bit in the dirty mask.Changing the value of SyncVars causes the bit for that SyncVar to be set in the dirty maskAlternatively, calling SetDirtyBit writes directly to the dirty maskNetworkIdentity game objects are checked on the server as part of its update loopIf any NetworkBehaviours on a NetworkIdentity are dirty, then a UpdateVars packet is created for that game objectThe UpdateVars packet is populated by calling OnSerialize on each NetworkBehaviour on the game objectNetworkBehaviours that are not dirty write a zero to the packet for their dirty bitsNetworkBehaviours that are dirty write their dirty mask, then the values for the SyncVars that have changedIf OnSerialize returns true for a NetworkBehaviour, the dirty mask is reset for that NetworkBehaviour so it does not send again until its value changes.The UpdateVars packet is sent to ready clients that are observing the game object On the client: an UpdateVars packet is received for a game objectThe OnDeserialize function is called for each NetworkBehaviour script on the game objectEach NetworkBehaviour script on the game object reads a dirty mask.If the dirty mask for a NetworkBehaviour is zero, the OnDeserialize function returns without reading any moreIf the dirty mask is a non-zero value, then the OnDeserialize function reads the values for the SyncVars that correspond to the dirty bits that are setIf there are SyncVar hook functions, those are invoked with the value read from the stream. So for this script: using Mirage; public class Data : NetworkBehaviour { [SyncVar(hook = nameof(OnInt1Changed))] public int int1 = 66; [SyncVar] public int int2 = 23487; [SyncVar] public string MyString = &quot;Example string&quot;; void OnInt1Changed(int oldValue, int newValue) { // do something here } }  The following sample shows the code that is generated by Mirage for the SerializeSyncVars function which is called inside NetworkBehaviour.OnSerialize: public override bool SerializeSyncVars(NetworkWriter writer, bool initialState) { // Write any SyncVars in base class bool written = base.SerializeSyncVars(writer, forceAll); if (initialState) { // The first time a game object is sent to a client, send all the data (and no dirty bits) writer.WritePackedUInt32((uint)this.int1); writer.WritePackedUInt32((uint)this.int2); writer.Write(this.MyString); return true; } else { // Writes which SyncVars have changed writer.WritePackedUInt64(base.syncVarDirtyBits); if ((base.get_syncVarDirtyBits() &amp; 1u) != 0u) { writer.WritePackedUInt32((uint)this.int1); written = true; } if ((base.get_syncVarDirtyBits() &amp; 2u) != 0u) { writer.WritePackedUInt32((uint)this.int2); written = true; } if ((base.get_syncVarDirtyBits() &amp; 4u) != 0u) { writer.Write(this.MyString); written = true; } return written; } }  The following sample shows the code that is generated by Mirage for the DeserializeSyncVars function which is called inside NetworkBehaviour.OnDeserialize: public override void DeserializeSyncVars(NetworkReader reader, bool initialState) { // Read any SyncVars in base class base.DeserializeSyncVars(reader, initialState); if (initialState) { // The first time a game object is sent to a client, read all the data (and no dirty bits) int oldInt1 = this.int1; this.int1 = (int)reader.ReadPackedUInt32(); // if old and new values are not equal, call hook if (!base.SyncVarEqual&lt;int&gt;(num, ref this.int1)) { this.OnInt1Changed(num, this.int1); } this.int2 = (int)reader.ReadPackedUInt32(); this.MyString = reader.ReadString(); return; } int dirtySyncVars = (int)reader.ReadPackedUInt32(); // is 1st SyncVar dirty if ((dirtySyncVars &amp; 1) != 0) { int oldInt1 = this.int1; this.int1 = (int)reader.ReadPackedUInt32(); // if old and new values are not equal, call hook if (!base.SyncVarEqual&lt;int&gt;(num, ref this.int1)) { this.OnInt1Changed(num, this.int1); } } // is 2nd SyncVar dirty if ((dirtySyncVars &amp; 2) != 0) { this.int2 = (int)reader.ReadPackedUInt32(); } // is 3rd SyncVar dirty if ((dirtySyncVars &amp; 4) != 0) { this.MyString = reader.ReadString(); } }  If a NetworkBehaviour has a base class that also has serialization functions, the base class functions should also be called. "},{"title":"Sync Hash Set","type":0,"sectionRef":"#","url":"docs/guides/sync/sync-hash-set","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"Sync Hash Set","url":"docs/guides/sync/sync-hash-set#usage","content":"Create a class that derives from SyncHashSet for your specific type. This is necessary because Mirage will add methods to that class with the weaver. Then add a SyncHashSet field to your NetworkBehaviour class. For example: IMPORTANT You need to initialize the SyncHashSet immediately after the definition in order for them to work. You can mark them as readonly to enforce proper usage. "},{"title":"Basic example​","type":1,"pageTitle":"Sync Hash Set","url":"docs/guides/sync/sync-hash-set#basic-example","content":"[System.Serializable] public class SyncSkillSet : SyncHashSet&lt;string&gt; {} public class Player : NetworkBehaviour { [SerializeField] readonly SyncSkillSet skills = new SyncSkillSet(); int skillPoints = 10; [Command] public void CmdLearnSkill(string skillName) { if (skillPoints &gt; 1) { skillPoints--; skills.Add(skillName); } } }  Callbacks You can detect when a SyncHashSet changes on the client and/or the server. This is especially useful for refreshing your UI, character appearance, etc. Subscribe to the Callback event typically during Start, OnClientStart, or OnServerStart for that. note Note that by the time you subscribe, the set will already be initialized, so you will not get a call for the initial data, only updates. [System.Serializable] public class SyncSetBuffs : SyncHashSet&lt;string&gt; {}; public class Player : NetworkBehaviour { [SerializeField] public readonly SyncSetBuffs buffs = new SyncSetBuffs(); // this will add the delegate on the client. // Use OnStartServer instead if you want it on the server public override void OnStartClient() { buffs.Callback += OnBuffsChanged; } private void OnBuffsChanged(SyncSetBuffs.Operation op, string buff) { switch (op) { case SyncSetBuffs.Operation.OP_ADD: // we added a buff, draw an icon on the character break; case SyncSetBuffs.Operation.OP_CLEAR: // clear all buffs from the character break; case SyncSetBuffs.Operation.OP_REMOVE: // We removed a buff from the character break; } } }  "},{"title":"Sync Sorted Set","type":0,"sectionRef":"#","url":"docs/guides/sync/sync-sorted-set","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"Sync Sorted Set","url":"docs/guides/sync/sync-sorted-set#usage","content":"Create a class that derives from SyncSortedSet for your specific type. This is necessary because Mirage will add methods to that class with the weaver. Then add a SyncSortedSet field to your NetworkBehaviour class. For example: IMPORTANT You need to initialize the SyncSortedSet immediately after the definition for them to work. You can mark them as readonly to enforce proper usage. class Player : NetworkBehaviour { class SyncSkillSet : SyncSortedSet&lt;string&gt; {} readonly SyncSkillSet skills = new SyncSkillSet(); int skillPoints = 10; [Command] public void CmdLearnSkill(string skillName) { if (skillPoints &gt; 1) { skillPoints--; skills.Add(skillName); } } }  You can also detect when a SyncSortedSet changes. This is useful for refreshing your character in the client or determining when you need to update your database. Subscribe to the Callback event typically during Start, OnClientStart, or OnServerStart for that. note That by the time you subscribe, the set will already be initialized, so you will not get a call for the initial data, only updates. public class Player : NetworkBehaviour { private class SyncSetBuffs : SyncSortedSet&lt;string&gt; {}; private readonly SyncSetBuffs buffs = new SyncSetBuffs(); // This will add the delegate on the client. // Use OnStartServer instead if you want it on the server public override void OnStartClient() { buffs.Callback += OnBuffsChanged; } private void OnBuffsChanged(SyncSetBuffs.Operation op, string buff) { switch (op) { case SyncSetBuffs.Operation.OP_ADD: // we added a buff, draw an icon on the character break; case SyncSetBuffs.Operation.OP_CLEAR: // clear all buffs from the character break; case SyncSetBuffs.Operation.OP_REMOVE: // We removed a buff from the character break; } } }  "},{"title":"Sync List","type":0,"sectionRef":"#","url":"docs/guides/sync/sync-list","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"Sync List","url":"docs/guides/sync/sync-list#usage","content":"Add a field of type SyncList on any NetworkIdentity where T can be any supported Mirage type and initialize it. IMPORTANT You need to initialize the SyncList immediately after the definition for them to work. You can mark them as readonly to enforce proper usage. "},{"title":"Basic example​","type":1,"pageTitle":"Sync List","url":"docs/guides/sync/sync-list#basic-example","content":"using Mirage; using Mirage.Collections; [System.Serializable] public struct Item { public string name; public int amount; public Color32 color; } public class Player : NetworkBehaviour { private readonly SyncList&lt;Item&gt; inventory = new SyncList&lt;Item&gt;(); public int coins = 100; [ServerRpc] public void Purchase(string itemName) { if (coins &gt; 10) { coins -= 10; Item item = new Item { name = &quot;Sword&quot;, amount = 3, color = new Color32(125, 125, 125, 255) }; // During next synchronization, all clients will see the item inventory.Add(item); } } }  "},{"title":"Callbacks​","type":1,"pageTitle":"Sync List","url":"docs/guides/sync/sync-list#callbacks","content":"You can detect when a SyncList changes on the client and/or server. This is especially useful for refreshing your UI, character appearance, etc. There are different callbacks for different operations, such as OnChange (any change to the list), OnInsert (adding a new element), etc. Please check the SyncList API reference for the complete list of callbacks. Depending on where you want to invoke the callbacks, you can use these methods to register them: Awake for both client and serverIdentity.OnStartServer event for server-onlyIdentity.OnStartClient event for client-only note By the time you subscribe, the list will already be initialized, so you will not get a call for the initial data, only updates. "},{"title":"Example​","type":1,"pageTitle":"Sync List","url":"docs/guides/sync/sync-list#example","content":"using Mirage; using Mirage.Collections; public class Player : NetworkBehaviour { private readonly SyncList&lt;Item&gt; inventory = new SyncList&lt;Item&gt;(); private readonly SyncList&lt;Item&gt; hotbar = new SyncList&lt;Item&gt;(); // This will hook the callback on both server and client private void Awake() { inventory.OnChange += UpdateInventory; Identity.OnStartClient.AddListener(OnStartClient); } // Hotbar changes will only be invoked on clients private void OnStartClient() { hotbar.OnChange += UpdateHotbar; } private void UpdateInventory() { // Here you can refresh your UI for instance } private void UpdateHotbar() { // Here you can refresh your UI for instance } }  By default, SyncList uses a List to store its data. If you want to use a different list implementation, add a constructor and pass the list implementation to the parent constructor. For example: public SyncList&lt;Item&gt; myList = new SyncList&lt;Item&gt;(new MyIList&lt;Item&gt;());  "},{"title":"Mirage.Authenticators","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Authenticators/","content":"","keywords":""},{"title":"Classes​","type":1,"pageTitle":"Mirage.Authenticators","url":"docs/reference/Mirage.Authenticators/#classes","content":"BasicAuthenticator​ Basic Authenticator that lets the server/host set a &quot;passcode&quot; in order to connect. This code could be a short string that can be used to host a private game. The host would set the code and then give it to their friends allowing them to join. TimeoutAuthenticator​ An authenticator that disconnects connections if they don't authenticate within a specified time limit. "},{"title":"Class BasicAuthenticator","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Authenticators/BasicAuthenticator","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class BasicAuthenticator","url":"docs/reference/Mirage.Authenticators/BasicAuthenticator#fields","content":"serverCode​ Code given to clients so that they can connect to the server/host Set this in inspector or at runtime when the server/host starts Declaration​ public string serverCode  "},{"title":"Methods​","type":1,"pageTitle":"Class BasicAuthenticator","url":"docs/reference/Mirage.Authenticators/BasicAuthenticator#methods","content":"ServerSetup(NetworkServer)​ Declaration​ public override void ServerSetup(NetworkServer server)  Parameters​ Type\tName\tDescriptionMirage.NetworkServer\tserver\t ServerAuthenticate(INetworkPlayer)​ Declaration​ public override void ServerAuthenticate(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\t ClientSetup(NetworkClient)​ Declaration​ public override void ClientSetup(NetworkClient client)  Parameters​ Type\tName\tDescriptionMirage.NetworkClient\tclient\t ClientAuthenticate(INetworkPlayer)​ Declaration​ public override void ClientAuthenticate(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\t "},{"title":"Class TimeoutAuthenticator","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Authenticators/TimeoutAuthenticator","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class TimeoutAuthenticator","url":"docs/reference/Mirage.Authenticators/TimeoutAuthenticator#fields","content":"Authenticator​ Declaration​ public NetworkAuthenticator Authenticator  Timeout​ Declaration​ public float Timeout  "},{"title":"Methods​","type":1,"pageTitle":"Class TimeoutAuthenticator","url":"docs/reference/Mirage.Authenticators/TimeoutAuthenticator#methods","content":"Awake()​ Declaration​ public void Awake()  ServerAuthenticate(INetworkPlayer)​ Declaration​ public override void ServerAuthenticate(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\t ClientAuthenticate(INetworkPlayer)​ Declaration​ public override void ClientAuthenticate(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\t ServerSetup(NetworkServer)​ Declaration​ public override void ServerSetup(NetworkServer server)  Parameters​ Type\tName\tDescriptionMirage.NetworkServer\tserver\t ClientSetup(NetworkClient)​ Declaration​ public override void ClientSetup(NetworkClient client)  Parameters​ Type\tName\tDescriptionMirage.NetworkClient\tclient\t "},{"title":"Sync Var","type":0,"sectionRef":"#","url":"docs/guides/sync/sync-var","content":"","keywords":""},{"title":"Example​","type":1,"pageTitle":"Sync Var","url":"docs/guides/sync/sync-var#example","content":"Let's have a simple Player class with the following code: using Mirage; using UnityEngine; public class Player : NetworkBehaviour { [SyncVar] public int clickCount; private void Update() { if (IsLocalPlayer &amp;&amp; Input.GetMouseButtonDown(0)) { ServerRpc_IncreaseClicks(); } } [ServerRpc] public void ServerRpc_IncreaseClicks() { // This is executed on the server clickCount++; } }  In this example, when Player A clicks the left mouse button, he sends a ServerRpc to the server where the clickCount SyncVar is incremented. All other visible players will be informed about Player A's new clickCount value. "},{"title":"Class inheritance​","type":1,"pageTitle":"Sync Var","url":"docs/guides/sync/sync-var#class-inheritance","content":"SyncVars work with class inheritance. Consider this example: private class Pet : NetworkBehaviour { [SyncVar] private string name; } private class Cat : Pet { [SyncVar] private Color32 color; }  You can attach the Cat component to your cat prefab, and it will synchronize both its name and color. caution Both Cat and Pet should be in the same assembly. If they are in separate assemblies, make sure not to change name from inside Cat directly, add a method to Pet instead. "},{"title":"SyncVar hook​","type":1,"pageTitle":"Sync Var","url":"docs/guides/sync/sync-var#syncvar-hook","content":"The hook property of SyncVar can be used to specify a function to be called when the SyncVar changes value on the client and server. Trivia: The hook callback must have two parameters of the same type as the SyncVar property. One for the old value, one for the new value.The hook is always called after the SyncVar value is set. You don't need to set it yourself.The hook only fires for changed values, and changing a value in the inspector will not trigger an update.Hooks can be virtual methods and overridden in a derived class. "},{"title":"Example Client Only​","type":1,"pageTitle":"Sync Var","url":"docs/guides/sync/sync-var#example-client-only","content":"Below is a simple example of assigning a random color to each player when they're spawned on the server. All clients will see all players in the correct colors, even if they join later. using UnityEngine; using Mirage; public class Player : NetworkBehaviour { [SyncVar(hook = nameof(UpdateColor))] private Color playerColor = Color.black; private Renderer renderer; // Unity makes a clone of the Material every time renderer.material is used. // Cache it here and Destroy it in OnDestroy to prevent a memory leak. private Material cachedMaterial; private void Awake() { renderer = GetComponent&lt;Renderer&gt;(); Identity.OnStartServer.AddListener(OnStartServer); } private void OnStartServer() { playerColor = Random.ColorHSV(0f, 1f, 1f, 1f, 0.5f, 1f); } private void UpdateColor(Color oldColor, Color newColor) { // this is executed on this player for each client if (cachedMaterial == null) { cachedMaterial = renderer.material; } cachedMaterial.color = newColor; } private void OnDestroy() { Destroy(cachedMaterial); } }  "},{"title":"Example Client & Server​","type":1,"pageTitle":"Sync Var","url":"docs/guides/sync/sync-var#example-client--server","content":"Below is a simple example of assigning a random color to each player when they're spawned on the server. All clients will see all players in the correct colors, even if they join later, the server will also fire the event. using UnityEngine; using Mirage; public class Player : NetworkBehaviour { [SyncVar(hook = nameof(UpdateColor), invokeHookOnServer = true)] private Color playerColor = Color.black; private Renderer renderer; // Unity makes a clone of the Material every time renderer.material is used. // Cache it here and Destroy it in OnDestroy to prevent a memory leak. private Material cachedMaterial; private void Awake() { renderer = GetComponent&lt;Renderer&gt;(); Identity.OnStartServer.AddListener(OnStartServer); } private void OnStartServer() { playerColor = Random.ColorHSV(0f, 1f, 1f, 1f, 0.5f, 1f); } private void UpdateColor(Color oldColor, Color newColor) { // this is executed on this player for each client if (cachedMaterial == null) { cachedMaterial = renderer.material; } cachedMaterial.color = newColor; } private void OnDestroy() { Destroy(cachedMaterial); } }  "},{"title":"SyncVar Initialize Only​","type":1,"pageTitle":"Sync Var","url":"docs/guides/sync/sync-var#syncvar-initialize-only","content":"Just like regular SyncVars, when a game object is spawned, or a new player joins a game in progress, they are sent the latest state of all SyncVars on networked objects that are visible to them. With the initialOnly flag set to true you will now be able to control the state of the SyncVar manually rather than waiting for Mirage to update them. note Make sure you manually update your observable clients with the new state. Syncvar Hooks become redundant, as you are setting the state of the Syncvar directly. "},{"title":"Example​","type":1,"pageTitle":"Sync Var","url":"docs/guides/sync/sync-var#example-1","content":"using Mirage; using UnityEngine; public class Player : NetworkBehaviour { [SyncVar(initialOnly = true)] private int weaponId; private void Awake() { Identity.OnStartClient.AddListener(OnStartClient); } private void OnStartClient() { // Update weapon using id from syncvar (sent to client via spawn message UpdateWeapon(weaponId); } private void Update() { if (Input.GetKeyDown(KeyCode.Q)) { // Client Request weapon change ServerRpc_SetSyncVarWeaponId(7); } } [ServerRpc] private void ServerRpc_SetSyncVarWeaponId(int weaponId) { // Set weapon id on server so new players get it this.weaponId = weaponId; // Tell current players about it ClientRpc_SetSyncVarWeaponId(weaponId); // Update weapon on server UpdateWeapon(weaponId); } [ClientRpc] private void ClientRpc_SetSyncVarWeaponId(int weaponId) { // Set id on client this.weaponId = weaponId; // Update weapon on client UpdateWeapon(weaponId); } public void UpdateWeapon(int weaponId) { // Do stuff to update weapon here // For example, its spawning model } }  "},{"title":"Mirage.Collections","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Collections/","content":"","keywords":""},{"title":"Classes​","type":1,"pageTitle":"Mirage.Collections","url":"docs/reference/Mirage.Collections/#classes","content":"SyncDictionary&lt;TKey, TValue&gt;​ SyncHashSet&lt;T&gt;​ SyncIDictionary&lt;TKey, TValue&gt;​ SyncList&lt;T&gt;​ SyncSet&lt;T&gt;​ SyncSortedSet&lt;T&gt;​ "},{"title":"Structs​","type":1,"pageTitle":"Mirage.Collections","url":"docs/reference/Mirage.Collections/#structs","content":"SyncList&lt;T&gt;.Enumerator​ "},{"title":"Interfaces​","type":1,"pageTitle":"Mirage.Collections","url":"docs/reference/Mirage.Collections/#interfaces","content":"ISyncObject​ A sync object is an object that can synchronize it's state between server and client, such as a SyncList "},{"title":"Interface ISyncObject","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Collections/ISyncObject","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Interface ISyncObject","url":"docs/reference/Mirage.Collections/ISyncObject#properties","content":"IsDirty​ true if there are changes since the last flush Declaration​ bool IsDirty { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Interface ISyncObject","url":"docs/reference/Mirage.Collections/ISyncObject#methods","content":"Flush()​ Discard all the queued changes Consider the object fully synchronized with clients Declaration​ void Flush()  OnSerializeAll(NetworkWriter)​ Write a full copy of the object Declaration​ void OnSerializeAll(NetworkWriter writer)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter\t OnSerializeDelta(NetworkWriter)​ Write the changes made to the object since last sync Declaration​ void OnSerializeDelta(NetworkWriter writer)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter\t OnDeserializeAll(NetworkReader)​ Reads a full copy of the object Declaration​ void OnDeserializeAll(NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t OnDeserializeDelta(NetworkReader)​ Reads the changes made to the object since last sync Declaration​ void OnDeserializeDelta(NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Reset()​ Resets the SyncObject so that it can be re-used Declaration​ void Reset()  "},{"title":"Class SyncHashSet<T>","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Collections/SyncHashSet-1","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class SyncHashSet<T>","url":"docs/reference/Mirage.Collections/SyncHashSet-1#constructors","content":"SyncHashSet()​ Declaration​ public SyncHashSet()  SyncHashSet(IEqualityComparer&lt;T&gt;)​ Declaration​ public SyncHashSet(IEqualityComparer&lt;T&gt; comparer)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IEqualityComparer&lt;T&gt;\tcomparer\t "},{"title":"Methods​","type":1,"pageTitle":"Class SyncHashSet<T>","url":"docs/reference/Mirage.Collections/SyncHashSet-1#methods","content":"GetEnumerator()​ Declaration​ public HashSet&lt;T&gt;.Enumerator GetEnumerator()  Returns​ Type\tDescriptionSystem.Collections.Generic.HashSet.Enumerator&lt;&gt;\t "},{"title":"Class SyncDictionary<TKey, TValue>","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Collections/SyncDictionary-2","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class SyncDictionary<TKey, TValue>","url":"docs/reference/Mirage.Collections/SyncDictionary-2#constructors","content":"SyncDictionary()​ Declaration​ public SyncDictionary()  SyncDictionary(IEqualityComparer&lt;TKey&gt;)​ Declaration​ public SyncDictionary(IEqualityComparer&lt;TKey&gt; eq)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IEqualityComparer&lt;TKey&gt;\teq\t "},{"title":"Properties​","type":1,"pageTitle":"Class SyncDictionary<TKey, TValue>","url":"docs/reference/Mirage.Collections/SyncDictionary-2#properties","content":"Values​ Declaration​ public Dictionary&lt;TKey, TValue&gt;.ValueCollection Values { get; }  Keys​ Declaration​ public Dictionary&lt;TKey, TValue&gt;.KeyCollection Keys { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class SyncDictionary<TKey, TValue>","url":"docs/reference/Mirage.Collections/SyncDictionary-2#methods","content":"GetEnumerator()​ Declaration​ public Dictionary&lt;TKey, TValue&gt;.Enumerator GetEnumerator()  Returns​ Type\tDescriptionSystem.Collections.Generic.Dictionary.Enumerator&lt;&gt;\t "},{"title":"Class SyncIDictionary<TKey, TValue>","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Collections/SyncIDictionary-2","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class SyncIDictionary<TKey, TValue>","url":"docs/reference/Mirage.Collections/SyncIDictionary-2#constructors","content":"SyncIDictionary(IDictionary&lt;TKey, TValue&gt;)​ Declaration​ public SyncIDictionary(IDictionary&lt;TKey, TValue&gt; objects)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IDictionary&lt;TKey, TValue&gt;\tobjects\t "},{"title":"Fields​","type":1,"pageTitle":"Class SyncIDictionary<TKey, TValue>","url":"docs/reference/Mirage.Collections/SyncIDictionary-2#fields","content":"objects​ Declaration​ protected readonly IDictionary&lt;TKey, TValue&gt; objects  "},{"title":"Properties​","type":1,"pageTitle":"Class SyncIDictionary<TKey, TValue>","url":"docs/reference/Mirage.Collections/SyncIDictionary-2#properties","content":"Count​ Declaration​ public int Count { get; }  IsReadOnly​ Declaration​ public bool IsReadOnly { get; }  IsDirty​ Declaration​ public bool IsDirty { get; }  Keys​ Declaration​ public ICollection&lt;TKey&gt; Keys { get; }  Values​ Declaration​ public ICollection&lt;TValue&gt; Values { get; }  IReadOnlyDictionary&lt;TKey, TValue&gt;.Keys​ Declaration​ IEnumerable&lt;TKey&gt; IReadOnlyDictionary&lt;TKey, TValue&gt;.Keys { get; }  IReadOnlyDictionary&lt;TKey, TValue&gt;.Values​ Declaration​ IEnumerable&lt;TValue&gt; IReadOnlyDictionary&lt;TKey, TValue&gt;.Values { get; }  Item[TKey]​ Declaration​ public TValue this[TKey i] { get; set; }  "},{"title":"Methods​","type":1,"pageTitle":"Class SyncIDictionary<TKey, TValue>","url":"docs/reference/Mirage.Collections/SyncIDictionary-2#methods","content":"Reset()​ Declaration​ public void Reset()  Flush()​ Declaration​ public void Flush()  OnSerializeAll(NetworkWriter)​ Declaration​ public void OnSerializeAll(NetworkWriter writer)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter\t OnSerializeDelta(NetworkWriter)​ Declaration​ public void OnSerializeDelta(NetworkWriter writer)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter\t OnDeserializeAll(NetworkReader)​ Declaration​ public void OnDeserializeAll(NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t OnDeserializeDelta(NetworkReader)​ Declaration​ public void OnDeserializeDelta(NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Clear()​ Declaration​ public void Clear()  ContainsKey(TKey)​ Declaration​ public bool ContainsKey(TKey key)  Parameters​ Type\tName\tDescriptionTKey\tkey\t Returns​ Type\tDescriptionSystem.Boolean\t Remove(TKey)​ Declaration​ public bool Remove(TKey key)  Parameters​ Type\tName\tDescriptionTKey\tkey\t Returns​ Type\tDescriptionSystem.Boolean\t TryGetValue(TKey, out TValue)​ Declaration​ public bool TryGetValue(TKey key, out TValue value)  Parameters​ Type\tName\tDescriptionTKey\tkey TValue\tvalue\t Returns​ Type\tDescriptionSystem.Boolean\t Add(TKey, TValue)​ Declaration​ public void Add(TKey key, TValue value)  Parameters​ Type\tName\tDescriptionTKey\tkey TValue\tvalue\t Add(KeyValuePair&lt;TKey, TValue&gt;)​ Declaration​ public void Add(KeyValuePair&lt;TKey, TValue&gt; item)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;\titem\t Contains(KeyValuePair&lt;TKey, TValue&gt;)​ Declaration​ public bool Contains(KeyValuePair&lt;TKey, TValue&gt; item)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;\titem\t Returns​ Type\tDescriptionSystem.Boolean\t CopyTo(KeyValuePair&lt;TKey, TValue&gt;[], Int32)​ Declaration​ public void CopyTo(KeyValuePair&lt;TKey, TValue&gt;[] array, int arrayIndex)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.KeyValuePair{{TKey},{TValue}}[]\tarray System.Int32\tarrayIndex\t Remove(KeyValuePair&lt;TKey, TValue&gt;)​ Declaration​ public bool Remove(KeyValuePair&lt;TKey, TValue&gt; item)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;\titem\t Returns​ Type\tDescriptionSystem.Boolean\t GetEnumerator()​ Declaration​ public IEnumerator&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; GetEnumerator()  Returns​ Type\tDescriptionSystem.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;&gt;\t IEnumerable.GetEnumerator()​ Declaration​ IEnumerator IEnumerable.GetEnumerator()  Returns​ Type\tDescriptionSystem.Collections.IEnumerator\t "},{"title":"Class SyncList<T>","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Collections/SyncList-1","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class SyncList<T>","url":"docs/reference/Mirage.Collections/SyncList-1#constructors","content":"SyncList()​ Declaration​ public SyncList()  SyncList(IEqualityComparer&lt;T&gt;)​ Declaration​ public SyncList(IEqualityComparer&lt;T&gt; comparer)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IEqualityComparer&lt;T&gt;\tcomparer\t SyncList(IList&lt;T&gt;, IEqualityComparer&lt;T&gt;)​ Declaration​ public SyncList(IList&lt;T&gt; objects, IEqualityComparer&lt;T&gt; comparer = null)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IList&lt;T&gt;\tobjects System.Collections.Generic.IEqualityComparer&lt;T&gt;\tcomparer\t "},{"title":"Properties​","type":1,"pageTitle":"Class SyncList<T>","url":"docs/reference/Mirage.Collections/SyncList-1#properties","content":"Count​ Declaration​ public int Count { get; }  IsReadOnly​ Declaration​ public bool IsReadOnly { get; }  IsDirty​ Declaration​ public bool IsDirty { get; }  Item[Int32]​ Declaration​ public T this[int i] { get; set; }  "},{"title":"Methods​","type":1,"pageTitle":"Class SyncList<T>","url":"docs/reference/Mirage.Collections/SyncList-1#methods","content":"Flush()​ Declaration​ public void Flush()  Reset()​ Declaration​ public void Reset()  OnSerializeAll(NetworkWriter)​ Declaration​ public void OnSerializeAll(NetworkWriter writer)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter\t OnSerializeDelta(NetworkWriter)​ Declaration​ public void OnSerializeDelta(NetworkWriter writer)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter\t OnDeserializeAll(NetworkReader)​ Declaration​ public void OnDeserializeAll(NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t OnDeserializeDelta(NetworkReader)​ Declaration​ public void OnDeserializeDelta(NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Add(T)​ Declaration​ public void Add(T item)  Parameters​ Type\tName\tDescriptionT\titem\t AddRange(IEnumerable&lt;T&gt;)​ Declaration​ public void AddRange(IEnumerable&lt;T&gt; range)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IEnumerable&lt;T&gt;\trange\t Clear()​ Declaration​ public void Clear()  Contains(T)​ Declaration​ public bool Contains(T item)  Parameters​ Type\tName\tDescriptionT\titem\t Returns​ Type\tDescriptionSystem.Boolean\t CopyTo(T[], Int32)​ Declaration​ public void CopyTo(T[] array, int arrayIndex)  Parameters​ Type\tName\tDescription{T}[]\tarray System.Int32\tarrayIndex\t IndexOf(T)​ Declaration​ public int IndexOf(T item)  Parameters​ Type\tName\tDescriptionT\titem\t Returns​ Type\tDescriptionSystem.Int32\t FindIndex(Predicate&lt;T&gt;)​ Declaration​ public int FindIndex(Predicate&lt;T&gt; match)  Parameters​ Type\tName\tDescriptionSystem.Predicate&lt;T&gt;\tmatch\t Returns​ Type\tDescriptionSystem.Int32\t Find(Predicate&lt;T&gt;)​ Declaration​ public T Find(Predicate&lt;T&gt; match)  Parameters​ Type\tName\tDescriptionSystem.Predicate&lt;T&gt;\tmatch\t Returns​ Type\tDescriptionT\t FindAll(Predicate&lt;T&gt;)​ Declaration​ public List&lt;T&gt; FindAll(Predicate&lt;T&gt; match)  Parameters​ Type\tName\tDescriptionSystem.Predicate&lt;T&gt;\tmatch\t Returns​ Type\tDescriptionSystem.Collections.Generic.List&lt;T&gt;\t Insert(Int32, T)​ Declaration​ public void Insert(int index, T item)  Parameters​ Type\tName\tDescriptionSystem.Int32\tindex T\titem\t InsertRange(Int32, IEnumerable&lt;T&gt;)​ Declaration​ public void InsertRange(int index, IEnumerable&lt;T&gt; range)  Parameters​ Type\tName\tDescriptionSystem.Int32\tindex System.Collections.Generic.IEnumerable&lt;T&gt;\trange\t Remove(T)​ Declaration​ public bool Remove(T item)  Parameters​ Type\tName\tDescriptionT\titem\t Returns​ Type\tDescriptionSystem.Boolean\t RemoveAt(Int32)​ Declaration​ public void RemoveAt(int index)  Parameters​ Type\tName\tDescriptionSystem.Int32\tindex\t RemoveAll(Predicate&lt;T&gt;)​ Declaration​ public int RemoveAll(Predicate&lt;T&gt; match)  Parameters​ Type\tName\tDescriptionSystem.Predicate&lt;T&gt;\tmatch\t Returns​ Type\tDescriptionSystem.Int32\t GetEnumerator()​ Declaration​ public SyncList&lt;T&gt;.Enumerator GetEnumerator()  Returns​ Type\tDescriptionMirage.Collections.SyncList.Enumerator&lt;&gt;\t IEnumerable&lt;T&gt;.GetEnumerator()​ Declaration​ IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator()  Returns​ Type\tDescriptionSystem.Collections.Generic.IEnumerator&lt;T&gt;\t IEnumerable.GetEnumerator()​ Declaration​ IEnumerator IEnumerable.GetEnumerator()  Returns​ Type\tDescriptionSystem.Collections.IEnumerator\t "},{"title":"Struct SyncList<T>.Enumerator","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Collections/SyncList-1.Enumerator","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Struct SyncList<T>.Enumerator","url":"docs/reference/Mirage.Collections/SyncList-1.Enumerator#constructors","content":"Enumerator(SyncList&lt;T&gt;)​ Declaration​ public Enumerator(SyncList&lt;T&gt; list)  Parameters​ Type\tName\tDescriptionMirage.Collections.SyncList&lt;T&gt;\tlist\t "},{"title":"Properties​","type":1,"pageTitle":"Struct SyncList<T>.Enumerator","url":"docs/reference/Mirage.Collections/SyncList-1.Enumerator#properties","content":"Current​ Declaration​ public T Current { get; }  IEnumerator.Current​ Declaration​ object IEnumerator.Current { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Struct SyncList<T>.Enumerator","url":"docs/reference/Mirage.Collections/SyncList-1.Enumerator#methods","content":"MoveNext()​ Declaration​ public bool MoveNext()  Returns​ Type\tDescriptionSystem.Boolean\t Reset()​ Declaration​ public void Reset()  Dispose()​ Declaration​ public void Dispose()  "},{"title":"Class SyncSortedSet<T>","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Collections/SyncSortedSet-1","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class SyncSortedSet<T>","url":"docs/reference/Mirage.Collections/SyncSortedSet-1#constructors","content":"SyncSortedSet()​ Declaration​ public SyncSortedSet()  SyncSortedSet(IComparer&lt;T&gt;)​ Declaration​ public SyncSortedSet(IComparer&lt;T&gt; comparer)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IComparer&lt;T&gt;\tcomparer\t "},{"title":"Methods​","type":1,"pageTitle":"Class SyncSortedSet<T>","url":"docs/reference/Mirage.Collections/SyncSortedSet-1#methods","content":"GetEnumerator()​ Declaration​ public SortedSet&lt;T&gt;.Enumerator GetEnumerator()  Returns​ Type\tDescriptionSystem.Collections.Generic.SortedSet.Enumerator&lt;&gt;\t "},{"title":"Mirage.DisplayMetrics","type":0,"sectionRef":"#","url":"docs/reference/Mirage.DisplayMetrics/","content":"","keywords":""},{"title":"Classes​","type":1,"pageTitle":"Mirage.DisplayMetrics","url":"docs/reference/Mirage.DisplayMetrics/#classes","content":"DisplayMetricsAverageGui​ This is an example of how to show metrics, It only shows some of the values inside If you want to show more of the values then create a copy of this class and add values to DrawAverage RequestServerMetrics​ SetDisplayMetrics​ "},{"title":"Class SyncSet<T>","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Collections/SyncSet-1","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class SyncSet<T>","url":"docs/reference/Mirage.Collections/SyncSet-1#constructors","content":"SyncSet(ISet&lt;T&gt;)​ Declaration​ public SyncSet(ISet&lt;T&gt; objects)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.ISet&lt;T&gt;\tobjects\t "},{"title":"Fields​","type":1,"pageTitle":"Class SyncSet<T>","url":"docs/reference/Mirage.Collections/SyncSet-1#fields","content":"objects​ Declaration​ protected readonly ISet&lt;T&gt; objects  "},{"title":"Properties​","type":1,"pageTitle":"Class SyncSet<T>","url":"docs/reference/Mirage.Collections/SyncSet-1#properties","content":"Count​ Declaration​ public int Count { get; }  IsReadOnly​ Declaration​ public bool IsReadOnly { get; }  IsDirty​ Declaration​ public bool IsDirty { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class SyncSet<T>","url":"docs/reference/Mirage.Collections/SyncSet-1#methods","content":"Reset()​ Declaration​ public void Reset()  Flush()​ Declaration​ public void Flush()  OnSerializeAll(NetworkWriter)​ Declaration​ public void OnSerializeAll(NetworkWriter writer)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter\t OnSerializeDelta(NetworkWriter)​ Declaration​ public void OnSerializeDelta(NetworkWriter writer)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter\t OnDeserializeAll(NetworkReader)​ Declaration​ public void OnDeserializeAll(NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t OnDeserializeDelta(NetworkReader)​ Declaration​ public void OnDeserializeDelta(NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Add(T)​ Declaration​ public bool Add(T item)  Parameters​ Type\tName\tDescriptionT\titem\t Returns​ Type\tDescriptionSystem.Boolean\t ICollection&lt;T&gt;.Add(T)​ Declaration​ void ICollection&lt;T&gt;.Add(T item)  Parameters​ Type\tName\tDescriptionT\titem\t Clear()​ Declaration​ public void Clear()  Contains(T)​ Declaration​ public bool Contains(T item)  Parameters​ Type\tName\tDescriptionT\titem\t Returns​ Type\tDescriptionSystem.Boolean\t CopyTo(T[], Int32)​ Declaration​ public void CopyTo(T[] array, int arrayIndex)  Parameters​ Type\tName\tDescription{T}[]\tarray System.Int32\tarrayIndex\t Remove(T)​ Declaration​ public bool Remove(T item)  Parameters​ Type\tName\tDescriptionT\titem\t Returns​ Type\tDescriptionSystem.Boolean\t GetEnumerator()​ Declaration​ public IEnumerator&lt;T&gt; GetEnumerator()  Returns​ Type\tDescriptionSystem.Collections.Generic.IEnumerator&lt;T&gt;\t IEnumerable.GetEnumerator()​ Declaration​ IEnumerator IEnumerable.GetEnumerator()  Returns​ Type\tDescriptionSystem.Collections.IEnumerator\t ExceptWith(IEnumerable&lt;T&gt;)​ Declaration​ public void ExceptWith(IEnumerable&lt;T&gt; other)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IEnumerable&lt;T&gt;\tother\t IntersectWith(IEnumerable&lt;T&gt;)​ Declaration​ public void IntersectWith(IEnumerable&lt;T&gt; other)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IEnumerable&lt;T&gt;\tother\t IsProperSubsetOf(IEnumerable&lt;T&gt;)​ Declaration​ public bool IsProperSubsetOf(IEnumerable&lt;T&gt; other)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IEnumerable&lt;T&gt;\tother\t Returns​ Type\tDescriptionSystem.Boolean\t IsProperSupersetOf(IEnumerable&lt;T&gt;)​ Declaration​ public bool IsProperSupersetOf(IEnumerable&lt;T&gt; other)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IEnumerable&lt;T&gt;\tother\t Returns​ Type\tDescriptionSystem.Boolean\t IsSubsetOf(IEnumerable&lt;T&gt;)​ Declaration​ public bool IsSubsetOf(IEnumerable&lt;T&gt; other)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IEnumerable&lt;T&gt;\tother\t Returns​ Type\tDescriptionSystem.Boolean\t IsSupersetOf(IEnumerable&lt;T&gt;)​ Declaration​ public bool IsSupersetOf(IEnumerable&lt;T&gt; other)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IEnumerable&lt;T&gt;\tother\t Returns​ Type\tDescriptionSystem.Boolean\t Overlaps(IEnumerable&lt;T&gt;)​ Declaration​ public bool Overlaps(IEnumerable&lt;T&gt; other)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IEnumerable&lt;T&gt;\tother\t Returns​ Type\tDescriptionSystem.Boolean\t SetEquals(IEnumerable&lt;T&gt;)​ Declaration​ public bool SetEquals(IEnumerable&lt;T&gt; other)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IEnumerable&lt;T&gt;\tother\t Returns​ Type\tDescriptionSystem.Boolean\t SymmetricExceptWith(IEnumerable&lt;T&gt;)​ Declaration​ public void SymmetricExceptWith(IEnumerable&lt;T&gt; other)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IEnumerable&lt;T&gt;\tother\t UnionWith(IEnumerable&lt;T&gt;)​ Declaration​ public void UnionWith(IEnumerable&lt;T&gt; other)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IEnumerable&lt;T&gt;\tother\t "},{"title":"Class DisplayMetricsAverageGui","type":0,"sectionRef":"#","url":"docs/reference/Mirage.DisplayMetrics/DisplayMetricsAverageGui","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class DisplayMetricsAverageGui","url":"docs/reference/Mirage.DisplayMetrics/DisplayMetricsAverageGui#fields","content":"offset​ Declaration​ public Rect offset  background​ Declaration​ public Color background  "},{"title":"Properties​","type":1,"pageTitle":"Class DisplayMetricsAverageGui","url":"docs/reference/Mirage.DisplayMetrics/DisplayMetricsAverageGui#properties","content":"Metrics​ Declaration​ public Metrics Metrics { get; set; }  "},{"title":"Class RequestServerMetrics","type":0,"sectionRef":"#","url":"docs/reference/Mirage.DisplayMetrics/RequestServerMetrics","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class RequestServerMetrics","url":"docs/reference/Mirage.DisplayMetrics/RequestServerMetrics#fields","content":"server​ Declaration​ public NetworkServer server  client​ Declaration​ public NetworkClient client  displayMetrics​ Declaration​ public DisplayMetricsAverageGui displayMetrics  RequestMetrics​ Declaration​ public bool RequestMetrics  "},{"title":"Methods​","type":1,"pageTitle":"Class RequestServerMetrics","url":"docs/reference/Mirage.DisplayMetrics/RequestServerMetrics#methods","content":"Runner()​ Declaration​ public IEnumerator Runner()  Returns​ Type\tDescriptionSystem.Collections.IEnumerator\t "},{"title":"Class SetDisplayMetrics","type":0,"sectionRef":"#","url":"docs/reference/Mirage.DisplayMetrics/SetDisplayMetrics","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class SetDisplayMetrics","url":"docs/reference/Mirage.DisplayMetrics/SetDisplayMetrics#fields","content":"server​ Declaration​ public NetworkServer server  client​ Declaration​ public NetworkClient client  displayMetrics​ Declaration​ public DisplayMetricsAverageGui displayMetrics  "},{"title":"Mirage.Events","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Events/","content":"","keywords":""},{"title":"Classes​","type":1,"pageTitle":"Mirage.Events","url":"docs/reference/Mirage.Events/#classes","content":"AddLateEvent​ An event that will invoke handlers immediately if they are added after has been called AddLateEvent&lt;T0, T1, TEvent&gt;​ Version of with 2 arguments Create a non-generic class inheriting from this to use in inspector. Same rules as AddLateEvent&lt;T0, TEvent&gt;​ Version of with 1 argument Create a non-generic class inheriting from this to use in inspector. Same rules as AddLateEventBase​ BoolAddLateEvent​ BoolUnityEvent​ DisconnectAddLateEvent​ Event fires from a when it fails to connect to the server DisconnectEvent​ NetworkPlayerAddLateEvent​ Event fires from a or during a new connection, a new authentication, or a disconnection. NetworkPlayerEvent​ "},{"title":"Interfaces​","type":1,"pageTitle":"Mirage.Events","url":"docs/reference/Mirage.Events/#interfaces","content":"IAddLateEvent​ Event that can only run once, adding handler late will it invoke right away IAddLateEvent&lt;T0, T1&gt;​ Version of with 2 arguments IAddLateEvent&lt;T0&gt;​ Version of with 1 argument "},{"title":"Class AddLateEvent","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Events/AddLateEvent","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Class AddLateEvent","url":"docs/reference/Mirage.Events/AddLateEvent#properties","content":"baseEvent​ Declaration​ protected override UnityEventBase baseEvent { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class AddLateEvent","url":"docs/reference/Mirage.Events/AddLateEvent#methods","content":"AddListener(UnityAction)​ Declaration​ public void AddListener(UnityAction handler)  Parameters​ Type\tName\tDescriptionUnityAction\thandler\t RemoveListener(UnityAction)​ Declaration​ public void RemoveListener(UnityAction handler)  Parameters​ Type\tName\tDescriptionUnityAction\thandler\t Invoke()​ Declaration​ public void Invoke()  "},{"title":"Class AddLateEvent<T0, TEvent>","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Events/AddLateEvent-2","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Class AddLateEvent<T0, TEvent>","url":"docs/reference/Mirage.Events/AddLateEvent-2#properties","content":"baseEvent​ Declaration​ protected override UnityEventBase baseEvent { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class AddLateEvent<T0, TEvent>","url":"docs/reference/Mirage.Events/AddLateEvent-2#methods","content":"AddListener(UnityAction&lt;T0&gt;)​ Declaration​ public void AddListener(UnityAction&lt;T0&gt; handler)  Parameters​ Type\tName\tDescriptionUnityAction&lt;T0&gt;\thandler\t RemoveListener(UnityAction&lt;T0&gt;)​ Declaration​ public void RemoveListener(UnityAction&lt;T0&gt; handler)  Parameters​ Type\tName\tDescriptionUnityAction&lt;T0&gt;\thandler\t Invoke(T0)​ Declaration​ public void Invoke(T0 arg0)  Parameters​ Type\tName\tDescriptionT0\targ0\t "},{"title":"Class AddLateEvent<T0, T1, TEvent>","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Events/AddLateEvent-3","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Class AddLateEvent<T0, T1, TEvent>","url":"docs/reference/Mirage.Events/AddLateEvent-3#properties","content":"baseEvent​ Declaration​ protected override UnityEventBase baseEvent { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class AddLateEvent<T0, T1, TEvent>","url":"docs/reference/Mirage.Events/AddLateEvent-3#methods","content":"AddListener(UnityAction&lt;T0, T1&gt;)​ Declaration​ public void AddListener(UnityAction&lt;T0, T1&gt; handler)  Parameters​ Type\tName\tDescriptionUnityAction&lt;T0, T1&gt;\thandler\t RemoveListener(UnityAction&lt;T0, T1&gt;)​ Declaration​ public void RemoveListener(UnityAction&lt;T0, T1&gt; handler)  Parameters​ Type\tName\tDescriptionUnityAction&lt;T0, T1&gt;\thandler\t Invoke(T0, T1)​ Declaration​ public void Invoke(T0 arg0, T1 arg1)  Parameters​ Type\tName\tDescriptionT0\targ0 T1\targ1\t "},{"title":"Class BoolAddLateEvent","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Events/BoolAddLateEvent","content":"Class BoolAddLateEvent Inheritance​ System.Object Mirage.Events.AddLateEventBase Mirage.Events.AddLateEvent&lt;System.Boolean, Mirage.Events.BoolUnityEvent&gt; Inherited Members​ Show Mirage.Events.AddLateEvent&lt;System.Boolean, Mirage.Events.BoolUnityEvent&gt;.baseEvent Mirage.Events.AddLateEvent&lt;System.Boolean, Mirage.Events.BoolUnityEvent&gt;.AddListener(UnityAction&lt;System.Boolean&gt;) Mirage.Events.AddLateEvent&lt;System.Boolean, Mirage.Events.BoolUnityEvent&gt;.RemoveListener(UnityAction&lt;System.Boolean&gt;) Mirage.Events.AddLateEvent&lt;System.Boolean, Mirage.Events.BoolUnityEvent&gt;.Invoke(System.Boolean) Mirage.Events.AddLateEventBase.baseEvent Mirage.Events.AddLateEventBase.hasInvoked Mirage.Events.AddLateEventBase.MarkInvoked() Mirage.Events.AddLateEventBase.Reset() Mirage.Events.AddLateEventBase.RemoveAllListeners() Syntax​ [Serializable] public class BoolAddLateEvent : AddLateEvent&lt;bool, BoolUnityEvent&gt;, IAddLateEvent&lt;bool&gt; ","keywords":""},{"title":"Class AddLateEventBase","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Events/AddLateEventBase","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Class AddLateEventBase","url":"docs/reference/Mirage.Events/AddLateEventBase#properties","content":"baseEvent​ Declaration​ protected abstract UnityEventBase baseEvent { get; }  hasInvoked​ Declaration​ protected bool hasInvoked { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class AddLateEventBase","url":"docs/reference/Mirage.Events/AddLateEventBase#methods","content":"MarkInvoked()​ Declaration​ protected void MarkInvoked()  Reset()​ Resets invoked flag, meaning new handles wont be invoked untill invoke is called again Reset does not remove listeners Declaration​ public void Reset()  RemoveAllListeners()​ Remove all non-persisent (ie created from script) listeners from the event. Declaration​ public void RemoveAllListeners()  "},{"title":"Class BoolUnityEvent","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Events/BoolUnityEvent","content":"Class BoolUnityEvent Inheritance​ System.Object Syntax​ [Serializable] public class BoolUnityEvent : UnityEvent&lt;bool&gt; ","keywords":""},{"title":"Class DisconnectAddLateEvent","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Events/DisconnectAddLateEvent","content":"Class DisconnectAddLateEvent Event fires from a when it fails to connect to the server Inheritance​ System.Object Mirage.Events.AddLateEventBase Mirage.Events.AddLateEvent&lt;Mirage.ClientStoppedReason, Mirage.Events.DisconnectEvent&gt; Inherited Members​ Show Mirage.Events.AddLateEvent&lt;Mirage.ClientStoppedReason, Mirage.Events.DisconnectEvent&gt;.baseEvent Mirage.Events.AddLateEvent&lt;Mirage.ClientStoppedReason, Mirage.Events.DisconnectEvent&gt;.AddListener(UnityAction&lt;Mirage.ClientStoppedReason&gt;) Mirage.Events.AddLateEvent&lt;Mirage.ClientStoppedReason, Mirage.Events.DisconnectEvent&gt;.RemoveListener(UnityAction&lt;Mirage.ClientStoppedReason&gt;) Mirage.Events.AddLateEvent&lt;Mirage.ClientStoppedReason, Mirage.Events.DisconnectEvent&gt;.Invoke(Mirage.ClientStoppedReason) Mirage.Events.AddLateEventBase.baseEvent Mirage.Events.AddLateEventBase.hasInvoked Mirage.Events.AddLateEventBase.MarkInvoked() Mirage.Events.AddLateEventBase.Reset() Mirage.Events.AddLateEventBase.RemoveAllListeners() Syntax​ [Serializable] public class DisconnectAddLateEvent : AddLateEvent&lt;ClientStoppedReason, DisconnectEvent&gt;, IAddLateEvent&lt;ClientStoppedReason&gt; ","keywords":""},{"title":"Class DisconnectEvent","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Events/DisconnectEvent","content":"Class DisconnectEvent Inheritance​ System.Object Syntax​ [Serializable] public class DisconnectEvent : UnityEvent&lt;ClientStoppedReason&gt; ","keywords":""},{"title":"Interface IAddLateEvent","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Events/IAddLateEvent","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Interface IAddLateEvent","url":"docs/reference/Mirage.Events/IAddLateEvent#methods","content":"AddListener(UnityAction)​ Declaration​ void AddListener(UnityAction handler)  Parameters​ Type\tName\tDescriptionUnityAction\thandler\t RemoveListener(UnityAction)​ Declaration​ void RemoveListener(UnityAction handler)  Parameters​ Type\tName\tDescriptionUnityAction\thandler\t "},{"title":"Interface IAddLateEvent<T0>","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Events/IAddLateEvent-1","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Interface IAddLateEvent<T0>","url":"docs/reference/Mirage.Events/IAddLateEvent-1#methods","content":"AddListener(UnityAction&lt;T0&gt;)​ Declaration​ void AddListener(UnityAction&lt;T0&gt; handler)  Parameters​ Type\tName\tDescriptionUnityAction&lt;T0&gt;\thandler\t RemoveListener(UnityAction&lt;T0&gt;)​ Declaration​ void RemoveListener(UnityAction&lt;T0&gt; handler)  Parameters​ Type\tName\tDescriptionUnityAction&lt;T0&gt;\thandler\t "},{"title":"Interface IAddLateEvent<T0, T1>","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Events/IAddLateEvent-2","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Interface IAddLateEvent<T0, T1>","url":"docs/reference/Mirage.Events/IAddLateEvent-2#methods","content":"AddListener(UnityAction&lt;T0, T1&gt;)​ Declaration​ void AddListener(UnityAction&lt;T0, T1&gt; handler)  Parameters​ Type\tName\tDescriptionUnityAction&lt;T0, T1&gt;\thandler\t RemoveListener(UnityAction&lt;T0, T1&gt;)​ Declaration​ void RemoveListener(UnityAction&lt;T0, T1&gt; handler)  Parameters​ Type\tName\tDescriptionUnityAction&lt;T0, T1&gt;\thandler\t "},{"title":"Class NetworkPlayerAddLateEvent","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Events/NetworkPlayerAddLateEvent","content":"Class NetworkPlayerAddLateEvent Event fires from a or during a new connection, a new authentication, or a disconnection. Inheritance​ System.Object Mirage.Events.AddLateEventBase Mirage.Events.AddLateEvent&lt;Mirage.INetworkPlayer, Mirage.Events.NetworkPlayerEvent&gt; Inherited Members​ Show Mirage.Events.AddLateEvent&lt;Mirage.INetworkPlayer, Mirage.Events.NetworkPlayerEvent&gt;.baseEvent Mirage.Events.AddLateEvent&lt;Mirage.INetworkPlayer, Mirage.Events.NetworkPlayerEvent&gt;.AddListener(UnityAction&lt;Mirage.INetworkPlayer&gt;) Mirage.Events.AddLateEvent&lt;Mirage.INetworkPlayer, Mirage.Events.NetworkPlayerEvent&gt;.RemoveListener(UnityAction&lt;Mirage.INetworkPlayer&gt;) Mirage.Events.AddLateEvent&lt;Mirage.INetworkPlayer, Mirage.Events.NetworkPlayerEvent&gt;.Invoke(Mirage.INetworkPlayer) Mirage.Events.AddLateEventBase.baseEvent Mirage.Events.AddLateEventBase.hasInvoked Mirage.Events.AddLateEventBase.MarkInvoked() Mirage.Events.AddLateEventBase.Reset() Mirage.Events.AddLateEventBase.RemoveAllListeners() Syntax​ [Serializable] public class NetworkPlayerAddLateEvent : AddLateEvent&lt;INetworkPlayer, NetworkPlayerEvent&gt;, IAddLateEvent&lt;INetworkPlayer&gt; ","keywords":""},{"title":"Class NetworkPlayerEvent","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Events/NetworkPlayerEvent","content":"Class NetworkPlayerEvent Inheritance​ System.Object Syntax​ [Serializable] public class NetworkPlayerEvent : UnityEvent&lt;INetworkPlayer&gt; ","keywords":""},{"title":"Mirage.Experimental","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Experimental/","content":"","keywords":""},{"title":"Classes​","type":1,"pageTitle":"Mirage.Experimental","url":"docs/reference/Mirage.Experimental/#classes","content":"NetworkLerpRigidbody​ NetworkRigidbody​ NetworkRigidbody.ClientSyncState​ holds previously synced values NetworkTransform​ NetworkTransformBase​ NetworkTransformChild​ A component to synchronize the position of child transforms of networked objects. There must be a NetworkTransform on the root object of the hierarchy. There can be multiple NetworkTransformChild components on an object. This does not use physics for synchronization, it simply synchronizes the localPosition and localRotation of the child transform and lerps towards the received values. "},{"title":"Structs​","type":1,"pageTitle":"Mirage.Experimental","url":"docs/reference/Mirage.Experimental/#structs","content":"NetworkTransformBase.DataPoint​ "},{"title":"Class NetworkLerpRigidbody","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Experimental/NetworkLerpRigidbody","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkLerpRigidbody","url":"docs/reference/Mirage.Experimental/NetworkLerpRigidbody#fields","content":"lerpVelocityAmount​ Declaration​ public float lerpVelocityAmount  lerpPositionAmount​ Declaration​ public float lerpPositionAmount  clientAuthority​ Declaration​ public bool clientAuthority  "},{"title":"Class NetworkRigidbody.ClientSyncState","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Experimental/NetworkRigidbody.ClientSyncState","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkRigidbody.ClientSyncState","url":"docs/reference/Mirage.Experimental/NetworkRigidbody.ClientSyncState#fields","content":"nextSyncTime​ Next sync time that velocity will be synced, based on syncInterval. Declaration​ public float nextSyncTime  velocity​ Declaration​ public Vector3 velocity  angularVelocity​ Declaration​ public Vector3 angularVelocity  isKinematic​ Declaration​ public bool isKinematic  useGravity​ Declaration​ public bool useGravity  drag​ Declaration​ public float drag  angularDrag​ Declaration​ public float angularDrag  "},{"title":"Class NetworkRigidbody","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Experimental/NetworkRigidbody","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkRigidbody","url":"docs/reference/Mirage.Experimental/NetworkRigidbody#fields","content":"target​ Declaration​ public Rigidbody target  clientAuthority​ Declaration​ public bool clientAuthority  syncVelocity​ Declaration​ public bool syncVelocity  clearVelocity​ Declaration​ public bool clearVelocity  velocitySensitivity​ Declaration​ public float velocitySensitivity  syncAngularVelocity​ Declaration​ public bool syncAngularVelocity  clearAngularVelocity​ Declaration​ public bool clearAngularVelocity  angularVelocitySensitivity​ Declaration​ public float angularVelocitySensitivity  "},{"title":"Class NetworkTransform","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Experimental/NetworkTransform","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Class NetworkTransform","url":"docs/reference/Mirage.Experimental/NetworkTransform#properties","content":"TargetTransform​ Declaration​ protected override Transform TargetTransform { get; }  "},{"title":"Struct NetworkTransformBase.DataPoint","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Experimental/NetworkTransformBase.DataPoint","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Struct NetworkTransformBase.DataPoint","url":"docs/reference/Mirage.Experimental/NetworkTransformBase.DataPoint#fields","content":"timeStamp​ Declaration​ public float timeStamp  localPosition​ Declaration​ public Vector3 localPosition  localRotation​ Declaration​ public Quaternion localRotation  localScale​ Declaration​ public Vector3 localScale  movementSpeed​ Declaration​ public float movementSpeed  "},{"title":"Properties​","type":1,"pageTitle":"Struct NetworkTransformBase.DataPoint","url":"docs/reference/Mirage.Experimental/NetworkTransformBase.DataPoint#properties","content":"IsValid​ Declaration​ public bool IsValid { get; }  "},{"title":"Class NetworkTransformBase","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Experimental/NetworkTransformBase","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkTransformBase","url":"docs/reference/Mirage.Experimental/NetworkTransformBase#fields","content":"clientAuthority​ Declaration​ public bool clientAuthority  excludeOwnerUpdate​ Declaration​ public bool excludeOwnerUpdate  syncPosition​ Declaration​ public bool syncPosition  syncRotation​ Declaration​ public bool syncRotation  syncScale​ Declaration​ public bool syncScale  interpolatePosition​ Declaration​ public bool interpolatePosition  interpolateRotation​ Declaration​ public bool interpolateRotation  interpolateScale​ Declaration​ public bool interpolateScale  localPositionSensitivity​ Declaration​ public float localPositionSensitivity  localRotationSensitivity​ Declaration​ public float localRotationSensitivity  localScaleSensitivity​ Declaration​ public float localScaleSensitivity  lastPosition​ Declaration​ public Vector3 lastPosition  lastRotation​ Declaration​ public Quaternion lastRotation  lastScale​ Declaration​ public Vector3 lastScale  start​ Declaration​ public NetworkTransformBase.DataPoint start  goal​ Declaration​ public NetworkTransformBase.DataPoint goal  "},{"title":"Properties​","type":1,"pageTitle":"Class NetworkTransformBase","url":"docs/reference/Mirage.Experimental/NetworkTransformBase#properties","content":"TargetTransform​ Declaration​ protected abstract Transform TargetTransform { get; }  "},{"title":"Mirage.Logging","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Logging/","content":"","keywords":""},{"title":"Classes​","type":1,"pageTitle":"Mirage.Logging","url":"docs/reference/Mirage.Logging/#classes","content":"ILoggerExtensions​ LogFactory​ LogSettings​ Used to load LogSettings in build LogSettingsExtensions​ LogSettingsSO​ LogSettingsSO.LoggerSettings​ "},{"title":"Class NetworkTransformChild","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Experimental/NetworkTransformChild","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkTransformChild","url":"docs/reference/Mirage.Experimental/NetworkTransformChild#fields","content":"target​ Declaration​ public Transform target  "},{"title":"Properties​","type":1,"pageTitle":"Class NetworkTransformChild","url":"docs/reference/Mirage.Experimental/NetworkTransformChild#properties","content":"TargetTransform​ Declaration​ protected override Transform TargetTransform { get; }  "},{"title":"Class LogFactory","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Logging/LogFactory","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Class LogFactory","url":"docs/reference/Mirage.Logging/LogFactory#properties","content":"Loggers​ Declaration​ public static IReadOnlyDictionary&lt;string, ILogger&gt; Loggers { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class LogFactory","url":"docs/reference/Mirage.Logging/LogFactory#methods","content":"GetLogger&lt;T&gt;(LogType)​ Declaration​ public static ILogger GetLogger&lt;T&gt;(LogType defaultLogLevel = null)  Parameters​ Type\tName\tDescriptionLogType\tdefaultLogLevel\t Returns​ Type\tDescriptionILogger\t GetLogger(Type, LogType)​ Declaration​ public static ILogger GetLogger(Type type, LogType defaultLogLevel = null)  Parameters​ Type\tName\tDescriptionSystem.Type\ttype LogType\tdefaultLogLevel\t Returns​ Type\tDescriptionILogger\t GetLogger(String, LogType)​ Declaration​ public static ILogger GetLogger(string loggerName, LogType defaultLogLevel = null)  Parameters​ Type\tName\tDescriptionSystem.String\tloggerName LogType\tdefaultLogLevel\t Returns​ Type\tDescriptionILogger\t ReplaceLogHandler(ILogHandler)​ Replacing log handler for all existing loggers and sets defaultLogHandler for new loggers Declaration​ public static void ReplaceLogHandler(ILogHandler logHandler)  Parameters​ Type\tName\tDescriptionILogHandler\tlogHandler\t "},{"title":"Class ILoggerExtensions","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Logging/ILoggerExtensions","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class ILoggerExtensions","url":"docs/reference/Mirage.Logging/ILoggerExtensions#methods","content":"LogError(ILogger, Object)​ Declaration​ public static void LogError(this ILogger logger, object message)  Parameters​ Type\tName\tDescriptionILogger\tlogger System.Object\tmessage\t Assert(ILogger, Boolean, Object)​ Declaration​ [Conditional(&quot;UNITY_ASSERTIONS&quot;)] public static void Assert(this ILogger logger, bool condition, object message)  Parameters​ Type\tName\tDescriptionILogger\tlogger System.Boolean\tcondition System.Object\tmessage\t Assert(ILogger, Boolean)​ Declaration​ [Conditional(&quot;UNITY_ASSERTIONS&quot;)] public static void Assert(this ILogger logger, bool condition)  Parameters​ Type\tName\tDescriptionILogger\tlogger System.Boolean\tcondition\t LogWarning(ILogger, Object)​ Declaration​ public static void LogWarning(this ILogger logger, object message)  Parameters​ Type\tName\tDescriptionILogger\tlogger System.Object\tmessage\t LogEnabled(ILogger)​ Declaration​ public static bool LogEnabled(this ILogger logger)  Parameters​ Type\tName\tDescriptionILogger\tlogger\t Returns​ Type\tDescriptionSystem.Boolean\t WarnEnabled(ILogger)​ Declaration​ public static bool WarnEnabled(this ILogger logger)  Parameters​ Type\tName\tDescriptionILogger\tlogger\t Returns​ Type\tDescriptionSystem.Boolean\t ErrorEnabled(ILogger)​ Declaration​ public static bool ErrorEnabled(this ILogger logger)  Parameters​ Type\tName\tDescriptionILogger\tlogger\t Returns​ Type\tDescriptionSystem.Boolean\t "},{"title":"Class LogSettings","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Logging/LogSettings","content":"Class LogSettings Used to load LogSettings in build Inheritance​ System.Object Syntax​ public class LogSettings : MonoBehaviour ","keywords":""},{"title":"Class LogSettingsExtensions","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Logging/LogSettingsExtensions","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class LogSettingsExtensions","url":"docs/reference/Mirage.Logging/LogSettingsExtensions#methods","content":"SaveFromLogFactory(LogSettingsSO)​ Declaration​ public static void SaveFromLogFactory(this LogSettingsSO settings)  Parameters​ Type\tName\tDescriptionMirage.Logging.LogSettingsSO\tsettings\t LoadIntoLogFactory(LogSettingsSO)​ Declaration​ public static void LoadIntoLogFactory(this LogSettingsSO settings)  Parameters​ Type\tName\tDescriptionMirage.Logging.LogSettingsSO\tsettings\t "},{"title":"Class LogSettingsSO","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Logging/LogSettingsSO","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class LogSettingsSO","url":"docs/reference/Mirage.Logging/LogSettingsSO#fields","content":"LogLevels​ Declaration​ public List&lt;LogSettingsSO.LoggerSettings&gt; LogLevels  "},{"title":"Mirage.RemoteCalls","type":0,"sectionRef":"#","url":"docs/reference/Mirage.RemoteCalls/","content":"","keywords":""},{"title":"Classes​","type":1,"pageTitle":"Mirage.RemoteCalls","url":"docs/reference/Mirage.RemoteCalls/#classes","content":"ClientRpcSender​ RemoteCall​ Used for invoking a RPC methods RemoteCallCollection​ ServerRpcSender​ Methods used by weaver to send RPCs "},{"title":"Enums​","type":1,"pageTitle":"Mirage.RemoteCalls","url":"docs/reference/Mirage.RemoteCalls/#enums","content":"RpcInvokeType​ "},{"title":"Delegates​","type":1,"pageTitle":"Mirage.RemoteCalls","url":"docs/reference/Mirage.RemoteCalls/#delegates","content":"RequestDelegate&lt;T&gt;​ RpcDelegate​ Delegate for ServerRpc functions. "},{"title":"Class LogSettingsSO.LoggerSettings","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Logging/LogSettingsSO.LoggerSettings","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class LogSettingsSO.LoggerSettings","url":"docs/reference/Mirage.Logging/LogSettingsSO.LoggerSettings#constructors","content":"LoggerSettings(String, String, LogType)​ Declaration​ public LoggerSettings(string name, string namespace, LogType level)  Parameters​ Type\tName\tDescriptionSystem.String\tname System.String\tnamespace LogType\tlevel\t LoggerSettings(String, LogType)​ Declaration​ public LoggerSettings(string fullname, LogType level)  Parameters​ Type\tName\tDescriptionSystem.String\tfullname LogType\tlevel\t "},{"title":"Fields​","type":1,"pageTitle":"Class LogSettingsSO.LoggerSettings","url":"docs/reference/Mirage.Logging/LogSettingsSO.LoggerSettings#fields","content":"Name​ Declaration​ public string Name  Namespace​ Declaration​ public string Namespace  logLevel​ Declaration​ public LogType logLevel  "},{"title":"Properties​","type":1,"pageTitle":"Class LogSettingsSO.LoggerSettings","url":"docs/reference/Mirage.Logging/LogSettingsSO.LoggerSettings#properties","content":"FullName​ Declaration​ public string FullName { get; }  "},{"title":"Class ClientRpcSender","type":0,"sectionRef":"#","url":"docs/reference/Mirage.RemoteCalls/ClientRpcSender","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class ClientRpcSender","url":"docs/reference/Mirage.RemoteCalls/ClientRpcSender#methods","content":"Send(NetworkBehaviour, Int32, NetworkWriter, Int32, Boolean)​ Declaration​ public static void Send(NetworkBehaviour behaviour, int index, NetworkWriter writer, int channelId, bool excludeOwner)  Parameters​ Type\tName\tDescriptionMirage.NetworkBehaviour\tbehaviour System.Int32\tindex Mirage.Serialization.NetworkWriter\twriter System.Int32\tchannelId System.Boolean\texcludeOwner\t SendTarget(NetworkBehaviour, Int32, NetworkWriter, Int32, INetworkPlayer)​ Declaration​ public static void SendTarget(NetworkBehaviour behaviour, int index, NetworkWriter writer, int channelId, INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.NetworkBehaviour\tbehaviour System.Int32\tindex Mirage.Serialization.NetworkWriter\twriter System.Int32\tchannelId Mirage.INetworkPlayer\tplayer\t ShouldInvokeLocally(NetworkBehaviour, RpcTarget, INetworkPlayer)​ Used by weaver to check if ClientRPC should be invoked locally in host mode Declaration​ public static bool ShouldInvokeLocally(NetworkBehaviour behaviour, RpcTarget target, INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.NetworkBehaviour\tbehaviour Mirage.RpcTarget\ttarget Mirage.INetworkPlayer\tplayer\tplayer used for RpcTarget.Player Returns​ Type\tDescriptionSystem.Boolean\t IsLocalPlayerObserver(NetworkBehaviour)​ Checks if host player can see the object Weaver uses this to check if RPC should be invoked locally Declaration​ public static bool IsLocalPlayerObserver(NetworkBehaviour behaviour)  Parameters​ Type\tName\tDescriptionMirage.NetworkBehaviour\tbehaviour\t Returns​ Type\tDescriptionSystem.Boolean\t IsLocalPlayerTarget(NetworkBehaviour, INetworkPlayer)​ Checks if host player is the target player Weaver uses this to check if RPC should be invoked locally Declaration​ public static bool IsLocalPlayerTarget(NetworkBehaviour behaviour, INetworkPlayer target)  Parameters​ Type\tName\tDescriptionMirage.NetworkBehaviour\tbehaviour Mirage.INetworkPlayer\ttarget\t Returns​ Type\tDescriptionSystem.Boolean\t "},{"title":"Class RemoteCall","type":0,"sectionRef":"#","url":"docs/reference/Mirage.RemoteCalls/RemoteCall","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class RemoteCall","url":"docs/reference/Mirage.RemoteCalls/RemoteCall#constructors","content":"RemoteCall(Type, RpcInvokeType, RpcDelegate, Boolean, String)​ Declaration​ public RemoteCall(Type declaringType, RpcInvokeType invokeType, RpcDelegate function, bool requireAuthority, string name)  Parameters​ Type\tName\tDescriptionSystem.Type\tdeclaringType Mirage.RemoteCalls.RpcInvokeType\tinvokeType Mirage.RemoteCalls.RpcDelegate\tfunction System.Boolean\trequireAuthority System.String\tname\t "},{"title":"Fields​","type":1,"pageTitle":"Class RemoteCall","url":"docs/reference/Mirage.RemoteCalls/RemoteCall#fields","content":"DeclaringType​ Type that rpc was declared in Declaration​ public readonly Type DeclaringType  InvokeType​ Server rpc or client rpc Declaration​ public readonly RpcInvokeType InvokeType  function​ Function to be invoked when receiving message Declaration​ public readonly RpcDelegate function  RequireAuthority​ Used by ServerRpc Declaration​ public readonly bool RequireAuthority  name​ User friendly name Declaration​ public readonly string name  "},{"title":"Methods​","type":1,"pageTitle":"Class RemoteCall","url":"docs/reference/Mirage.RemoteCalls/RemoteCall#methods","content":"AreEqual(Type, RpcInvokeType, RpcDelegate)​ Declaration​ public bool AreEqual(Type declaringType, RpcInvokeType invokeType, RpcDelegate function)  Parameters​ Type\tName\tDescriptionSystem.Type\tdeclaringType Mirage.RemoteCalls.RpcInvokeType\tinvokeType Mirage.RemoteCalls.RpcDelegate\tfunction\t Returns​ Type\tDescriptionSystem.Boolean\t ToString()​ User friendly name used for debug/error messages Declaration​ public override string ToString()  Returns​ Type\tDescriptionSystem.String\t "},{"title":"Delegate RequestDelegate<T>","type":0,"sectionRef":"#","url":"docs/reference/Mirage.RemoteCalls/RequestDelegate-1","content":"Delegate RequestDelegate&lt;T&gt; Syntax​ public delegate UniTask&lt;T&gt; RequestDelegate&lt;T&gt;(NetworkBehaviour obj, NetworkReader reader, INetworkPlayer senderPlayer, int replyId); Type Parameters​ Name\tDescriptionT\t","keywords":""},{"title":"Class RemoteCallCollection","type":0,"sectionRef":"#","url":"docs/reference/Mirage.RemoteCalls/RemoteCallCollection","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class RemoteCallCollection","url":"docs/reference/Mirage.RemoteCalls/RemoteCallCollection#constructors","content":"RemoteCallCollection(NetworkBehaviour)​ Declaration​ public RemoteCallCollection(NetworkBehaviour behaviour)  Parameters​ Type\tName\tDescriptionMirage.NetworkBehaviour\tbehaviour\t "},{"title":"Fields​","type":1,"pageTitle":"Class RemoteCallCollection","url":"docs/reference/Mirage.RemoteCalls/RemoteCallCollection#fields","content":"remoteCalls​ Declaration​ public RemoteCall[] remoteCalls  "},{"title":"Methods​","type":1,"pageTitle":"Class RemoteCallCollection","url":"docs/reference/Mirage.RemoteCalls/RemoteCallCollection#methods","content":"Register(Int32, Type, String, RpcInvokeType, RpcDelegate, Boolean)​ Declaration​ public void Register(int index, Type invokeClass, string name, RpcInvokeType invokerType, RpcDelegate func, bool cmdRequireAuthority)  Parameters​ Type\tName\tDescriptionSystem.Int32\tindex System.Type\tinvokeClass System.String\tname Mirage.RemoteCalls.RpcInvokeType\tinvokerType Mirage.RemoteCalls.RpcDelegate\tfunc System.Boolean\tcmdRequireAuthority\t RegisterRequest&lt;T&gt;(Int32, Type, String, RequestDelegate&lt;T&gt;, Boolean)​ Declaration​ public void RegisterRequest&lt;T&gt;(int index, Type invokeClass, string name, RequestDelegate&lt;T&gt; func, bool cmdRequireAuthority)  Parameters​ Type\tName\tDescriptionSystem.Int32\tindex System.Type\tinvokeClass System.String\tname Mirage.RemoteCalls.RequestDelegate&lt;T&gt;\tfunc System.Boolean\tcmdRequireAuthority\t Get(Int32)​ Declaration​ public RemoteCall Get(int index)  Parameters​ Type\tName\tDescriptionSystem.Int32\tindex\t Returns​ Type\tDescriptionMirage.RemoteCalls.RemoteCall\t "},{"title":"Delegate RpcDelegate","type":0,"sectionRef":"#","url":"docs/reference/Mirage.RemoteCalls/RpcDelegate","content":"Delegate RpcDelegate Delegate for ServerRpc functions. Syntax​ public delegate void RpcDelegate(NetworkBehaviour obj, NetworkReader reader, INetworkPlayer senderPlayer, int replyId); ","keywords":""},{"title":"Enum RpcInvokeType","type":0,"sectionRef":"#","url":"docs/reference/Mirage.RemoteCalls/RpcInvokeType","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Enum RpcInvokeType","url":"docs/reference/Mirage.RemoteCalls/RpcInvokeType#fields","content":"ServerRpc​ Declaration​ ServerRpc = 0  ClientRpc​ Declaration​ ClientRpc = 1  "},{"title":"Class ServerRpcSender","type":0,"sectionRef":"#","url":"docs/reference/Mirage.RemoteCalls/ServerRpcSender","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class ServerRpcSender","url":"docs/reference/Mirage.RemoteCalls/ServerRpcSender#methods","content":"Send(NetworkBehaviour, Int32, NetworkWriter, Int32, Boolean)​ Declaration​ public static void Send(NetworkBehaviour behaviour, int index, NetworkWriter writer, int channelId, bool requireAuthority)  Parameters​ Type\tName\tDescriptionMirage.NetworkBehaviour\tbehaviour System.Int32\tindex Mirage.Serialization.NetworkWriter\twriter System.Int32\tchannelId System.Boolean\trequireAuthority\t SendWithReturn&lt;T&gt;(NetworkBehaviour, Int32, NetworkWriter, Int32, Boolean)​ Declaration​ public static UniTask&lt;T&gt; SendWithReturn&lt;T&gt;(NetworkBehaviour behaviour, int index, NetworkWriter writer, int channelId, bool requireAuthority)  Parameters​ Type\tName\tDescriptionMirage.NetworkBehaviour\tbehaviour System.Int32\tindex Mirage.Serialization.NetworkWriter\twriter System.Int32\tchannelId System.Boolean\trequireAuthority\t Returns​ Type\tDescriptionCysharp.Threading.Tasks.UniTask&lt;T&gt;\t ShouldInvokeLocally(NetworkBehaviour, Boolean)​ Used by weaver to check if ClientRPC should be invoked locally in host mode Declaration​ public static bool ShouldInvokeLocally(NetworkBehaviour behaviour, bool requireAuthority)  Parameters​ Type\tName\tDescriptionMirage.NetworkBehaviour\tbehaviour System.Boolean\trequireAuthority\t Returns​ Type\tDescriptionSystem.Boolean\t "},{"title":"Mirage.Serialization.Internal.Codegen","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization.Internal.Codegen/","content":"","keywords":""},{"title":"Classes​","type":1,"pageTitle":"Mirage.Serialization.Internal.Codegen","url":"docs/reference/Mirage.Serialization.Internal.Codegen/#classes","content":"WeaverReaderGeneratedAttribute​ Used by weaver Weavers Adds to types that have readers generared for them. Checked by other asmdefs so they dont generate their own readers WeaverWriterGeneratedAttribute​ Used by weaver Weavers Adds to types that have writers generared for them. Checked by other asmdefs so they dont generate their own writers "},{"title":"Class WeaverReaderGeneratedAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization.Internal.Codegen/WeaverReaderGeneratedAttribute","content":"Class WeaverReaderGeneratedAttribute Used by weaver Weavers Adds to types that have readers generared for them. Checked by other asmdefs so they dont generate their own readers Inheritance​ System.Object System.Attribute Inherited Members​ Show Syntax​ [AttributeUsage(AttributeTargets.Method)] [Obsolete(&quot;broken in unity2021&quot;)] public sealed class WeaverReaderGeneratedAttribute : Attribute, _Attribute ","keywords":""},{"title":"Class WeaverWriterGeneratedAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization.Internal.Codegen/WeaverWriterGeneratedAttribute","content":"Class WeaverWriterGeneratedAttribute Used by weaver Weavers Adds to types that have writers generared for them. Checked by other asmdefs so they dont generate their own writers Inheritance​ System.Object System.Attribute Inherited Members​ Show Syntax​ [AttributeUsage(AttributeTargets.Method)] [Obsolete(&quot;broken in unity2021&quot;)] public sealed class WeaverWriterGeneratedAttribute : Attribute, _Attribute ","keywords":""},{"title":"Mirage.Serialization","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/","content":"","keywords":""},{"title":"Classes​","type":1,"pageTitle":"Mirage.Serialization","url":"docs/reference/Mirage.Serialization/#classes","content":"BitCountAttribute​ Tells weaver how many bits to sue for field Only works with interager fields (byte, int, ulong, enums etc) NOTE: bits are truncated when using this, so signed values will lose their sign. Use as well if value might be negative Also See: Bit Packing Documentation BitCountFromRangeAttribute​ Calculates bitcount from then given min/max values and then packs using Also See: Bit Packing Documentation BitHelper​ BitMask​ CollectionExtensions​ CompressedExtensions​ FloatPackAttribute​ Packs a float field, clamped from -max to +max, with Also See: Bit Packing Documentation FloatPacker​ Helps compresses a float into a reduced number of bits FromBitCount​ The max value for N number of bits GenericTypesSerializationExtensions​ MessagePacker​ MirageNetworkReader​ NetworkReader but has a ObjectLocator field that can be used by Reader functions to fetch NetworkIdentity MirageTypesExtensions​ NetworkReader​ Bit writer, writes values to a buffer on a bit level Use to reduce memory allocation NetworkReaderPool​ Holds static reference to of NetworkWriter​ Bit writer, writes values to a buffer on a bit level Use to reduce memory allocation NetworkWriterPool​ PackedExtensions​ PooledNetworkReader​ NetworkReader to be used with PooledNetworkWriter​ NetworkWriter to be used with QuaternionPackAttribute​ QuaternionPacker​ Reader&lt;T&gt;​ a class that holds readers for the different types Note that c# creates a different static variable for each type This will be populated by the weaver StringExtensions​ SystemTypesExtensions​ UnityTypesExtensions​ VarFloatPacker​ Packs a float using and VarIntAttribute​ Tells weaver the max range for small, medium and large values. Allows small values to be sent using less bits Only works with interager fields (byte, int, ulong, enums etc) VarIntBlocksAttribute​ Tells weaver the block size to use for packing int values Allows small values to be sent using less bits Only works with interager fields (byte, int, ulong, enums etc) VarIntBlocksPacker​ VarIntPacker​ VarVector3Packer​ Packs a vector3 using and Vector2PackAttribute​ Vector2Packer​ Vector3PackAttribute​ Vector3Packer​ WeaverIgnoreAttribute​ Tells Weaver to ignore an Extension method Writer&lt;T&gt;​ a class that holds writers for the different types Note that c# creates a different static variable for each type This will be populated by the weaver ZigZag​ See zigzag encoding ZigZagEncodeAttribute​ Used along size to encodes a interager value using so that both positive and negative values can be sent Also See: Bit Packing Documentation "},{"title":"Class BitCountFromRangeAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/BitCountFromRangeAttribute","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class BitCountFromRangeAttribute","url":"docs/reference/Mirage.Serialization/BitCountFromRangeAttribute#constructors","content":"BitCountFromRangeAttribute(Int32, Int32)​ Declaration​ public BitCountFromRangeAttribute(int min, int max)  Parameters​ Type\tName\tDescriptionSystem.Int32\tmin\tminimum possible int value System.Int32\tmax\tminimum possible max value "},{"title":"Class BitCountAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/BitCountAttribute","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class BitCountAttribute","url":"docs/reference/Mirage.Serialization/BitCountAttribute#constructors","content":"BitCountAttribute(Int32)​ Declaration​ public BitCountAttribute(int bitCount)  Parameters​ Type\tName\tDescriptionSystem.Int32\tbitCount\tValue should be between 1 and 64 "},{"title":"Class BitHelper","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/BitHelper","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class BitHelper","url":"docs/reference/Mirage.Serialization/BitHelper#methods","content":"BitCount(Single, Single)​ Gets the number of bits need for precision in range negative to positive max WARNING: these methods are not fast, dont use in hotpath Declaration​ public static int BitCount(float max, float precision)  Parameters​ Type\tName\tDescriptionSystem.Single\tmax System.Single\tprecision\tlowest precision required, bit count will round up so real precision might be higher Returns​ Type\tDescriptionSystem.Int32\t BitCount(Single, Single, Boolean)​ Gets the number of bits need for precision in range max If signed then range is negative max to positive max, If unsigned then 0 to max WARNING: these methods are not fast, dont use in hotpath Declaration​ public static int BitCount(float max, float precision, bool signed)  Parameters​ Type\tName\tDescriptionSystem.Single\tmax System.Single\tprecision\tlowest precision required, bit count will round up so real precision might be higher System.Boolean\tsigned\t Returns​ Type\tDescriptionSystem.Int32\t BitCount(UInt64)​ Gets the number of bits need for max WARNING: these methods are not fast, dont use in hotpath Declaration​ public static int BitCount(ulong max)  Parameters​ Type\tName\tDescriptionSystem.UInt64\tmax\t Returns​ Type\tDescriptionSystem.Int32\t "},{"title":"Class BitMask","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/BitMask","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class BitMask","url":"docs/reference/Mirage.Serialization/BitMask#methods","content":"Mask(Int32)​ Creates mask for bits (showing 32 bits for simplify, result is 64 bit) Example bits = 4 =&gt; mask = 00000000_00000000_00000000_00001111 Example bits = 10 =&gt; mask = 00000000_00000000_00000011_11111111 Declaration​ public static ulong Mask(int bits)  Parameters​ Type\tName\tDescriptionSystem.Int32\tbits\t Returns​ Type\tDescriptionSystem.UInt64\t OuterMask(Int32, Int32)​ Creates Mask either side of start and end Note this mask is only valid for start [0..63] and end [0..64] Declaration​ public static ulong OuterMask(int start, int end)  Parameters​ Type\tName\tDescriptionSystem.Int32\tstart System.Int32\tend\t Returns​ Type\tDescriptionSystem.UInt64\t "},{"title":"Class CompressedExtensions","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/CompressedExtensions","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class CompressedExtensions","url":"docs/reference/Mirage.Serialization/CompressedExtensions#methods","content":"WriteQuaternion(NetworkWriter, Quaternion)​ Packs Quaternion using Declaration​ public static void WriteQuaternion(this NetworkWriter writer, Quaternion rotation)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Quaternion\trotation\t ReadQuaternion(NetworkReader)​ Unpacks Quaternion using Declaration​ public static Quaternion ReadQuaternion(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionQuaternion\t "},{"title":"Class CollectionExtensions","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/CollectionExtensions","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class CollectionExtensions","url":"docs/reference/Mirage.Serialization/CollectionExtensions#methods","content":"WriteBytesAndSize(NetworkWriter, Byte[], Int32, Int32)​ For byte arrays with dynamic size, where the reader doesn't know how many will come Declaration​ public static void WriteBytesAndSize(this NetworkWriter writer, byte[] buffer, int offset, int count)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Byte[]\tbuffer\tarray or null System.Int32\toffset System.Int32\tcount\t WriteBytesAndSize(NetworkWriter, Byte[])​ Write method for weaver to use Declaration​ public static void WriteBytesAndSize(this NetworkWriter writer, byte[] buffer)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Byte[]\tbuffer\tarray or null WriteBytesAndSizeSegment(NetworkWriter, ArraySegment&lt;Byte&gt;)​ Declaration​ public static void WriteBytesAndSizeSegment(this NetworkWriter writer, ArraySegment&lt;byte&gt; buffer)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.ArraySegment&lt;System.Byte&gt;\tbuffer\t WriteList&lt;T&gt;(NetworkWriter, List&lt;T&gt;)​ Declaration​ public static void WriteList&lt;T&gt;(this NetworkWriter writer, List&lt;T&gt; list)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Collections.Generic.List&lt;T&gt;\tlist\t WriteArray&lt;T&gt;(NetworkWriter, T[])​ Declaration​ public static void WriteArray&lt;T&gt;(this NetworkWriter writer, T[] array)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter {T}[]\tarray\t WriteArraySegment&lt;T&gt;(NetworkWriter, ArraySegment&lt;T&gt;)​ Declaration​ public static void WriteArraySegment&lt;T&gt;(this NetworkWriter writer, ArraySegment&lt;T&gt; segment)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.ArraySegment&lt;T&gt;\tsegment\t ReadBytesAndSize(NetworkReader)​ Declaration​ public static byte[] ReadBytesAndSize(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.Byte[]\tarray or null ReadBytesAndSizeSegment(NetworkReader)​ Declaration​ public static ArraySegment&lt;byte&gt; ReadBytesAndSizeSegment(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.ArraySegment&lt;System.Byte&gt;\t ReadBytes(NetworkReader, Int32)​ Declaration​ public static byte[] ReadBytes(this NetworkReader reader, int count)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader System.Int32\tcount\t Returns​ Type\tDescriptionSystem.Byte[]\t ReadList&lt;T&gt;(NetworkReader)​ Declaration​ public static List&lt;T&gt; ReadList&lt;T&gt;(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.Collections.Generic.List&lt;T&gt;\t ReadArray&lt;T&gt;(NetworkReader)​ Declaration​ public static T[] ReadArray&lt;T&gt;(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescription{T}[]\t ReadArraySegment&lt;T&gt;(NetworkReader)​ Declaration​ public static ArraySegment&lt;T&gt; ReadArraySegment&lt;T&gt;(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.ArraySegment&lt;T&gt;\t "},{"title":"Class FloatPackAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/FloatPackAttribute","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class FloatPackAttribute","url":"docs/reference/Mirage.Serialization/FloatPackAttribute#constructors","content":"FloatPackAttribute(Single, Single)​ Declaration​ public FloatPackAttribute(float max, float precision)  Parameters​ Type\tName\tDescriptionSystem.Single\tmax\tMax value of the float System.Single\tprecision\tSmallest possible value of the field. Real precision woll be caculated using bitcount but will always be lower than this parameter FloatPackAttribute(Single, Int32)​ Declaration​ public FloatPackAttribute(float max, int bitCount)  Parameters​ Type\tName\tDescriptionSystem.Single\tmax\tMax value of the float System.Int32\tbitCount\tnumber of bits to pack the field into "},{"title":"Class FloatPacker","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/FloatPacker","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class FloatPacker","url":"docs/reference/Mirage.Serialization/FloatPacker#constructors","content":"FloatPacker(Single, Single)​ Declaration​ public FloatPacker(float max, float lowestPrecision)  Parameters​ Type\tName\tDescriptionSystem.Single\tmax System.Single\tlowestPrecision\tlowest precision, actual precision will be caculated from number of bits used FloatPacker(Single, Int32)​ Declaration​ public FloatPacker(float max, int bitCount)  Parameters​ Type\tName\tDescriptionSystem.Single\tmax System.Int32\tbitCount\t FloatPacker(Single, Single, Boolean)​ Declaration​ public FloatPacker(float max, float lowestPrecision, bool signed)  Parameters​ Type\tName\tDescriptionSystem.Single\tmax System.Single\tlowestPrecision\tlowest precision, actual precision will be caculated from number of bits used System.Boolean\tsigned\tif negative values will be allowed or not FloatPacker(Single, Int32, Boolean)​ Declaration​ public FloatPacker(float max, int bitCount, bool signed)  Parameters​ Type\tName\tDescriptionSystem.Single\tmax System.Int32\tbitCount System.Boolean\tsigned\tif negative values will be allowed or not "},{"title":"Methods​","type":1,"pageTitle":"Class FloatPacker","url":"docs/reference/Mirage.Serialization/FloatPacker#methods","content":"Pack(Single)​ Packs a float value into a uint Clamps the value within min/max range Declaration​ public uint Pack(float value)  Parameters​ Type\tName\tDescriptionSystem.Single\tvalue\t Returns​ Type\tDescriptionSystem.UInt32\t Pack(NetworkWriter, Single)​ Packs and Writes a float value Clamps the value within min/max range Declaration​ public void Pack(NetworkWriter writer, float value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Single\tvalue\t PackNoClamp(Single)​ Packs a float value into a uint without clamping it in range WARNING: only use this method if value is always in range. Out of range values may not be unpacked correctly Declaration​ public uint PackNoClamp(float value)  Parameters​ Type\tName\tDescriptionSystem.Single\tvalue\t Returns​ Type\tDescriptionSystem.UInt32\t PackNoClamp(NetworkWriter, Single)​ Declaration​ public void PackNoClamp(NetworkWriter writer, float value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Single\tvalue\t Unpack(UInt32)​ Unpacks uint value to float Declaration​ public float Unpack(uint value)  Parameters​ Type\tName\tDescriptionSystem.UInt32\tvalue\t Returns​ Type\tDescriptionSystem.Single\t Unpack(NetworkReader)​ Reads and unpacks float value Declaration​ public float Unpack(NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.Single\t "},{"title":"Class GenericTypesSerializationExtensions","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/GenericTypesSerializationExtensions","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class GenericTypesSerializationExtensions","url":"docs/reference/Mirage.Serialization/GenericTypesSerializationExtensions#methods","content":"Write&lt;T&gt;(NetworkWriter, T)​ Writes any type that mirage supports Declaration​ public static void Write&lt;T&gt;(this NetworkWriter writer, T value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter T\tvalue\t Read&lt;T&gt;(NetworkReader)​ Reads any data type that mirage supports Declaration​ public static T Read&lt;T&gt;(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionT\t "},{"title":"Class MessagePacker","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/MessagePacker","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Class MessagePacker","url":"docs/reference/Mirage.Serialization/MessagePacker#properties","content":"MessageTypes​ Map of Message Id =&gt; Type When we receive a message, we can lookup here to find out what type it was. This is populated by the weaver. Declaration​ public static IReadOnlyDictionary&lt;int, Type&gt; MessageTypes { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class MessagePacker","url":"docs/reference/Mirage.Serialization/MessagePacker#methods","content":"RegisterMessage&lt;T&gt;()​ Registers a message with its ID, Useful for debugging if a message handler is missing Used by weaver Declaration​ public static void RegisterMessage&lt;T&gt;()  GetId&lt;T&gt;()​ Declaration​ public static int GetId&lt;T&gt;()  Returns​ Type\tDescriptionSystem.Int32\t GetId(Type)​ Declaration​ public static int GetId(Type type)  Parameters​ Type\tName\tDescriptionSystem.Type\ttype\t Returns​ Type\tDescriptionSystem.Int32\t Pack&lt;T&gt;(T, NetworkWriter)​ Declaration​ public static void Pack&lt;T&gt;(T message, NetworkWriter writer)  Parameters​ Type\tName\tDescriptionT\tmessage Mirage.Serialization.NetworkWriter\twriter\t Pack&lt;T&gt;(T)​ Declaration​ public static byte[] Pack&lt;T&gt;(T message)  Parameters​ Type\tName\tDescriptionT\tmessage\t Returns​ Type\tDescriptionSystem.Byte[]\t Unpack&lt;T&gt;(Byte[])​ unpack a message we received Use Instead to if you need to read NetworkIdentities Declaration​ [Obsolete(&quot;Use Unpack(byte[], IObjectLocator) instead&quot;)] public static T Unpack&lt;T&gt;(byte[] data)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tdata\t Returns​ Type\tDescriptionT\t Unpack&lt;T&gt;(Byte[], IObjectLocator)​ unpack a message we received Declaration​ public static T Unpack&lt;T&gt;(byte[] data, IObjectLocator objectLocator)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tdata Mirage.IObjectLocator\tobjectLocator\tCan be null, but must be set in order to read NetworkIdentity Values Returns​ Type\tDescriptionT\t UnpackId(NetworkReader)​ Declaration​ public static int UnpackId(NetworkReader messageReader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\tmessageReader\t Returns​ Type\tDescriptionSystem.Int32\t "},{"title":"Class FromBitCount","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/FromBitCount","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class FromBitCount","url":"docs/reference/Mirage.Serialization/FromBitCount#fields","content":"b1​ Declaration​ public const ulong b1 = 1UL  b2​ Declaration​ public const ulong b2 = 3UL  b3​ Declaration​ public const ulong b3 = 7UL  b4​ Declaration​ public const ulong b4 = 15UL  b5​ Declaration​ public const ulong b5 = 31UL  b6​ Declaration​ public const ulong b6 = 63UL  b7​ Declaration​ public const ulong b7 = 127UL  b8​ Declaration​ public const ulong b8 = 255UL  b9​ Declaration​ public const ulong b9 = 511UL  b10​ Declaration​ public const ulong b10 = 1023UL  b11​ Declaration​ public const ulong b11 = 2047UL  b12​ Declaration​ public const ulong b12 = 4095UL  b13​ Declaration​ public const ulong b13 = 8191UL  b14​ Declaration​ public const ulong b14 = 16383UL  b15​ Declaration​ public const ulong b15 = 32767UL  b16​ Declaration​ public const ulong b16 = 65535UL  b17​ Declaration​ public const ulong b17 = 131071UL  b18​ Declaration​ public const ulong b18 = 262143UL  b19​ Declaration​ public const ulong b19 = 524287UL  b20​ Declaration​ public const ulong b20 = 1048575UL  b21​ Declaration​ public const ulong b21 = 2097151UL  b22​ Declaration​ public const ulong b22 = 4194303UL  b23​ Declaration​ public const ulong b23 = 8388607UL  b24​ Declaration​ public const ulong b24 = 16777215UL  b25​ Declaration​ public const ulong b25 = 33554431UL  b26​ Declaration​ public const ulong b26 = 67108863UL  b27​ Declaration​ public const ulong b27 = 134217727UL  b28​ Declaration​ public const ulong b28 = 268435455UL  b29​ Declaration​ public const ulong b29 = 536870911UL  b30​ Declaration​ public const ulong b30 = 1073741823UL  b31​ Declaration​ public const ulong b31 = 2147483647UL  b32​ Declaration​ public const ulong b32 = 4294967295UL  b33​ Declaration​ public const ulong b33 = 8589934591UL  b34​ Declaration​ public const ulong b34 = 17179869183UL  b35​ Declaration​ public const ulong b35 = 34359738367UL  b36​ Declaration​ public const ulong b36 = 68719476735UL  b37​ Declaration​ public const ulong b37 = 137438953471UL  b38​ Declaration​ public const ulong b38 = 274877906943UL  b39​ Declaration​ public const ulong b39 = 549755813887UL  b40​ Declaration​ public const ulong b40 = 1099511627775UL  b41​ Declaration​ public const ulong b41 = 2199023255551UL  b42​ Declaration​ public const ulong b42 = 4398046511103UL  b43​ Declaration​ public const ulong b43 = 8796093022207UL  b44​ Declaration​ public const ulong b44 = 17592186044415UL  b45​ Declaration​ public const ulong b45 = 35184372088831UL  b46​ Declaration​ public const ulong b46 = 70368744177663UL  b47​ Declaration​ public const ulong b47 = 140737488355327UL  b48​ Declaration​ public const ulong b48 = 281474976710655UL  b49​ Declaration​ public const ulong b49 = 562949953421311UL  b50​ Declaration​ public const ulong b50 = 1125899906842623UL  b51​ Declaration​ public const ulong b51 = 2251799813685247UL  b52​ Declaration​ public const ulong b52 = 4503599627370495UL  b53​ Declaration​ public const ulong b53 = 9007199254740991UL  b54​ Declaration​ public const ulong b54 = 18014398509481983UL  b55​ Declaration​ public const ulong b55 = 36028797018963967UL  b56​ Declaration​ public const ulong b56 = 72057594037927935UL  b57​ Declaration​ public const ulong b57 = 144115188075855871UL  b58​ Declaration​ public const ulong b58 = 288230376151711743UL  b59​ Declaration​ public const ulong b59 = 576460752303423487UL  b60​ Declaration​ public const ulong b60 = 1152921504606846975UL  b61​ Declaration​ public const ulong b61 = 2305843009213693951UL  b62​ Declaration​ public const ulong b62 = 4611686018427387903UL  b63​ Declaration​ public const ulong b63 = 9223372036854775807UL  b64​ Declaration​ public const ulong b64 = 18446744073709551615UL  "},{"title":"Class MirageNetworkReader","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/MirageNetworkReader","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Class MirageNetworkReader","url":"docs/reference/Mirage.Serialization/MirageNetworkReader#properties","content":"ObjectLocator​ Used to find objects by net id Declaration​ public IObjectLocator ObjectLocator { get; set; }  "},{"title":"Class MirageTypesExtensions","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/MirageTypesExtensions","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class MirageTypesExtensions","url":"docs/reference/Mirage.Serialization/MirageTypesExtensions#methods","content":"WriteNetworkIdentity(NetworkWriter, NetworkIdentity)​ Declaration​ public static void WriteNetworkIdentity(this NetworkWriter writer, NetworkIdentity value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Mirage.NetworkIdentity\tvalue\t WriteNetworkBehaviour(NetworkWriter, NetworkBehaviour)​ Declaration​ public static void WriteNetworkBehaviour(this NetworkWriter writer, NetworkBehaviour value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Mirage.NetworkBehaviour\tvalue\t WriteGameObject(NetworkWriter, GameObject)​ Declaration​ public static void WriteGameObject(this NetworkWriter writer, GameObject value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter GameObject\tvalue\t ToMirageReader(NetworkReader)​ Casts reader to , throw if cast is invalid Declaration​ public static MirageNetworkReader ToMirageReader(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionMirage.Serialization.MirageNetworkReader\t ReadNetworkIdentity(NetworkReader)​ Declaration​ public static NetworkIdentity ReadNetworkIdentity(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionMirage.NetworkIdentity\t ReadNetworkBehaviour(NetworkReader)​ Declaration​ public static NetworkBehaviour ReadNetworkBehaviour(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionMirage.NetworkBehaviour\t ReadNetworkBehaviour&lt;T&gt;(NetworkReader)​ Declaration​ public static T ReadNetworkBehaviour&lt;T&gt;(this NetworkReader reader) where T : NetworkBehaviour  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionT\t ReadGameObject(NetworkReader)​ Declaration​ public static GameObject ReadGameObject(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionGameObject\t "},{"title":"Class NetworkReaderPool","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/NetworkReaderPool","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class NetworkReaderPool","url":"docs/reference/Mirage.Serialization/NetworkReaderPool#methods","content":"Configure(Int32, Int32)​ Declaration​ public static void Configure(int startPoolSize = 5, int maxPoolSize = 100)  Parameters​ Type\tName\tDescriptionSystem.Int32\tstartPoolSize System.Int32\tmaxPoolSize\t GetReader(ArraySegment&lt;Byte&gt;, IObjectLocator)​ Gets reader from pool. sets internal array and objectLocator values Declaration​ public static PooledNetworkReader GetReader(ArraySegment&lt;byte&gt; packet, IObjectLocator objectLocator)  Parameters​ Type\tName\tDescriptionSystem.ArraySegment&lt;System.Byte&gt;\tpacket Mirage.IObjectLocator\tobjectLocator\tCan be null, but must be set in order to read NetworkIdentity Values Returns​ Type\tDescriptionMirage.Serialization.PooledNetworkReader\t GetReader(Byte[], IObjectLocator)​ Gets reader from pool. sets internal array and objectLocator values Declaration​ public static PooledNetworkReader GetReader(byte[] array, IObjectLocator objectLocator)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tarray Mirage.IObjectLocator\tobjectLocator\tCan be null, but must be set in order to read NetworkIdentity Values Returns​ Type\tDescriptionMirage.Serialization.PooledNetworkReader\t GetReader(Byte[], Int32, Int32, IObjectLocator)​ Gets reader from pool. sets internal array and objectLocator values Declaration​ public static PooledNetworkReader GetReader(byte[] array, int offset, int length, IObjectLocator objectLocator)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tarray System.Int32\toffset System.Int32\tlength Mirage.IObjectLocator\tobjectLocator\tCan be null, but must be set in order to read NetworkIdentity Values Returns​ Type\tDescriptionMirage.Serialization.PooledNetworkReader\t "},{"title":"Class NetworkReader","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/NetworkReader","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class NetworkReader","url":"docs/reference/Mirage.Serialization/NetworkReader#constructors","content":"NetworkReader()​ Declaration​ public NetworkReader()  "},{"title":"Properties​","type":1,"pageTitle":"Class NetworkReader","url":"docs/reference/Mirage.Serialization/NetworkReader#properties","content":"BitLength​ Size of buffer that is being read from Declaration​ public int BitLength { get; }  BitPosition​ Current bit position for reading from buffer Declaration​ public int BitPosition { get; }  BytePosition​ Current rounded up to nearest multiple of 8 Declaration​ public int BytePosition { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class NetworkReader","url":"docs/reference/Mirage.Serialization/NetworkReader#methods","content":"Finalize()​ Declaration​ protected void Finalize()  Dispose(Boolean)​ Declaration​ protected virtual void Dispose(bool disposing)  Parameters​ Type\tName\tDescriptionSystem.Boolean\tdisposing\ttrue if called from IDisposable Dispose()​ Declaration​ public void Dispose()  Reset(ArraySegment&lt;Byte&gt;)​ Declaration​ public void Reset(ArraySegment&lt;byte&gt; segment)  Parameters​ Type\tName\tDescriptionSystem.ArraySegment&lt;System.Byte&gt;\tsegment\t Reset(Byte[])​ Declaration​ public void Reset(byte[] array)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tarray\t Reset(Byte[], Int32, Int32)​ Declaration​ public void Reset(byte[] array, int position, int length)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tarray System.Int32\tposition System.Int32\tlength\t CanRead()​ Can read atleast 1 bit Declaration​ public bool CanRead()  Returns​ Type\tDescriptionSystem.Boolean\t CanReadBits(Int32)​ Can atleast readCount bits Declaration​ public bool CanReadBits(int readCount)  Parameters​ Type\tName\tDescriptionSystem.Int32\treadCount\t Returns​ Type\tDescriptionSystem.Boolean\t CanReadBytes(Int32)​ Can atleast readCount bytes Declaration​ public bool CanReadBytes(int readCount)  Parameters​ Type\tName\tDescriptionSystem.Int32\treadCount\t Returns​ Type\tDescriptionSystem.Boolean\t ReadBoolean()​ Declaration​ public bool ReadBoolean()  Returns​ Type\tDescriptionSystem.Boolean\t ReadBooleanAsUlong()​ Writes first bit of value to buffer Declaration​ public ulong ReadBooleanAsUlong()  Returns​ Type\tDescriptionSystem.UInt64\t ReadSByte()​ Declaration​ public sbyte ReadSByte()  Returns​ Type\tDescriptionSystem.SByte\t ReadByte()​ Declaration​ public byte ReadByte()  Returns​ Type\tDescriptionSystem.Byte\t ReadInt16()​ Declaration​ public short ReadInt16()  Returns​ Type\tDescriptionSystem.Int16\t ReadUInt16()​ Declaration​ public ushort ReadUInt16()  Returns​ Type\tDescriptionSystem.UInt16\t ReadInt32()​ Declaration​ public int ReadInt32()  Returns​ Type\tDescriptionSystem.Int32\t ReadUInt32()​ Declaration​ public uint ReadUInt32()  Returns​ Type\tDescriptionSystem.UInt32\t ReadInt64()​ Declaration​ public long ReadInt64()  Returns​ Type\tDescriptionSystem.Int64\t ReadUInt64()​ Declaration​ public ulong ReadUInt64()  Returns​ Type\tDescriptionSystem.UInt64\t ReadSingle()​ Declaration​ public float ReadSingle()  Returns​ Type\tDescriptionSystem.Single\t ReadDouble()​ Declaration​ public double ReadDouble()  Returns​ Type\tDescriptionSystem.Double\t Read(Int32)​ Declaration​ public ulong Read(int bits)  Parameters​ Type\tName\tDescriptionSystem.Int32\tbits\t Returns​ Type\tDescriptionSystem.UInt64\t ReadAtPosition(Int32, Int32)​ Reads n bits from buffer at bitPosition Declaration​ public ulong ReadAtPosition(int bits, int bitPosition)  Parameters​ Type\tName\tDescriptionSystem.Int32\tbits\tnumber of bits in value to write System.Int32\tbitPosition\twhere to write bits Returns​ Type\tDescriptionSystem.UInt64\t MoveBitPosition(Int32)​ Moves the internal bit position For most usecases it is safer to use WARNING: When reading from earlier position make sure to move position back to end of buffer after reading Declaration​ public void MoveBitPosition(int newPosition)  Parameters​ Type\tName\tDescriptionSystem.Int32\tnewPosition\t PadAndCopy&lt;T&gt;(out T)​ Moves position to nearest byte then copies struct from that position Declaration​ public void PadAndCopy&lt;T&gt;(out T value) where T : struct  Parameters​ Type\tName\tDescriptionT\tvalue\t ReadBytes(Byte[], Int32, Int32)​ Moves position to nearest byte then copies bytes from that position Declaration​ public void ReadBytes(byte[] array, int offset, int length)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tarray System.Int32\toffset System.Int32\tlength\t ReadBytesSegment(Int32)​ Declaration​ public ArraySegment&lt;byte&gt; ReadBytesSegment(int count)  Parameters​ Type\tName\tDescriptionSystem.Int32\tcount\t Returns​ Type\tDescriptionSystem.ArraySegment&lt;System.Byte&gt;\t "},{"title":"Class NetworkWriterPool","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/NetworkWriterPool","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Class NetworkWriterPool","url":"docs/reference/Mirage.Serialization/NetworkWriterPool#properties","content":"BufferSize​ Current Size of buffers, or null before Configure has been called Declaration​ public static int? BufferSize { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class NetworkWriterPool","url":"docs/reference/Mirage.Serialization/NetworkWriterPool#methods","content":"Configure(Int32, Int32, Int32)​ Configures an exist pool or creates a new one Does not create a new pool if bufferSize is less that current Declaration​ public static void Configure(int bufferSize, int startPoolSize = 5, int maxPoolSize = 100)  Parameters​ Type\tName\tDescriptionSystem.Int32\tbufferSize\tstarting capacity of buffer System.Int32\tstartPoolSize System.Int32\tmaxPoolSize\t GetWriter()​ Declaration​ public static PooledNetworkWriter GetWriter()  Returns​ Type\tDescriptionMirage.Serialization.PooledNetworkWriter\t "},{"title":"Class NetworkWriter","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/NetworkWriter","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class NetworkWriter","url":"docs/reference/Mirage.Serialization/NetworkWriter#constructors","content":"NetworkWriter(Int32)​ Declaration​ public NetworkWriter(int minByteCapacity)  Parameters​ Type\tName\tDescriptionSystem.Int32\tminByteCapacity\t NetworkWriter(Int32, Boolean)​ Declaration​ public NetworkWriter(int minByteCapacity, bool allowResize)  Parameters​ Type\tName\tDescriptionSystem.Int32\tminByteCapacity System.Boolean\tallowResize\t "},{"title":"Properties​","type":1,"pageTitle":"Class NetworkWriter","url":"docs/reference/Mirage.Serialization/NetworkWriter#properties","content":"ByteCapacity​ Size limit of buffer Declaration​ public int ByteCapacity { get; }  ByteLength​ Current rounded up to nearest multiple of 8 To set byte position use multiple by 8 Declaration​ public int ByteLength { get; }  BitPosition​ Current bit position for writing to buffer To set bit position use Declaration​ public int BitPosition { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class NetworkWriter","url":"docs/reference/Mirage.Serialization/NetworkWriter#methods","content":"Finalize()​ Declaration​ protected void Finalize()  Reset()​ Declaration​ public void Reset()  ToArray()​ Copies internal buffer to new Array To reduce Allocations use instead Declaration​ public byte[] ToArray()  Returns​ Type\tDescriptionSystem.Byte[]\t ToArraySegment()​ Declaration​ public ArraySegment&lt;byte&gt; ToArraySegment()  Returns​ Type\tDescriptionSystem.ArraySegment&lt;System.Byte&gt;\t WriteBoolean(Boolean)​ Declaration​ public void WriteBoolean(bool value)  Parameters​ Type\tName\tDescriptionSystem.Boolean\tvalue\t WriteBoolean(UInt64)​ Writes first bit of value to buffer Declaration​ public void WriteBoolean(ulong value)  Parameters​ Type\tName\tDescriptionSystem.UInt64\tvalue\t WriteSByte(SByte)​ Declaration​ public void WriteSByte(sbyte value)  Parameters​ Type\tName\tDescriptionSystem.SByte\tvalue\t WriteByte(Byte)​ Declaration​ public void WriteByte(byte value)  Parameters​ Type\tName\tDescriptionSystem.Byte\tvalue\t WriteInt16(Int16)​ Declaration​ public void WriteInt16(short value)  Parameters​ Type\tName\tDescriptionSystem.Int16\tvalue\t WriteUInt16(UInt16)​ Declaration​ public void WriteUInt16(ushort value)  Parameters​ Type\tName\tDescriptionSystem.UInt16\tvalue\t WriteInt32(Int32)​ Declaration​ public void WriteInt32(int value)  Parameters​ Type\tName\tDescriptionSystem.Int32\tvalue\t WriteUInt32(UInt32)​ Declaration​ public void WriteUInt32(uint value)  Parameters​ Type\tName\tDescriptionSystem.UInt32\tvalue\t WriteInt64(Int64)​ Declaration​ public void WriteInt64(long value)  Parameters​ Type\tName\tDescriptionSystem.Int64\tvalue\t WriteUInt64(UInt64)​ Declaration​ public void WriteUInt64(ulong value)  Parameters​ Type\tName\tDescriptionSystem.UInt64\tvalue\t WriteSingle(Single)​ Declaration​ public void WriteSingle(float value)  Parameters​ Type\tName\tDescriptionSystem.Single\tvalue\t WriteDouble(Double)​ Declaration​ public void WriteDouble(double value)  Parameters​ Type\tName\tDescriptionSystem.Double\tvalue\t Write(UInt64, Int32)​ Declaration​ public void Write(ulong value, int bits)  Parameters​ Type\tName\tDescriptionSystem.UInt64\tvalue System.Int32\tbits\t WriteAtBytePosition(UInt64, Int32, Int32)​ Same as expect position given is in bytes instead of bits WARNING: When writing to bytes instead of bits make sure you are able to read at the right position when deserializing as it might cause data to be misaligned Declaration​ public void WriteAtBytePosition(ulong value, int bits, int bytePosition)  Parameters​ Type\tName\tDescriptionSystem.UInt64\tvalue System.Int32\tbits System.Int32\tbytePosition\t WriteAtPosition(UInt64, Int32, Int32)​ Writes n bits from value to bitPosition This methods can be used to go back to a previous position to write length or other flags to the buffer after other data has been written WARNING: This method does not change the internal position so will not change the overall length if writing past internal position Declaration​ public void WriteAtPosition(ulong value, int bits, int bitPosition)  Parameters​ Type\tName\tDescriptionSystem.UInt64\tvalue\tvalue to write System.Int32\tbits\tnumber of bits in value to write System.Int32\tbitPosition\twhere to write bits MoveBitPosition(Int32)​ Moves the internal bit position For most usecases it is safer to use WARNING: When writing to earlier position make sure to move position back to end of buffer after writing because position is also used as length Declaration​ public void MoveBitPosition(int newPosition)  Parameters​ Type\tName\tDescriptionSystem.Int32\tnewPosition\t PadAndCopy&lt;T&gt;(T)​ Moves position to nearest byte then copies struct to that position Declaration​ public void PadAndCopy&lt;T&gt;(in T value) where T : struct  Parameters​ Type\tName\tDescriptionT\tvalue\t WriteBytes(Byte[], Int32, Int32)​ Moves position to nearest byte then writes bytes to that position Declaration​ public void WriteBytes(byte[] array, int offset, int length)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tarray System.Int32\toffset System.Int32\tlength\t CopyFromWriter(NetworkWriter)​ Copies all data from other Declaration​ public void CopyFromWriter(NetworkWriter other)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\tother\t CopyFromWriter(NetworkWriter, Int32, Int32)​ Copies bitLength bits from other starting at otherBitPosition Declaration​ public void CopyFromWriter(NetworkWriter other, int otherBitPosition, int bitLength)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\tother System.Int32\totherBitPosition System.Int32\tbitLength\t "},{"title":"Class PackedExtensions","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/PackedExtensions","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class PackedExtensions","url":"docs/reference/Mirage.Serialization/PackedExtensions#methods","content":"WritePackedInt32(NetworkWriter, Int32)​ Declaration​ public static void WritePackedInt32(this NetworkWriter writer, int i)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Int32\ti\t WritePackedUInt32(NetworkWriter, UInt32)​ Declaration​ public static void WritePackedUInt32(this NetworkWriter writer, uint value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.UInt32\tvalue\t WritePackedInt64(NetworkWriter, Int64)​ Declaration​ public static void WritePackedInt64(this NetworkWriter writer, long i)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Int64\ti\t WritePackedUInt64(NetworkWriter, UInt64)​ Declaration​ public static void WritePackedUInt64(this NetworkWriter writer, ulong value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.UInt64\tvalue\t ReadPackedInt32(NetworkReader)​ Declaration​ public static int ReadPackedInt32(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.Int32\t ReadPackedUInt32(NetworkReader)​ Declaration​ public static uint ReadPackedUInt32(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.UInt32\t ReadPackedInt64(NetworkReader)​ Declaration​ public static long ReadPackedInt64(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.Int64\t ReadPackedUInt64(NetworkReader)​ Declaration​ public static ulong ReadPackedUInt64(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.UInt64\t "},{"title":"Class PooledNetworkWriter","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/PooledNetworkWriter","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class PooledNetworkWriter","url":"docs/reference/Mirage.Serialization/PooledNetworkWriter#methods","content":"CreateNew(Int32, Pool&lt;PooledNetworkWriter&gt;)​ Declaration​ public static PooledNetworkWriter CreateNew(int bufferSize, Pool&lt;PooledNetworkWriter&gt; pool)  Parameters​ Type\tName\tDescriptionSystem.Int32\tbufferSize Mirage.SocketLayer.Pool&lt;Mirage.Serialization.PooledNetworkWriter&gt;\tpool\t Returns​ Type\tDescriptionMirage.Serialization.PooledNetworkWriter\t Release()​ Puts object back in Pool Declaration​ public void Release()  IDisposable.Dispose()​ Declaration​ void IDisposable.Dispose()  "},{"title":"Class PooledNetworkReader","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/PooledNetworkReader","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class PooledNetworkReader","url":"docs/reference/Mirage.Serialization/PooledNetworkReader#methods","content":"CreateNew(Int32, Pool&lt;PooledNetworkReader&gt;)​ Declaration​ public static PooledNetworkReader CreateNew(int _, Pool&lt;PooledNetworkReader&gt; pool)  Parameters​ Type\tName\tDescriptionSystem.Int32\t_ Mirage.SocketLayer.Pool&lt;Mirage.Serialization.PooledNetworkReader&gt;\tpool\t Returns​ Type\tDescriptionMirage.Serialization.PooledNetworkReader\t Release()​ Puts object back in Pool Declaration​ public void Release()  IDisposable.Dispose()​ Declaration​ void IDisposable.Dispose()  Dispose(Boolean)​ Declaration​ protected override void Dispose(bool disposing)  Parameters​ Type\tName\tDescriptionSystem.Boolean\tdisposing\t "},{"title":"Class QuaternionPackAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/QuaternionPackAttribute","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class QuaternionPackAttribute","url":"docs/reference/Mirage.Serialization/QuaternionPackAttribute#constructors","content":"QuaternionPackAttribute(Int32)​ Declaration​ public QuaternionPackAttribute(int bitPerElement = 9)  Parameters​ Type\tName\tDescriptionSystem.Int32\tbitPerElement\t "},{"title":"Class QuaternionPacker","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/QuaternionPacker","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class QuaternionPacker","url":"docs/reference/Mirage.Serialization/QuaternionPacker#constructors","content":"QuaternionPacker(Int32)​ Declaration​ public QuaternionPacker(int quaternionBitLength = 10)  Parameters​ Type\tName\tDescriptionSystem.Int32\tquaternionBitLength\t10 per &quot;smallest 3&quot; is good enough for most people "},{"title":"Fields​","type":1,"pageTitle":"Class QuaternionPacker","url":"docs/reference/Mirage.Serialization/QuaternionPacker#fields","content":"Default9​ Default packer using 9 bits per element, 29 bits total Declaration​ public static readonly QuaternionPacker Default9  Default10​ Default packer using 10 bits per element, 32 bits total Declaration​ public static readonly QuaternionPacker Default10  "},{"title":"Methods​","type":1,"pageTitle":"Class QuaternionPacker","url":"docs/reference/Mirage.Serialization/QuaternionPacker#methods","content":"PackAsInt(Quaternion)​ Declaration​ public static uint PackAsInt(Quaternion value)  Parameters​ Type\tName\tDescriptionQuaternion\tvalue\t Returns​ Type\tDescriptionSystem.UInt32\t UnpackFromInt(UInt32)​ Declaration​ public static Quaternion UnpackFromInt(uint value)  Parameters​ Type\tName\tDescriptionSystem.UInt32\tvalue\t Returns​ Type\tDescriptionQuaternion\t Pack(NetworkWriter, Quaternion)​ Declaration​ public void Pack(NetworkWriter writer, Quaternion value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Quaternion\tvalue\t Pack(Quaternion)​ Declaration​ public ulong Pack(Quaternion value)  Parameters​ Type\tName\tDescriptionQuaternion\tvalue\t Returns​ Type\tDescriptionSystem.UInt64\t Unpack(NetworkReader)​ Declaration​ public Quaternion Unpack(NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionQuaternion\t Unpack(UInt64)​ Declaration​ public Quaternion Unpack(ulong combine)  Parameters​ Type\tName\tDescriptionSystem.UInt64\tcombine\t Returns​ Type\tDescriptionQuaternion\t "},{"title":"Class Reader<T>","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/Reader-1","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Class Reader<T>","url":"docs/reference/Mirage.Serialization/Reader-1#properties","content":"Read​ Declaration​ public static Func&lt;NetworkReader, T&gt; Read { set; }  "},{"title":"Class StringExtensions","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/StringExtensions","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Class StringExtensions","url":"docs/reference/Mirage.Serialization/StringExtensions#properties","content":"MaxStringLength​ Maximum number of bytes a string can be serialized to. This is to avoid allocation attack. Defaults MTU, 1300 NOTE: this is byte size after Encoding IMPORTANT: Setting this property will resize the internal buffer. Do not call in hotpath. It is best to call once when you start the application Declaration​ public static int MaxStringLength { get; set; }  "},{"title":"Methods​","type":1,"pageTitle":"Class StringExtensions","url":"docs/reference/Mirage.Serialization/StringExtensions#methods","content":"WriteString(NetworkWriter, String)​ Declaration​ public static void WriteString(this NetworkWriter writer, string value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.String\tvalue\tstring or null ReadString(NetworkReader)​ Declaration​ public static string ReadString(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.String\tstring or null WriteString(NetworkWriter, String, Encoding)​ Declaration​ public static void WriteString(this NetworkWriter writer, string value, Encoding encoding)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.String\tvalue\tstring or null System.Text.Encoding\tencoding\tUse this for encoding other than the default (UTF8). Make sure to use same encoding for ReadString ReadString(NetworkReader, Encoding)​ Declaration​ public static string ReadString(this NetworkReader reader, Encoding encoding)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader System.Text.Encoding\tencoding\tUse this for encoding other than the default (UTF8). Make sure to use same encoding for WriterString Returns​ Type\tDescriptionSystem.String\tstring or null "},{"title":"Class SystemTypesExtensions","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/SystemTypesExtensions","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class SystemTypesExtensions","url":"docs/reference/Mirage.Serialization/SystemTypesExtensions#methods","content":"WriteByteExtension(NetworkWriter, Byte)​ Declaration​ public static void WriteByteExtension(this NetworkWriter writer, byte value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Byte\tvalue\t WriteSByteExtension(NetworkWriter, SByte)​ Declaration​ public static void WriteSByteExtension(this NetworkWriter writer, sbyte value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.SByte\tvalue\t WriteChar(NetworkWriter, Char)​ Declaration​ public static void WriteChar(this NetworkWriter writer, char value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Char\tvalue\t WriteBooleanExtension(NetworkWriter, Boolean)​ Declaration​ public static void WriteBooleanExtension(this NetworkWriter writer, bool value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Boolean\tvalue\t WriteUInt16Extension(NetworkWriter, UInt16)​ Declaration​ public static void WriteUInt16Extension(this NetworkWriter writer, ushort value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.UInt16\tvalue\t WriteInt16Extension(NetworkWriter, Int16)​ Declaration​ public static void WriteInt16Extension(this NetworkWriter writer, short value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Int16\tvalue\t WriteSingleConverter(NetworkWriter, Single)​ Declaration​ public static void WriteSingleConverter(this NetworkWriter writer, float value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Single\tvalue\t WriteDoubleConverter(NetworkWriter, Double)​ Declaration​ public static void WriteDoubleConverter(this NetworkWriter writer, double value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Double\tvalue\t WriteDecimalConverter(NetworkWriter, Decimal)​ Declaration​ public static void WriteDecimalConverter(this NetworkWriter writer, decimal value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Decimal\tvalue\t WriteGuid(NetworkWriter, Guid)​ Declaration​ public static void WriteGuid(this NetworkWriter writer, Guid value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Guid\tvalue\t WriteNullable&lt;T&gt;(NetworkWriter, Nullable&lt;T&gt;)​ Declaration​ public static void WriteNullable&lt;T&gt;(this NetworkWriter writer, T? nullable) where T : struct  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Nullable&lt;T&gt;\tnullable\t ReadByteExtension(NetworkReader)​ Declaration​ public static byte ReadByteExtension(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.Byte\t ReadSByteExtension(NetworkReader)​ Declaration​ public static sbyte ReadSByteExtension(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.SByte\t ReadChar(NetworkReader)​ Declaration​ public static char ReadChar(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.Char\t ReadBooleanExtension(NetworkReader)​ Declaration​ public static bool ReadBooleanExtension(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.Boolean\t ReadInt16Extension(NetworkReader)​ Declaration​ public static short ReadInt16Extension(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.Int16\t ReadUInt16Extension(NetworkReader)​ Declaration​ public static ushort ReadUInt16Extension(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.UInt16\t ReadSingleConverter(NetworkReader)​ Declaration​ public static float ReadSingleConverter(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.Single\t ReadDoubleConverter(NetworkReader)​ Declaration​ public static double ReadDoubleConverter(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.Double\t ReadDecimalConverter(NetworkReader)​ Declaration​ public static decimal ReadDecimalConverter(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.Decimal\t ReadGuid(NetworkReader)​ Declaration​ public static Guid ReadGuid(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.Guid\t ReadNullable&lt;T&gt;(NetworkReader)​ Declaration​ public static T? ReadNullable&lt;T&gt;(this NetworkReader reader) where T : struct  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.Nullable&lt;T&gt;\t "},{"title":"Class UnityTypesExtensions","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/UnityTypesExtensions","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class UnityTypesExtensions","url":"docs/reference/Mirage.Serialization/UnityTypesExtensions#methods","content":"WriteVector2(NetworkWriter, Vector2)​ Declaration​ public static void WriteVector2(this NetworkWriter writer, Vector2 value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Vector2\tvalue\t WriteVector3(NetworkWriter, Vector3)​ Declaration​ public static void WriteVector3(this NetworkWriter writer, Vector3 value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Vector3\tvalue\t WriteVector4(NetworkWriter, Vector4)​ Declaration​ public static void WriteVector4(this NetworkWriter writer, Vector4 value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Vector4\tvalue\t WriteVector2Int(NetworkWriter, Vector2Int)​ Declaration​ public static void WriteVector2Int(this NetworkWriter writer, Vector2Int value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Vector2Int\tvalue\t WriteVector3Int(NetworkWriter, Vector3Int)​ Declaration​ public static void WriteVector3Int(this NetworkWriter writer, Vector3Int value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Vector3Int\tvalue\t WriteColor(NetworkWriter, Color)​ Declaration​ public static void WriteColor(this NetworkWriter writer, Color value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Color\tvalue\t WriteColor32(NetworkWriter, Color32)​ Declaration​ public static void WriteColor32(this NetworkWriter writer, Color32 value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Color32\tvalue\t WriteRect(NetworkWriter, Rect)​ Declaration​ public static void WriteRect(this NetworkWriter writer, Rect value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Rect\tvalue\t WritePlane(NetworkWriter, Plane)​ Declaration​ public static void WritePlane(this NetworkWriter writer, Plane value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Plane\tvalue\t WriteRay(NetworkWriter, Ray)​ Declaration​ public static void WriteRay(this NetworkWriter writer, Ray value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Ray\tvalue\t WriteMatrix4X4(NetworkWriter, Matrix4x4)​ Declaration​ public static void WriteMatrix4X4(this NetworkWriter writer, Matrix4x4 value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Matrix4x4\tvalue\t ReadVector2(NetworkReader)​ Declaration​ public static Vector2 ReadVector2(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionVector2\t ReadVector3(NetworkReader)​ Declaration​ public static Vector3 ReadVector3(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionVector3\t ReadVector4(NetworkReader)​ Declaration​ public static Vector4 ReadVector4(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionVector4\t ReadVector2Int(NetworkReader)​ Declaration​ public static Vector2Int ReadVector2Int(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionVector2Int\t ReadVector3Int(NetworkReader)​ Declaration​ public static Vector3Int ReadVector3Int(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionVector3Int\t ReadColor(NetworkReader)​ Declaration​ public static Color ReadColor(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionColor\t ReadColor32(NetworkReader)​ Declaration​ public static Color32 ReadColor32(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionColor32\t ReadRect(NetworkReader)​ Declaration​ public static Rect ReadRect(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionRect\t ReadPlane(NetworkReader)​ Declaration​ public static Plane ReadPlane(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionPlane\t ReadRay(NetworkReader)​ Declaration​ public static Ray ReadRay(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionRay\t ReadMatrix4x4(NetworkReader)​ Declaration​ public static Matrix4x4 ReadMatrix4x4(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionMatrix4x4\t "},{"title":"Class VarFloatPacker","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/VarFloatPacker","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class VarFloatPacker","url":"docs/reference/Mirage.Serialization/VarFloatPacker#constructors","content":"VarFloatPacker(Single, Int32)​ Declaration​ public VarFloatPacker(float precision, int blockSize)  Parameters​ Type\tName\tDescriptionSystem.Single\tprecision System.Int32\tblockSize\t "},{"title":"Methods​","type":1,"pageTitle":"Class VarFloatPacker","url":"docs/reference/Mirage.Serialization/VarFloatPacker#methods","content":"Pack(NetworkWriter, Single)​ Declaration​ public void Pack(NetworkWriter writer, float value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Single\tvalue\t Unpack(NetworkReader)​ Declaration​ public float Unpack(NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.Single\t "},{"title":"Class VarIntBlocksAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/VarIntBlocksAttribute","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class VarIntBlocksAttribute","url":"docs/reference/Mirage.Serialization/VarIntBlocksAttribute#constructors","content":"VarIntBlocksAttribute(Int32)​ Bit size of each block how many bits per size bits, eg if size = 6 then values under 2^6 will be sent at 7 bits, values under 2^12 sent as 14 bits, etc Declaration​ public VarIntBlocksAttribute(int blockSize)  Parameters​ Type\tName\tDescriptionSystem.Int32\tblockSize\tValue should be between 1 and 64 "},{"title":"Class VarIntAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/VarIntAttribute","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class VarIntAttribute","url":"docs/reference/Mirage.Serialization/VarIntAttribute#constructors","content":"VarIntAttribute(UInt64, UInt64)​ Declaration​ public VarIntAttribute(ulong smallMax, ulong mediumMax)  Parameters​ Type\tName\tDescriptionSystem.UInt64\tsmallMax System.UInt64\tmediumMax\t VarIntAttribute(UInt64, UInt64, UInt64, Boolean)​ Declaration​ public VarIntAttribute(ulong smallMax, ulong mediumMax, ulong largeMax, bool throwIfOverLarge = true)  Parameters​ Type\tName\tDescriptionSystem.UInt64\tsmallMax System.UInt64\tmediumMax System.UInt64\tlargeMax System.Boolean\tthrowIfOverLarge\t "},{"title":"Class VarIntBlocksPacker","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/VarIntBlocksPacker","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class VarIntBlocksPacker","url":"docs/reference/Mirage.Serialization/VarIntBlocksPacker#methods","content":"Pack(NetworkWriter, UInt64, Int32)​ Declaration​ public static void Pack(NetworkWriter writer, ulong value, int blockSize)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.UInt64\tvalue System.Int32\tblockSize\t Unpack(NetworkReader, Int32)​ Declaration​ public static ulong Unpack(NetworkReader reader, int blockSize)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader System.Int32\tblockSize\t Returns​ Type\tDescriptionSystem.UInt64\t "},{"title":"Class VarIntPacker","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/VarIntPacker","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class VarIntPacker","url":"docs/reference/Mirage.Serialization/VarIntPacker#constructors","content":"VarIntPacker(UInt64, UInt64)​ Declaration​ public VarIntPacker(ulong smallValue, ulong mediumValue)  Parameters​ Type\tName\tDescriptionSystem.UInt64\tsmallValue System.UInt64\tmediumValue\t VarIntPacker(UInt64, UInt64, UInt64, Boolean)​ Declaration​ public VarIntPacker(ulong smallValue, ulong mediumValue, ulong largeValue, bool throwIfOverLarge = true)  Parameters​ Type\tName\tDescriptionSystem.UInt64\tsmallValue System.UInt64\tmediumValue System.UInt64\tlargeValue System.Boolean\tthrowIfOverLarge\t "},{"title":"Methods​","type":1,"pageTitle":"Class VarIntPacker","url":"docs/reference/Mirage.Serialization/VarIntPacker#methods","content":"FromBitCount(Int32, Int32)​ Declaration​ public static VarIntPacker FromBitCount(int smallBits, int mediumBits)  Parameters​ Type\tName\tDescriptionSystem.Int32\tsmallBits System.Int32\tmediumBits\t Returns​ Type\tDescriptionMirage.Serialization.VarIntPacker\t FromBitCount(Int32, Int32, Int32, Boolean)​ Declaration​ public static VarIntPacker FromBitCount(int smallBits, int mediumBits, int largeBits, bool throwIfOverLarge = true)  Parameters​ Type\tName\tDescriptionSystem.Int32\tsmallBits System.Int32\tmediumBits System.Int32\tlargeBits System.Boolean\tthrowIfOverLarge\t Returns​ Type\tDescriptionMirage.Serialization.VarIntPacker\t PackUlong(NetworkWriter, UInt64)​ Declaration​ public void PackUlong(NetworkWriter writer, ulong value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.UInt64\tvalue\t PackUint(NetworkWriter, UInt32)​ Declaration​ public void PackUint(NetworkWriter writer, uint value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.UInt32\tvalue\t PackUshort(NetworkWriter, UInt16)​ Declaration​ public void PackUshort(NetworkWriter writer, ushort value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.UInt16\tvalue\t UnpackUlong(NetworkReader)​ Declaration​ public ulong UnpackUlong(NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.UInt64\t UnpackUint(NetworkReader)​ Declaration​ public uint UnpackUint(NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.UInt32\t UnpackUshort(NetworkReader)​ Declaration​ public ushort UnpackUshort(NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionSystem.UInt16\t "},{"title":"Class VarVector3Packer","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/VarVector3Packer","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class VarVector3Packer","url":"docs/reference/Mirage.Serialization/VarVector3Packer#constructors","content":"VarVector3Packer(Vector3, Int32)​ Declaration​ public VarVector3Packer(Vector3 precision, int blocksize)  Parameters​ Type\tName\tDescriptionVector3\tprecision System.Int32\tblocksize\t "},{"title":"Methods​","type":1,"pageTitle":"Class VarVector3Packer","url":"docs/reference/Mirage.Serialization/VarVector3Packer#methods","content":"Pack(NetworkWriter, Vector3)​ Declaration​ public void Pack(NetworkWriter writer, Vector3 position)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Vector3\tposition\t Unpack(NetworkReader)​ Declaration​ public Vector3 Unpack(NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionVector3\t "},{"title":"Class Vector2Packer","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/Vector2Packer","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class Vector2Packer","url":"docs/reference/Mirage.Serialization/Vector2Packer#constructors","content":"Vector2Packer(Single, Single, Int32, Int32)​ Declaration​ public Vector2Packer(float xMax, float yMax, int xBitCount, int yBitCount)  Parameters​ Type\tName\tDescriptionSystem.Single\txMax System.Single\tyMax System.Int32\txBitCount System.Int32\tyBitCount\t Vector2Packer(Single, Single, Single, Single)​ Declaration​ public Vector2Packer(float xMax, float yMax, float xPrecision, float yPrecision)  Parameters​ Type\tName\tDescriptionSystem.Single\txMax System.Single\tyMax System.Single\txPrecision System.Single\tyPrecision\t Vector2Packer(Vector2, Vector2)​ Declaration​ public Vector2Packer(Vector2 max, Vector2 precision)  Parameters​ Type\tName\tDescriptionVector2\tmax Vector2\tprecision\t "},{"title":"Methods​","type":1,"pageTitle":"Class Vector2Packer","url":"docs/reference/Mirage.Serialization/Vector2Packer#methods","content":"Pack(NetworkWriter, Vector2)​ Declaration​ public void Pack(NetworkWriter writer, Vector2 value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Vector2\tvalue\t Unpack(NetworkReader)​ Declaration​ public Vector2 Unpack(NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionVector2\t "},{"title":"Class Vector2PackAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/Vector2PackAttribute","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class Vector2PackAttribute","url":"docs/reference/Mirage.Serialization/Vector2PackAttribute#constructors","content":"Vector2PackAttribute(Single, Single, Single, Single)​ Declaration​ public Vector2PackAttribute(float xMax, float yMax, float xPrecision, float yPrecision)  Parameters​ Type\tName\tDescriptionSystem.Single\txMax System.Single\tyMax System.Single\txPrecision System.Single\tyPrecision\t Vector2PackAttribute(Single, Single, Single)​ Declaration​ public Vector2PackAttribute(float xMax, float yMax, float precision)  Parameters​ Type\tName\tDescriptionSystem.Single\txMax System.Single\tyMax System.Single\tprecision\t Vector2PackAttribute(Single, Single, Int32, Int32)​ Declaration​ public Vector2PackAttribute(float xMax, float yMax, int xBitCount, int yBitCount)  Parameters​ Type\tName\tDescriptionSystem.Single\txMax System.Single\tyMax System.Int32\txBitCount System.Int32\tyBitCount\t Vector2PackAttribute(Single, Single, Int32)​ Declaration​ public Vector2PackAttribute(float xMax, float yMax, int bitCount)  Parameters​ Type\tName\tDescriptionSystem.Single\txMax System.Single\tyMax System.Int32\tbitCount\t "},{"title":"Class Vector3PackAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/Vector3PackAttribute","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class Vector3PackAttribute","url":"docs/reference/Mirage.Serialization/Vector3PackAttribute#constructors","content":"Vector3PackAttribute(Single, Single, Single, Single, Single, Single)​ Declaration​ public Vector3PackAttribute(float xMax, float yMax, float zMax, float xPrecision, float yPrecision, float zPrecision)  Parameters​ Type\tName\tDescriptionSystem.Single\txMax System.Single\tyMax System.Single\tzMax System.Single\txPrecision System.Single\tyPrecision System.Single\tzPrecision\t Vector3PackAttribute(Single, Single, Single, Single)​ Declaration​ public Vector3PackAttribute(float xMax, float yMax, float zMax, float precision)  Parameters​ Type\tName\tDescriptionSystem.Single\txMax System.Single\tyMax System.Single\tzMax System.Single\tprecision\t Vector3PackAttribute(Single, Single, Single, Int32, Int32, Int32)​ Declaration​ public Vector3PackAttribute(float xMax, float yMax, float zMax, int xBitCount, int yBitCount, int zBitCount)  Parameters​ Type\tName\tDescriptionSystem.Single\txMax System.Single\tyMax System.Single\tzMax System.Int32\txBitCount System.Int32\tyBitCount System.Int32\tzBitCount\t Vector3PackAttribute(Single, Single, Single, Int32)​ Declaration​ public Vector3PackAttribute(float xMax, float yMax, float zMax, int bitCount)  Parameters​ Type\tName\tDescriptionSystem.Single\txMax System.Single\tyMax System.Single\tzMax System.Int32\tbitCount\t "},{"title":"Class Vector3Packer","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/Vector3Packer","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class Vector3Packer","url":"docs/reference/Mirage.Serialization/Vector3Packer#constructors","content":"Vector3Packer(Single, Single, Single, Int32, Int32, Int32)​ Declaration​ public Vector3Packer(float xMax, float yMax, float zMax, int xBitCount, int yBitCount, int zBitCount)  Parameters​ Type\tName\tDescriptionSystem.Single\txMax System.Single\tyMax System.Single\tzMax System.Int32\txBitCount System.Int32\tyBitCount System.Int32\tzBitCount\t Vector3Packer(Single, Single, Single, Single, Single, Single)​ Declaration​ public Vector3Packer(float xMax, float yMax, float zMax, float xPrecision, float yPrecision, float zPrecision)  Parameters​ Type\tName\tDescriptionSystem.Single\txMax System.Single\tyMax System.Single\tzMax System.Single\txPrecision System.Single\tyPrecision System.Single\tzPrecision\t Vector3Packer(Vector3, Vector3)​ Declaration​ public Vector3Packer(Vector3 max, Vector3 precision)  Parameters​ Type\tName\tDescriptionVector3\tmax Vector3\tprecision\t "},{"title":"Methods​","type":1,"pageTitle":"Class Vector3Packer","url":"docs/reference/Mirage.Serialization/Vector3Packer#methods","content":"Pack(NetworkWriter, Vector3)​ Declaration​ public void Pack(NetworkWriter writer, Vector3 value)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Vector3\tvalue\t Unpack(NetworkReader)​ Declaration​ public Vector3 Unpack(NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionVector3\t "},{"title":"Class Writer<T>","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/Writer-1","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Class Writer<T>","url":"docs/reference/Mirage.Serialization/Writer-1#properties","content":"Write​ Declaration​ public static Action&lt;NetworkWriter, T&gt; Write { set; }  "},{"title":"Class WeaverIgnoreAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/WeaverIgnoreAttribute","content":"Class WeaverIgnoreAttribute Tells Weaver to ignore an Extension method Inheritance​ System.Object System.Attribute Inherited Members​ Show Syntax​ [AttributeUsage(AttributeTargets.Method)] public sealed class WeaverIgnoreAttribute : Attribute, _Attribute ","keywords":""},{"title":"Class ZigZagEncodeAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/ZigZagEncodeAttribute","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class ZigZagEncodeAttribute","url":"docs/reference/Mirage.Serialization/ZigZagEncodeAttribute#constructors","content":"ZigZagEncodeAttribute()​ Declaration​ public ZigZagEncodeAttribute()  "},{"title":"Class ZigZag","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Serialization/ZigZag","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class ZigZag","url":"docs/reference/Mirage.Serialization/ZigZag#methods","content":"Encode(Int32)​ Declaration​ public static uint Encode(int v)  Parameters​ Type\tName\tDescriptionSystem.Int32\tv\t Returns​ Type\tDescriptionSystem.UInt32\t Encode(Int64)​ Declaration​ public static ulong Encode(long v)  Parameters​ Type\tName\tDescriptionSystem.Int64\tv\t Returns​ Type\tDescriptionSystem.UInt64\t Decode(UInt32)​ Declaration​ public static int Decode(uint v)  Parameters​ Type\tName\tDescriptionSystem.UInt32\tv\t Returns​ Type\tDescriptionSystem.Int32\t Decode(UInt64)​ Declaration​ public static long Decode(ulong v)  Parameters​ Type\tName\tDescriptionSystem.UInt64\tv\t Returns​ Type\tDescriptionSystem.Int64\t "},{"title":"Mirage.SocketLayer","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/","content":"","keywords":""},{"title":"Classes​","type":1,"pageTitle":"Mirage.SocketLayer","url":"docs/reference/Mirage.SocketLayer/#classes","content":"ByteBuffer​ Warpper around a byte[] that belongs to a ByteUtils​ Config​ INotifyCallBackExtensions​ Metrics​ NotifyToken​ Object returned from with events for when packet is Lost or Delivered Peer​ Controls flow of data in/out of mirage, Uses Pool&lt;T&gt;​ Holds a collection of so they can be re-used without allocations RingBuffer&lt;T&gt;​ Sequencer​ A sequence generator that can wrap. For example a 2 bit sequencer would generate the following numbers: 0,1,2,3,0,1,2,3,0,1,2,3... SocketFactory​ Creates an instance of "},{"title":"Structs​","type":1,"pageTitle":"Mirage.SocketLayer","url":"docs/reference/Mirage.SocketLayer/#structs","content":"Metrics.Frame​ "},{"title":"Interfaces​","type":1,"pageTitle":"Mirage.SocketLayer","url":"docs/reference/Mirage.SocketLayer/#interfaces","content":"IConnection​ Connection for IDataHandler​ Handles data from SocketLayer A high level script should implement this interface give it to Peer when it is created IEndPoint​ Object that can be used as an endpoint for and Implementation of this should override and so that 2 instance wil be equal if they have the same address internally When a new connection is received by Peer a copy of this endpoint will be created and given to that connection. On future received the incoming endpoint will be compared to active connections inside a dictionary IHasAddress​ Can be added to SocketFactory that have an Address Setting IHasPort​ Can be added to SocketFactory that have a Port Setting INotifyCallBack​ Can be passed into and methods will be invoked when notify is delivered or lost See the Notify Example on how to use this interface INotifyToken​ Object returned from with events for when packet is Lost or Delivered IPeer​ ISocket​ Link between Mirage and the outside world ITime​ "},{"title":"Enums​","type":1,"pageTitle":"Mirage.SocketLayer","url":"docs/reference/Mirage.SocketLayer/#enums","content":"Commands​ Small message used to control a connection and Commands uses their own byte/enum to split up the flow and add struture to the code. ConnectionState​ DisconnectReason​ Reason why a connection was disconnected PacketType​ RejectReason​ Reason for reject sent from server "},{"title":"Delegates​","type":1,"pageTitle":"Mirage.SocketLayer","url":"docs/reference/Mirage.SocketLayer/#delegates","content":"Pool&lt;T&gt;.CreateNewItem​ "},{"title":"Class ByteBuffer","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/ByteBuffer","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class ByteBuffer","url":"docs/reference/Mirage.SocketLayer/ByteBuffer#fields","content":"array​ Declaration​ public readonly byte[] array  "},{"title":"Methods​","type":1,"pageTitle":"Class ByteBuffer","url":"docs/reference/Mirage.SocketLayer/ByteBuffer#methods","content":"CreateNew(Int32, Pool&lt;ByteBuffer&gt;)​ Declaration​ public static ByteBuffer CreateNew(int bufferSize, Pool&lt;ByteBuffer&gt; pool)  Parameters​ Type\tName\tDescriptionSystem.Int32\tbufferSize Mirage.SocketLayer.Pool&lt;Mirage.SocketLayer.ByteBuffer&gt;\tpool\t Returns​ Type\tDescriptionMirage.SocketLayer.ByteBuffer\t Release()​ Declaration​ public void Release()  IDisposable.Dispose()​ Declaration​ void IDisposable.Dispose()  "},{"title":"Enum Commands","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/Commands","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Enum Commands","url":"docs/reference/Mirage.SocketLayer/Commands#fields","content":"ConnectRequest​ Sent from client to request to connect to server Declaration​ ConnectRequest = 1  ConnectionAccepted​ Sent when Server accepts client Declaration​ ConnectionAccepted = 2  ConnectionRejected​ Sent when server rejects client Declaration​ ConnectionRejected = 3  Disconnect​ Sent from client or server to close connection Declaration​ Disconnect = 4  "},{"title":"Class ByteUtils","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/ByteUtils","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class ByteUtils","url":"docs/reference/Mirage.SocketLayer/ByteUtils#methods","content":"WriteByte(Byte[], ref Int32, Byte)​ Declaration​ public static void WriteByte(byte[] buffer, ref int offset, byte value)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tbuffer System.Int32\toffset System.Byte\tvalue\t ReadByte(Byte[], ref Int32)​ Declaration​ public static byte ReadByte(byte[] buffer, ref int offset)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tbuffer System.Int32\toffset\t Returns​ Type\tDescriptionSystem.Byte\t WriteUShort(Byte[], ref Int32, UInt16)​ Declaration​ public static void WriteUShort(byte[] buffer, ref int offset, ushort value)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tbuffer System.Int32\toffset System.UInt16\tvalue\t ReadUShort(Byte[], ref Int32)​ Declaration​ public static ushort ReadUShort(byte[] buffer, ref int offset)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tbuffer System.Int32\toffset\t Returns​ Type\tDescriptionSystem.UInt16\t WriteUInt(Byte[], ref Int32, UInt32)​ Declaration​ public static void WriteUInt(byte[] buffer, ref int offset, uint value)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tbuffer System.Int32\toffset System.UInt32\tvalue\t ReadUInt(Byte[], ref Int32)​ Declaration​ public static uint ReadUInt(byte[] buffer, ref int offset)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tbuffer System.Int32\toffset\t Returns​ Type\tDescriptionSystem.UInt32\t WriteULong(Byte[], ref Int32, UInt64)​ Declaration​ public static void WriteULong(byte[] buffer, ref int offset, ulong value)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tbuffer System.Int32\toffset System.UInt64\tvalue\t ReadULong(Byte[], ref Int32)​ Declaration​ public static ulong ReadULong(byte[] buffer, ref int offset)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tbuffer System.Int32\toffset\t Returns​ Type\tDescriptionSystem.UInt64\t "},{"title":"Enum ConnectionState","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/ConnectionState","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Enum ConnectionState","url":"docs/reference/Mirage.SocketLayer/ConnectionState#fields","content":"Created​ Initial state Declaration​ Created = 1  Connecting​ Client is connecting to server Declaration​ Connecting = 2  Connected​ Server as accepted connection Declaration​ Connected = 3  Disconnected​ Server or client has disconnected the connection and is waiting to be cleaned up Declaration​ Disconnected = 9  Removing​ Marked to be removed from the connection collection Declaration​ Removing = 10  Destroyed​ Removed from collection and all state cleaned up Declaration​ Destroyed = 11  "},{"title":"Class Config","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/Config","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class Config","url":"docs/reference/Mirage.SocketLayer/Config#fields","content":"MaxConnections​ Max concurrent connections server will accept Declaration​ public int MaxConnections  ConnectAttemptInterval​ How often connect attempt message will be re-sent if server does not reply Declaration​ public float ConnectAttemptInterval  MaxConnectAttempts​ How many times attempt to connect before giving up Declaration​ public int MaxConnectAttempts  KeepAliveInterval​ how long after previous send before sending keep alive message Keep alive is to stop connection from timing out keep alive is sent over unreliable so this interval should be low enough so that does not timeout if some unreliable packets are missed Declaration​ public float KeepAliveInterval  TimeoutDuration​ how long without a message before disconnecting connection Declaration​ public float TimeoutDuration  key​ Key sent with connection message (defaults to Major version of assmebly) Used to validate that server and client are same application/version NOTE: key will be ASCII encoded Declaration​ public string key  DisconnectDuration​ How long after disconnect before connection is fully removed from Peer Declaration​ public float DisconnectDuration  BufferPoolStartSize​ How many buffers to create at start Declaration​ public int BufferPoolStartSize  BufferPoolMaxSize​ max number of buffers allowed to be stored in pool buffers over this limit will be left for GC Declaration​ public int BufferPoolMaxSize  TimeBeforeEmptyAck​ how long after last send to send ack without a message Declaration​ public float TimeBeforeEmptyAck  ReceivesBeforeEmptyAck​ How many receives before sending an empty ack this is so that acks are still sent even if receives many message before replying Declaration​ public int ReceivesBeforeEmptyAck  EmptyAckLimit​ How many empty acks to send via Send enough acks that there is a high chances that 1 of them reaches other size Empty Ack count resets after receives new message Declaration​ public int EmptyAckLimit  MaxReliablePacketsInSendBufferPerConnection​ How many packets can exist it ring buffers for Ack and Reliable system This value wont count null packets so can be set lower than 's value to limit actual number of packets waiting to be acked Example: (max=2000) (MTU=1200) (connections=100) =&gt; 240MB Declaration​ public int MaxReliablePacketsInSendBufferPerConnection  SequenceSize​ Bit size of sequence used for AckSystem this value also determines the size of ring buffers for Ack and Reliable system Max of 16 Declaration​ public int SequenceSize  MaxReliableFragments​ How many fragments large reliable message can be split into if set to 0 then messages over will not be allowed to be sent max value is 255 Declaration​ public int MaxReliableFragments  "},{"title":"Enum DisconnectReason","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/DisconnectReason","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Enum DisconnectReason","url":"docs/reference/Mirage.SocketLayer/DisconnectReason#fields","content":"None​ No reason given Declaration​ None = 0  Timeout​ No message Received in timeout window Declaration​ Timeout = 1  RequestedByRemotePeer​ Disconnect called by higher level Declaration​ RequestedByRemotePeer = 2  RequestedByLocalPeer​ Disconnect called by higher level Declaration​ RequestedByLocalPeer = 3  InvalidPacket​ Received packet was not allowed by config Declaration​ InvalidPacket = 4  "},{"title":"Interface IDataHandler","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/IDataHandler","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Interface IDataHandler","url":"docs/reference/Mirage.SocketLayer/IDataHandler#methods","content":"ReceiveMessage(IConnection, ArraySegment&lt;Byte&gt;)​ Receives a new Packet from low level Declaration​ void ReceiveMessage(IConnection connection, ArraySegment&lt;byte&gt; message)  Parameters​ Type\tName\tDescriptionMirage.SocketLayer.IConnection\tconnection\tconnection that sent data System.ArraySegment&lt;System.Byte&gt;\tmessage\tSingle message received by peer "},{"title":"Interface IConnection","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/IConnection","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Interface IConnection","url":"docs/reference/Mirage.SocketLayer/IConnection#properties","content":"EndPoint​ Declaration​ IEndPoint EndPoint { get; }  State​ Declaration​ ConnectionState State { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Interface IConnection","url":"docs/reference/Mirage.SocketLayer/IConnection#methods","content":"Disconnect()​ Declaration​ void Disconnect()  SendNotify(Byte[])​ Declaration​ INotifyToken SendNotify(byte[] packet)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tpacket\t Returns​ Type\tDescriptionMirage.SocketLayer.INotifyToken\t SendNotify(Byte[], Int32, Int32)​ Declaration​ INotifyToken SendNotify(byte[] packet, int offset, int length)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tpacket System.Int32\toffset System.Int32\tlength\t Returns​ Type\tDescriptionMirage.SocketLayer.INotifyToken\t SendNotify(ArraySegment&lt;Byte&gt;)​ Declaration​ INotifyToken SendNotify(ArraySegment&lt;byte&gt; packet)  Parameters​ Type\tName\tDescriptionSystem.ArraySegment&lt;System.Byte&gt;\tpacket\t Returns​ Type\tDescriptionMirage.SocketLayer.INotifyToken\t SendNotify(Byte[], INotifyCallBack)​ Declaration​ void SendNotify(byte[] packet, INotifyCallBack callBacks)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tpacket Mirage.SocketLayer.INotifyCallBack\tcallBacks\t SendNotify(Byte[], Int32, Int32, INotifyCallBack)​ Declaration​ void SendNotify(byte[] packet, int offset, int length, INotifyCallBack callBacks)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tpacket System.Int32\toffset System.Int32\tlength Mirage.SocketLayer.INotifyCallBack\tcallBacks\t SendNotify(ArraySegment&lt;Byte&gt;, INotifyCallBack)​ Declaration​ void SendNotify(ArraySegment&lt;byte&gt; packet, INotifyCallBack callBacks)  Parameters​ Type\tName\tDescriptionSystem.ArraySegment&lt;System.Byte&gt;\tpacket Mirage.SocketLayer.INotifyCallBack\tcallBacks\t SendReliable(Byte[])​ single message, batched by AckSystem Declaration​ void SendReliable(byte[] message)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tmessage\t SendReliable(Byte[], Int32, Int32)​ single message, batched by AckSystem Declaration​ void SendReliable(byte[] message, int offset, int length)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tmessage System.Int32\toffset System.Int32\tlength\t SendReliable(ArraySegment&lt;Byte&gt;)​ single message, batched by AckSystem Declaration​ void SendReliable(ArraySegment&lt;byte&gt; message)  Parameters​ Type\tName\tDescriptionSystem.ArraySegment&lt;System.Byte&gt;\tmessage\t SendUnreliable(Byte[])​ Declaration​ void SendUnreliable(byte[] packet)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tpacket\t SendUnreliable(Byte[], Int32, Int32)​ Declaration​ void SendUnreliable(byte[] packet, int offset, int length)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tpacket System.Int32\toffset System.Int32\tlength\t SendUnreliable(ArraySegment&lt;Byte&gt;)​ Declaration​ void SendUnreliable(ArraySegment&lt;byte&gt; packet)  Parameters​ Type\tName\tDescriptionSystem.ArraySegment&lt;System.Byte&gt;\tpacket\t FlushBatch()​ Forces the connection to send any batched message immediately to the socket Note: this will only send the packet to the socket. Some sockets may not send on main thread so might not send immediately Declaration​ void FlushBatch()  "},{"title":"Interface IEndPoint","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/IEndPoint","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Interface IEndPoint","url":"docs/reference/Mirage.SocketLayer/IEndPoint#methods","content":"CreateCopy()​ Creates a new instance of with same connection data this is called when a new connection is created by Declaration​ IEndPoint CreateCopy()  Returns​ Type\tDescriptionMirage.SocketLayer.IEndPoint\t "},{"title":"Interface IHasAddress","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/IHasAddress","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Interface IHasAddress","url":"docs/reference/Mirage.SocketLayer/IHasAddress#properties","content":"Address​ Declaration​ string Address { get; set; }  "},{"title":"Interface IHasPort","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/IHasPort","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Interface IHasPort","url":"docs/reference/Mirage.SocketLayer/IHasPort#properties","content":"Port​ Declaration​ int Port { get; set; }  "},{"title":"Interface INotifyCallBack","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/INotifyCallBack","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Interface INotifyCallBack","url":"docs/reference/Mirage.SocketLayer/INotifyCallBack#methods","content":"OnDelivered()​ Declaration​ void OnDelivered()  OnLost()​ Declaration​ void OnLost()  "},{"title":"Class INotifyCallBackExtensions","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/INotifyCallBackExtensions","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class INotifyCallBackExtensions","url":"docs/reference/Mirage.SocketLayer/INotifyCallBackExtensions#methods","content":"Notify(INotifyCallBack, Boolean)​ Declaration​ public static void Notify(this INotifyCallBack callBack, bool delivered)  Parameters​ Type\tName\tDescriptionMirage.SocketLayer.INotifyCallBack\tcallBack System.Boolean\tdelivered\t "},{"title":"Interface INotifyToken","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/INotifyToken","content":"Interface INotifyToken Object returned from with events for when packet is Lost or Delivered Syntax​ public interface INotifyToken ","keywords":""},{"title":"Interface IPeer","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/IPeer","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Interface IPeer","url":"docs/reference/Mirage.SocketLayer/IPeer#methods","content":"Bind(IEndPoint)​ Declaration​ void Bind(IEndPoint endPoint)  Parameters​ Type\tName\tDescriptionMirage.SocketLayer.IEndPoint\tendPoint\t Connect(IEndPoint)​ Declaration​ IConnection Connect(IEndPoint endPoint)  Parameters​ Type\tName\tDescriptionMirage.SocketLayer.IEndPoint\tendPoint\t Returns​ Type\tDescriptionMirage.SocketLayer.IConnection\t Close()​ Declaration​ void Close()  UpdateReceive()​ Call this at the start of the frame to receive new messages Declaration​ void UpdateReceive()  UpdateSent()​ Call this at end of frame to send new batches Declaration​ void UpdateSent()  "},{"title":"Interface ISocket","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/ISocket","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Interface ISocket","url":"docs/reference/Mirage.SocketLayer/ISocket#methods","content":"Bind(IEndPoint)​ Starts listens for data on an endpoint Used by Server to allow clients to connect Declaration​ void Bind(IEndPoint endPoint)  Parameters​ Type\tName\tDescriptionMirage.SocketLayer.IEndPoint\tendPoint\tthe endpoint to listen on Connect(IEndPoint)​ Sets up Socket ready to send data to endpoint as a client Declaration​ void Connect(IEndPoint endPoint)  Parameters​ Type\tName\tDescriptionMirage.SocketLayer.IEndPoint\tendPoint\t Close()​ Closes the socket, stops receiving messages from other peers Declaration​ void Close()  Poll()​ Checks if a packet is available Declaration​ bool Poll()  Returns​ Type\tDescriptionSystem.Boolean\ttrue if there is atleast 1 packet to read Receive(Byte[], out IEndPoint)​ Gets next packet Should be called after Poll Implementation should check that incoming packet is within the size of buffer, and make sure not to return bytesReceived above that size  Declaration​ int Receive(byte[] buffer, out IEndPoint endPoint)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tbuffer\tbuffer to write recevived packet into Mirage.SocketLayer.IEndPoint\tendPoint\twhere packet came from Returns​ Type\tDescriptionSystem.Int32\tlength of packet, should not be above buffer length Send(IEndPoint, Byte[], Int32)​ Sends a packet to an endpoint Implementation should use length because packet is a buffer than may contain data from previous packets Declaration​ void Send(IEndPoint endPoint, byte[] packet, int length)  Parameters​ Type\tName\tDescriptionMirage.SocketLayer.IEndPoint\tendPoint\twhere packet is being sent to System.Byte[]\tpacket\tbuffer that contains the packet, starting at index 0 System.Int32\tlength\tlength of the packet "},{"title":"Interface ITime","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/ITime","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Interface ITime","url":"docs/reference/Mirage.SocketLayer/ITime#properties","content":"Now​ Declaration​ float Now { get; }  "},{"title":"Class Metrics","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/Metrics","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class Metrics","url":"docs/reference/Mirage.SocketLayer/Metrics#constructors","content":"Metrics(Int32)​ Declaration​ public Metrics(int bitSize = 10)  Parameters​ Type\tName\tDescriptionSystem.Int32\tbitSize\t "},{"title":"Fields​","type":1,"pageTitle":"Class Metrics","url":"docs/reference/Mirage.SocketLayer/Metrics#fields","content":"Sequencer​ Declaration​ public readonly Sequencer Sequencer  buffer​ Declaration​ public readonly Metrics.Frame[] buffer  tick​ Declaration​ public uint tick  "},{"title":"Properties​","type":1,"pageTitle":"Class Metrics","url":"docs/reference/Mirage.SocketLayer/Metrics#properties","content":"Current​ Declaration​ [Obsolete(&quot;Frame is now a struct, use buffer and tick instead if you need to set data&quot;)] public Metrics.Frame Current { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class Metrics","url":"docs/reference/Mirage.SocketLayer/Metrics#methods","content":"OnTick(Int32)​ Declaration​ public void OnTick(int connectionCount)  Parameters​ Type\tName\tDescriptionSystem.Int32\tconnectionCount\t OnSend(Int32)​ Declaration​ public void OnSend(int length)  Parameters​ Type\tName\tDescriptionSystem.Int32\tlength\t OnResend(Int32)​ Declaration​ public void OnResend(int length)  Parameters​ Type\tName\tDescriptionSystem.Int32\tlength\t OnReceive(Int32)​ Declaration​ public void OnReceive(int length)  Parameters​ Type\tName\tDescriptionSystem.Int32\tlength\t OnReceiveUnconnected(Int32)​ Declaration​ public void OnReceiveUnconnected(int length)  Parameters​ Type\tName\tDescriptionSystem.Int32\tlength\t OnSendMessageUnreliable(Int32)​ Declaration​ public void OnSendMessageUnreliable(int length)  Parameters​ Type\tName\tDescriptionSystem.Int32\tlength\t OnReceiveMessageUnreliable(Int32)​ Declaration​ public void OnReceiveMessageUnreliable(int length)  Parameters​ Type\tName\tDescriptionSystem.Int32\tlength\t OnSendMessageReliable(Int32)​ Declaration​ public void OnSendMessageReliable(int length)  Parameters​ Type\tName\tDescriptionSystem.Int32\tlength\t OnReceiveMessageReliable(Int32)​ Declaration​ public void OnReceiveMessageReliable(int length)  Parameters​ Type\tName\tDescriptionSystem.Int32\tlength\t OnSendMessageNotify(Int32)​ Declaration​ public void OnSendMessageNotify(int length)  Parameters​ Type\tName\tDescriptionSystem.Int32\tlength\t OnReceiveMessageNotify(Int32)​ Declaration​ public void OnReceiveMessageNotify(int length)  Parameters​ Type\tName\tDescriptionSystem.Int32\tlength\t "},{"title":"Struct Metrics.Frame","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/Metrics.Frame","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Struct Metrics.Frame","url":"docs/reference/Mirage.SocketLayer/Metrics.Frame#fields","content":"init​ Is this frame initialized (uninitialized frames can be excluded from averages) Declaration​ public bool init  connectionCount​ Number of connections Declaration​ public int connectionCount  sendCount​ Number of send calls to connections Declaration​ public int sendCount  sendBytes​ Number of bytes sent to connections Declaration​ public int sendBytes  resendCount​ Number of resend calls by reliable system Declaration​ public int resendCount  resendBytes​ Number of bytes resent by reliable system Declaration​ public int resendBytes  receiveCount​ Number of packets received from connections Declaration​ public int receiveCount  receiveBytes​ Number of bytes received from connections Declaration​ public int receiveBytes  sendUnconnectedCount​ Number of send calls to unconnected addresses Declaration​ public int sendUnconnectedCount  sendUnconnectedBytes​ Number of bytes sent to unconnected addresses Declaration​ public int sendUnconnectedBytes  receiveUnconnectedBytes​ Number of packets received from unconnected addresses Declaration​ public int receiveUnconnectedBytes  receiveUnconnectedCount​ Number of bytes received from unconnected addresses Declaration​ public int receiveUnconnectedCount  sendMessagesUnreliableCount​ Number of Unreliable message sent to connections Declaration​ public int sendMessagesUnreliableCount  sendMessagesUnreliableBytes​ Number of Unreliable bytes sent to connections (excludes packets headers, will just be the message sent by high level) Declaration​ public int sendMessagesUnreliableBytes  receiveMessagesUnreliableCount​ Number of Unreliable message received from connections Declaration​ public int receiveMessagesUnreliableCount  receiveMessagesUnreliableBytes​ Number of Unreliable bytes received from connections (excludes packets headers, will just be the message sent by high level) Declaration​ public int receiveMessagesUnreliableBytes  sendMessagesReliableCount​ Number of Reliable message sent to connections Declaration​ public int sendMessagesReliableCount  sendMessagesReliableBytes​ Number of Reliable bytes sent to connections (excludes packets headers, will just be the message sent by high level) Declaration​ public int sendMessagesReliableBytes  receiveMessagesReliableCount​ Number of Reliable message received from connections Declaration​ public int receiveMessagesReliableCount  receiveMessagesReliableBytes​ Number of Reliable bytes received from connections (excludes packets headers, will just be the message sent by high level) Declaration​ public int receiveMessagesReliableBytes  sendMessagesNotifyCount​ Number of Notify message sent to connections Declaration​ public int sendMessagesNotifyCount  sendMessagesNotifyBytes​ Number of Notify bytes sent to connections (excludes packets headers, will just be the message sent by high level) Declaration​ public int sendMessagesNotifyBytes  receiveMessagesNotifyCount​ Number of Notify message received from connections Declaration​ public int receiveMessagesNotifyCount  receiveMessagesNotifyBytes​ Number of Notify bytes received from connections (excludes packets headers, will just be the message sent by high level) Declaration​ public int receiveMessagesNotifyBytes  "},{"title":"Properties​","type":1,"pageTitle":"Struct Metrics.Frame","url":"docs/reference/Mirage.SocketLayer/Metrics.Frame#properties","content":"sendMessagesCountTotal​ Number of message sent to connections Declaration​ public int sendMessagesCountTotal { get; }  sendMessagesBytesTotal​ Number of bytes sent to connections (excludes packets headers, will just be the message sent by high level) Declaration​ public int sendMessagesBytesTotal { get; }  receiveMessagesCountTotal​ Number of message received from connections Declaration​ public int receiveMessagesCountTotal { get; }  receiveMessagesBytesTotal​ Number of bytes received from connections (excludes packets headers, will just be the message sent by high level) Declaration​ public int receiveMessagesBytesTotal { get; }  "},{"title":"Class NotifyToken","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/NotifyToken","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class NotifyToken","url":"docs/reference/Mirage.SocketLayer/NotifyToken#methods","content":"OnDelivered()​ Declaration​ public void OnDelivered()  OnLost()​ Declaration​ public void OnLost()  "},{"title":"Enum PacketType","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/PacketType","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Enum PacketType","url":"docs/reference/Mirage.SocketLayer/PacketType#fields","content":"Command​ see Declaration​ Command = 1  Unreliable​ data packet sent with no guarantee for order or reliablity used for data that is fire and forget Declaration​ Unreliable = 2  Notify​ data packet sent with ack header so sender knows if packet gets delivered or lost Declaration​ Notify = 3  Reliable​ packet with just acks Declaration​ Reliable = 4  ReliableFragment​ packet with just acks Declaration​ ReliableFragment = 6  Ack​ packet with just acks Declaration​ Ack = 5  KeepAlive​ Used to keep connection alive. Similar to ping/pong Declaration​ KeepAlive = 10  "},{"title":"Class Peer","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/Peer","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class Peer","url":"docs/reference/Mirage.SocketLayer/Peer#constructors","content":"Peer(ISocket, Int32, IDataHandler, Config, ILogger, Metrics)​ Declaration​ public Peer(ISocket socket, int maxPacketSize, IDataHandler dataHandler, Config config = null, ILogger logger = null, Metrics metrics = null)  Parameters​ Type\tName\tDescriptionMirage.SocketLayer.ISocket\tsocket System.Int32\tmaxPacketSize Mirage.SocketLayer.IDataHandler\tdataHandler Mirage.SocketLayer.Config\tconfig ILogger\tlogger Mirage.SocketLayer.Metrics\tmetrics\t "},{"title":"Methods​","type":1,"pageTitle":"Class Peer","url":"docs/reference/Mirage.SocketLayer/Peer#methods","content":"Bind(IEndPoint)​ Declaration​ public void Bind(IEndPoint endPoint)  Parameters​ Type\tName\tDescriptionMirage.SocketLayer.IEndPoint\tendPoint\t Connect(IEndPoint)​ Declaration​ public IConnection Connect(IEndPoint endPoint)  Parameters​ Type\tName\tDescriptionMirage.SocketLayer.IEndPoint\tendPoint\t Returns​ Type\tDescriptionMirage.SocketLayer.IConnection\t Close()​ Declaration​ public void Close()  UpdateReceive()​ Call this at the start of the frame to receive new messages Declaration​ public void UpdateReceive()  UpdateSent()​ Call this at end of frame to send new batches Declaration​ public void UpdateSent()  "},{"title":"Delegate Pool<T>.CreateNewItem","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/Pool-1.CreateNewItem","content":"Delegate Pool&lt;T&gt;.CreateNewItem Syntax​ public delegate T CreateNewItem(int bufferSize, Pool&lt;T&gt; pool); ","keywords":""},{"title":"Class Pool<T>","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/Pool-1","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class Pool<T>","url":"docs/reference/Mirage.SocketLayer/Pool-1#constructors","content":"Pool(Pool&lt;T&gt;.CreateNewItem, Int32, Int32, Int32, ILogger)​ Declaration​ public Pool(Pool&lt;T&gt;.CreateNewItem createNew, int bufferSize, int startPoolSize, int maxPoolSize, ILogger logger = null)  Parameters​ Type\tName\tDescriptionMirage.SocketLayer.Pool.CreateNewItem&lt;&gt;\tcreateNew System.Int32\tbufferSize\tsize of each buffer System.Int32\tstartPoolSize\thow many buffers to create at start System.Int32\tmaxPoolSize\tmax number of buffers in pool ILogger\tlogger\t "},{"title":"Methods​","type":1,"pageTitle":"Class Pool<T>","url":"docs/reference/Mirage.SocketLayer/Pool-1#methods","content":"Configure(Int32, Int32)​ sets max pool size and then creates writers up to new start size Declaration​ public void Configure(int startPoolSize, int maxPoolSize)  Parameters​ Type\tName\tDescriptionSystem.Int32\tstartPoolSize System.Int32\tmaxPoolSize\t Take()​ Declaration​ public T Take()  Returns​ Type\tDescriptionT\t Put(T)​ Declaration​ public void Put(T buffer)  Parameters​ Type\tName\tDescriptionT\tbuffer\t "},{"title":"Enum RejectReason","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/RejectReason","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Enum RejectReason","url":"docs/reference/Mirage.SocketLayer/RejectReason#fields","content":"None​ No reason given Declaration​ None = 0  ServerFull​ Server is at max connections and will not accept a new connection until one disconnects Declaration​ ServerFull = 1  Timeout​ Server did not reply to connection request Declaration​ Timeout = 2  ClosedByPeer​ Closed called locally before connect Declaration​ ClosedByPeer = 3  KeyInvalid​ Key given with first message did not match the value on the server Declaration​ KeyInvalid = 4  "},{"title":"Class Sequencer","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/Sequencer","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class Sequencer","url":"docs/reference/Mirage.SocketLayer/Sequencer#constructors","content":"Sequencer(Int32)​ Declaration​ public Sequencer(int bits)  Parameters​ Type\tName\tDescriptionSystem.Int32\tbits\tamount of bits for the sequence "},{"title":"Properties​","type":1,"pageTitle":"Class Sequencer","url":"docs/reference/Mirage.SocketLayer/Sequencer#properties","content":"Bits​ Number of bits used for the sequence generator up to 64 Declaration​ public int Bits { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class Sequencer","url":"docs/reference/Mirage.SocketLayer/Sequencer#methods","content":"Next()​ Generates the next value in the sequence starts with 0 Declaration​ public ulong Next()  Returns​ Type\tDescriptionSystem.UInt64\t0, 1, 2, ..., (2^n)-1, 0, 1, 2, ... NextAfter(UInt64)​ Gets the next sequence value after a given sequence wraps if necessary Declaration​ public ulong NextAfter(ulong sequence)  Parameters​ Type\tName\tDescriptionSystem.UInt64\tsequence\tcurrent sequence value Returns​ Type\tDescriptionSystem.UInt64\tthe next sequence value MoveInBounds(UInt64)​ returns a sequence value from the given value wraps if necessary Declaration​ public ulong MoveInBounds(ulong sequence)  Parameters​ Type\tName\tDescriptionSystem.UInt64\tsequence\tcurrent sequence value Returns​ Type\tDescriptionSystem.UInt64\tthe next sequence value Distance(UInt64, UInt64)​ Calculates the distance between 2 sequences, taking into account wrapping Declaration​ public long Distance(ulong from, ulong to)  Parameters​ Type\tName\tDescriptionSystem.UInt64\tfrom\tcurrent sequence value System.UInt64\tto\tprevious sequence value Returns​ Type\tDescriptionSystem.Int64\tfrom - to, adjusted for wrapping "},{"title":"Class RingBuffer<T>","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/RingBuffer-1","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class RingBuffer<T>","url":"docs/reference/Mirage.SocketLayer/RingBuffer-1#constructors","content":"RingBuffer(Int32)​ Declaration​ public RingBuffer(int bitCount)  Parameters​ Type\tName\tDescriptionSystem.Int32\tbitCount\t RingBuffer(Int32, IEqualityComparer&lt;T&gt;)​ Declaration​ public RingBuffer(int bitCount, IEqualityComparer&lt;T&gt; comparer)  Parameters​ Type\tName\tDescriptionSystem.Int32\tbitCount System.Collections.Generic.IEqualityComparer&lt;T&gt;\tcomparer\t "},{"title":"Fields​","type":1,"pageTitle":"Class RingBuffer<T>","url":"docs/reference/Mirage.SocketLayer/RingBuffer-1#fields","content":"Sequencer​ Declaration​ public readonly Sequencer Sequencer  "},{"title":"Properties​","type":1,"pageTitle":"Class RingBuffer<T>","url":"docs/reference/Mirage.SocketLayer/RingBuffer-1#properties","content":"Read​ Declaration​ public uint Read { get; }  Write​ Declaration​ public uint Write { get; }  Count​ Number of non-null items in buffer NOTE: this is not distance from read to write Declaration​ public int Count { get; }  Item[UInt32]​ Declaration​ public T this[uint index] { get; }  Item[Int32]​ Declaration​ public T this[int index] { get; }  IsFull​ Declaration​ public bool IsFull { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class RingBuffer<T>","url":"docs/reference/Mirage.SocketLayer/RingBuffer-1#methods","content":"DistanceToRead(UInt32)​ Declaration​ public long DistanceToRead(uint from)  Parameters​ Type\tName\tDescriptionSystem.UInt32\tfrom\t Returns​ Type\tDescriptionSystem.Int64\t Enqueue(T)​ Declaration​ public uint Enqueue(T item)  Parameters​ Type\tName\tDescriptionT\titem\t Returns​ Type\tDescriptionSystem.UInt32\tsequance of written item TryPeak(out T)​ Tries to read the item at read index same as but does not remove the item after reading it Declaration​ public bool TryPeak(out T item)  Parameters​ Type\tName\tDescriptionT\titem\t Returns​ Type\tDescriptionSystem.Boolean\ttrue if item exists, or false if it is missing Exists(UInt32)​ Does item exist at index Index will be moved into bounds Declaration​ public bool Exists(uint index)  Parameters​ Type\tName\tDescriptionSystem.UInt32\tindex\t Returns​ Type\tDescriptionSystem.Boolean\ttrue if item exists, or false if it is missing RemoveNext()​ Removes the item at read index and increments read index can be used after to do the same as Declaration​ public void RemoveNext()  Dequeue()​ Removes next item and increments read index Assumes next items exists, best to use this with Declaration​ public T Dequeue()  Returns​ Type\tDescriptionT\t TryDequeue(out T)​ Tries to remove the item at read index Declaration​ public bool TryDequeue(out T item)  Parameters​ Type\tName\tDescriptionT\titem\t Returns​ Type\tDescriptionSystem.Boolean\ttrue if item exists, or false if it is missing InsertAt(UInt32, T)​ Declaration​ public void InsertAt(uint index, T item)  Parameters​ Type\tName\tDescriptionSystem.UInt32\tindex T\titem\t RemoveAt(UInt32)​ Declaration​ public void RemoveAt(uint index)  Parameters​ Type\tName\tDescriptionSystem.UInt32\tindex\t MoveReadToNextNonEmpty()​ Moves read index to next non empty position this is useful when removing items from buffer in random order. Will stop when write == read, or when next buffer item is not empty Declaration​ public void MoveReadToNextNonEmpty()  MoveReadOne()​ Moves read 1 index Declaration​ public void MoveReadOne()  "},{"title":"Class SocketFactory","type":0,"sectionRef":"#","url":"docs/reference/Mirage.SocketLayer/SocketFactory","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Class SocketFactory","url":"docs/reference/Mirage.SocketLayer/SocketFactory#properties","content":"MaxPacketSize​ Max size for packets sent to or received from Socket Called once when Sockets are created Declaration​ public abstract int MaxPacketSize { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class SocketFactory","url":"docs/reference/Mirage.SocketLayer/SocketFactory#methods","content":"CreateServerSocket()​ Creates a to be used by on the server Declaration​ public abstract ISocket CreateServerSocket()  Returns​ Type\tDescriptionMirage.SocketLayer.ISocket\t GetBindEndPoint()​ Creates the that the Server Socket will bind to Declaration​ public abstract IEndPoint GetBindEndPoint()  Returns​ Type\tDescriptionMirage.SocketLayer.IEndPoint\t CreateClientSocket()​ Creates a to be used by on the client Declaration​ public abstract ISocket CreateClientSocket()  Returns​ Type\tDescriptionMirage.SocketLayer.ISocket\t GetConnectEndPoint(String, Nullable&lt;UInt16&gt;)​ Creates the that the Client Socket will connect to using the parameter given Declaration​ public abstract IEndPoint GetConnectEndPoint(string address = null, ushort? port = default(ushort? ))  Parameters​ Type\tName\tDescriptionSystem.String\taddress System.Nullable&lt;System.UInt16&gt;\tport\t Returns​ Type\tDescriptionMirage.SocketLayer.IEndPoint\t "},{"title":"Mirage.Sockets.Udp","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Sockets.Udp/","content":"","keywords":""},{"title":"Classes​","type":1,"pageTitle":"Mirage.Sockets.Udp","url":"docs/reference/Mirage.Sockets.Udp/#classes","content":"EndPointWrapper​ NanoEndPoint​ NanoSocket​ NanoSocketException​ UdpMTU​ UdpSocket​ UdpSocketFactory​ "},{"title":"Enums​","type":1,"pageTitle":"Mirage.Sockets.Udp","url":"docs/reference/Mirage.Sockets.Udp/#enums","content":"SocketLib​ "},{"title":"Class EndPointWrapper","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Sockets.Udp/EndPointWrapper","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class EndPointWrapper","url":"docs/reference/Mirage.Sockets.Udp/EndPointWrapper#constructors","content":"EndPointWrapper(EndPoint)​ Declaration​ public EndPointWrapper(EndPoint endPoint)  Parameters​ Type\tName\tDescriptionSystem.Net.EndPoint\tendPoint\t "},{"title":"Fields​","type":1,"pageTitle":"Class EndPointWrapper","url":"docs/reference/Mirage.Sockets.Udp/EndPointWrapper#fields","content":"inner​ Declaration​ public EndPoint inner  "},{"title":"Methods​","type":1,"pageTitle":"Class EndPointWrapper","url":"docs/reference/Mirage.Sockets.Udp/EndPointWrapper#methods","content":"Equals(Object)​ Declaration​ public override bool Equals(object obj)  Parameters​ Type\tName\tDescriptionSystem.Object\tobj\t Returns​ Type\tDescriptionSystem.Boolean\t GetHashCode()​ Declaration​ public override int GetHashCode()  Returns​ Type\tDescriptionSystem.Int32\t ToString()​ Declaration​ public override string ToString()  Returns​ Type\tDescriptionSystem.String\t IEndPoint.CreateCopy()​ Declaration​ IEndPoint IEndPoint.CreateCopy()  Returns​ Type\tDescriptionMirage.SocketLayer.IEndPoint\t "},{"title":"Class NanoEndPoint","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Sockets.Udp/NanoEndPoint","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class NanoEndPoint","url":"docs/reference/Mirage.Sockets.Udp/NanoEndPoint#constructors","content":"NanoEndPoint(String, UInt16)​ Declaration​ public NanoEndPoint(string host, ushort port)  Parameters​ Type\tName\tDescriptionSystem.String\thost System.UInt16\tport\t NanoEndPoint(Address)​ Declaration​ public NanoEndPoint(Address address)  Parameters​ Type\tName\tDescriptionNanoSockets.Address\taddress\t "},{"title":"Fields​","type":1,"pageTitle":"Class NanoEndPoint","url":"docs/reference/Mirage.Sockets.Udp/NanoEndPoint#fields","content":"address​ Declaration​ public Address address  "},{"title":"Methods​","type":1,"pageTitle":"Class NanoEndPoint","url":"docs/reference/Mirage.Sockets.Udp/NanoEndPoint#methods","content":"CreateCopy()​ Declaration​ public IEndPoint CreateCopy()  Returns​ Type\tDescriptionMirage.SocketLayer.IEndPoint\t Equals(NanoEndPoint)​ Declaration​ public bool Equals(NanoEndPoint other)  Parameters​ Type\tName\tDescriptionMirage.Sockets.Udp.NanoEndPoint\tother\t Returns​ Type\tDescriptionSystem.Boolean\t Equals(Object)​ Declaration​ public override bool Equals(object obj)  Parameters​ Type\tName\tDescriptionSystem.Object\tobj\t Returns​ Type\tDescriptionSystem.Boolean\t GetHashCode()​ Declaration​ public override int GetHashCode()  Returns​ Type\tDescriptionSystem.Int32\t ToString()​ Declaration​ public override string ToString()  Returns​ Type\tDescriptionSystem.String\t "},{"title":"Class NanoSocketException","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Sockets.Udp/NanoSocketException","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class NanoSocketException","url":"docs/reference/Mirage.Sockets.Udp/NanoSocketException#constructors","content":"NanoSocketException(String)​ Declaration​ public NanoSocketException(string message)  Parameters​ Type\tName\tDescriptionSystem.String\tmessage\t "},{"title":"Class NanoSocket","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Sockets.Udp/NanoSocket","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class NanoSocket","url":"docs/reference/Mirage.Sockets.Udp/NanoSocket#constructors","content":"NanoSocket(UdpSocketFactory)​ Declaration​ public NanoSocket(UdpSocketFactory factory)  Parameters​ Type\tName\tDescriptionMirage.Sockets.Udp.UdpSocketFactory\tfactory\t "},{"title":"Methods​","type":1,"pageTitle":"Class NanoSocket","url":"docs/reference/Mirage.Sockets.Udp/NanoSocket#methods","content":"Finalize()​ Declaration​ protected void Finalize()  Bind(IEndPoint)​ Declaration​ public void Bind(IEndPoint endPoint)  Parameters​ Type\tName\tDescriptionMirage.SocketLayer.IEndPoint\tendPoint\t Dispose()​ Declaration​ public void Dispose()  Close()​ Declaration​ public void Close()  Connect(IEndPoint)​ Declaration​ public void Connect(IEndPoint endPoint)  Parameters​ Type\tName\tDescriptionMirage.SocketLayer.IEndPoint\tendPoint\t Poll()​ Declaration​ public bool Poll()  Returns​ Type\tDescriptionSystem.Boolean\t Receive(Byte[], out IEndPoint)​ Declaration​ public int Receive(byte[] buffer, out IEndPoint endPoint)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tbuffer Mirage.SocketLayer.IEndPoint\tendPoint\t Returns​ Type\tDescriptionSystem.Int32\t Send(IEndPoint, Byte[], Int32)​ Declaration​ public void Send(IEndPoint endPoint, byte[] packet, int length)  Parameters​ Type\tName\tDescriptionMirage.SocketLayer.IEndPoint\tendPoint System.Byte[]\tpacket System.Int32\tlength\t "},{"title":"Enum SocketLib","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Sockets.Udp/SocketLib","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Enum SocketLib","url":"docs/reference/Mirage.Sockets.Udp/SocketLib#fields","content":"Automatic​ Declaration​ Automatic = 0  Native​ Declaration​ Native = 1  Managed​ Declaration​ Managed = 2  "},{"title":"Class UdpMTU","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Sockets.Udp/UdpMTU","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Class UdpMTU","url":"docs/reference/Mirage.Sockets.Udp/UdpMTU#properties","content":"MaxPacketSize​ Max size of array that will be sent to or can be received from This will also be the size of all buffers used by This is not max message size because this size includes packets header added by Declaration​ public static int MaxPacketSize { get; }  "},{"title":"Class UdpSocket","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Sockets.Udp/UdpSocket","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class UdpSocket","url":"docs/reference/Mirage.Sockets.Udp/UdpSocket#methods","content":"Bind(IEndPoint)​ Declaration​ public void Bind(IEndPoint endPoint)  Parameters​ Type\tName\tDescriptionMirage.SocketLayer.IEndPoint\tendPoint\t Connect(IEndPoint)​ Declaration​ public void Connect(IEndPoint endPoint)  Parameters​ Type\tName\tDescriptionMirage.SocketLayer.IEndPoint\tendPoint\t Close()​ Declaration​ public void Close()  Poll()​ Is message avaliable Declaration​ public bool Poll()  Returns​ Type\tDescriptionSystem.Boolean\ttrue if data to read Receive(Byte[], out IEndPoint)​ Declaration​ public int Receive(byte[] buffer, out IEndPoint endPoint)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tbuffer Mirage.SocketLayer.IEndPoint\tendPoint\t Returns​ Type\tDescriptionSystem.Int32\t Send(IEndPoint, Byte[], Int32)​ Declaration​ public void Send(IEndPoint endPoint, byte[] packet, int length)  Parameters​ Type\tName\tDescriptionMirage.SocketLayer.IEndPoint\tendPoint System.Byte[]\tpacket System.Int32\tlength\t "},{"title":"Class UdpSocketFactory","type":0,"sectionRef":"#","url":"docs/reference/Mirage.Sockets.Udp/UdpSocketFactory","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class UdpSocketFactory","url":"docs/reference/Mirage.Sockets.Udp/UdpSocketFactory#fields","content":"Address​ Declaration​ public string Address  Port​ Declaration​ public ushort Port  SocketLib​ Declaration​ public SocketLib SocketLib  BufferSize​ Declaration​ public int BufferSize  "},{"title":"Properties​","type":1,"pageTitle":"Class UdpSocketFactory","url":"docs/reference/Mirage.Sockets.Udp/UdpSocketFactory#properties","content":"MaxPacketSize​ Declaration​ public override int MaxPacketSize { get; }  IHasAddress.Address​ Declaration​ string IHasAddress.Address { get; set; }  IHasPort.Port​ Declaration​ int IHasPort.Port { get; set; }  "},{"title":"Methods​","type":1,"pageTitle":"Class UdpSocketFactory","url":"docs/reference/Mirage.Sockets.Udp/UdpSocketFactory#methods","content":"CreateClientSocket()​ Declaration​ public override ISocket CreateClientSocket()  Returns​ Type\tDescriptionMirage.SocketLayer.ISocket\t CreateServerSocket()​ Declaration​ public override ISocket CreateServerSocket()  Returns​ Type\tDescriptionMirage.SocketLayer.ISocket\t GetBindEndPoint()​ Declaration​ public override IEndPoint GetBindEndPoint()  Returns​ Type\tDescriptionMirage.SocketLayer.IEndPoint\t GetConnectEndPoint(String, Nullable&lt;UInt16&gt;)​ Declaration​ public override IEndPoint GetConnectEndPoint(string address = null, ushort? port = default(ushort? ))  Parameters​ Type\tName\tDescriptionSystem.String\taddress System.Nullable&lt;System.UInt16&gt;\tport\t Returns​ Type\tDescriptionMirage.SocketLayer.IEndPoint\t "},{"title":"Mirage","type":0,"sectionRef":"#","url":"docs/reference/Mirage/","content":"","keywords":""},{"title":"Classes​","type":1,"pageTitle":"Mirage","url":"docs/reference/Mirage/#classes","content":"Channel​ CharacterSpawner​ Spawns a player as soon as the connection is authenticated ClientAttribute​ Prevents this method from running if client is not active. Can only be used inside a NetworkBehaviour ClientObjectManager​ ClientRpcAttribute​ The server uses a Remote Procedure Call (RPC) to run this function on specific clients. Note that if you set the target as Connection, you need to pass a specific connection as a parameter of your method DeserializeFailedException​ ExponentialMovingAverage​ FoldoutEventAttribute​ Draws UnityEvent as a foldout GameObjectSerializers​ GameobjectExtension​ HasAuthorityAttribute​ Prevents players without authority from running this method. Can only be used inside a NetworkBehaviour HeadlessAutoStart​ HeadlessFrameLimiter​ LobbyReady​ LocalPlayerAttribute​ Prevents nonlocal players from running this method. Can only be used inside a NetworkBehaviour MessageHandler​ MethodInvocationException​ Exception thrown if a guarded method is invoked incorrectly NetworkAnimator​ A component to synchronize animation states for networked objects. NetworkAuthenticator​ Base class for implementing component-based authentication during the Connect phase NetworkBehaviorSerializers​ NetworkBehaviour​ Base class which should be inherited by scripts which contain networking functionality. NetworkClient​ This is a network client class used by the networking system. It contains a NetworkConnection that is used to connect to a network server. The handle connection state, messages handlers, and connection configuration. There can be many instances in a process at a time, but only one that is connected to a game server () that uses spawned objects. has an internal update function where it handles events from the transport layer. This includes asynchronous connect events, disconnect events and incoming data from a server. NetworkDiagnostics​ Provides profiling information from mirror A profiler can subscribe to these events and present the data in a friendly way to the user NetworkIdentity​ The NetworkIdentity identifies objects across the network, between server and clients. Its primary data is a NetworkInstanceId which is allocated by the server and then set on clients. This is used in network communications to be able to lookup game objects on different machines. NetworkIdentitySerializers​ NetworkManager​ NetworkManagerGUI​ NetworkManagerHud​ NetworkMatchChecker​ Component that controls visibility of networked objects based on match id. Any object with this component on it will only be visible to other objects in the same match. This would be used to isolate players to their respective matches within a single game server instance. NetworkMessageAttribute​ Tell the weaver to generate reader and writer for a class NetworkPingDisplay​ Component that will display the clients ping in milliseconds NetworkPlayer​ A High level network connection. This is used for connections from client-to-server and for connection from server-to-client. NetworkProximityChecker​ Component that controls visibility of networked objects for players. Any object with this component on it will not be visible to players more than a (configurable) distance away. NetworkSceneChecker​ Component that controls visibility of networked objects between scenes. Any object with this component on it will only be visible to other objects in the same scene This would be used when the server has multiple additive subscenes loaded to isolate players to their respective subscenes NetworkSceneManager​ NetworkSceneManager is an optional component that helps keep scene in sync between server and client. The loads scenes as instructed by the . The controls the currently active Scene and any additive Load/Unload. when a client connect NetworkSceneManager will send a message telling the new client to load the scene that is active on the server NetworkServer​ The NetworkServer. NetworkTime​ Synchronize time between the server and the clients NetworkTransform​ NetworkTransformBase​ NetworkTransformBase.DataPoint​ NetworkTransformChild​ A component to synchronize the position of child transforms of networked objects. There must be a NetworkTransform on the root object of the hierarchy. There can be multiple NetworkTransformChild components on an object. This does not use physics for synchronization, it simply synchronizes the localPosition and localRotation of the child transform and lerps towards the received values. NetworkVisibility​ NetworkWorld​ Holds collection of spawned network objects This class works on both server and client ObjectReady​ OnlineOfflineScene​ PipePeerConnection​ A that is directly sends data to a PipePeerConnection.PipeEndPoint​ PlayerSceneChangeEvent​ ReadOnlyInspectorAttribute​ Makes field readonly in inspector. This is useful for fields that are set by code, but are shown iin inpector for debuggiing SceneAttribute​ Converts a string property into a Scene property in the inspector SceneChangeFinishedEvent​ Event fires from INetworkSceneManager when a scene change finishes on either Server or Client. Scene - Loaded scene SceneOperation - Scene change type (Normal, Additive Load, Additive Unload). SceneChangeStartedEvent​ Event fires from INetworkSceneManager when a scene change begins on either Server or Client. Scene - Name or path of the scene that's about to be loaded SceneOperation - Scene change type (Normal, Additive Load, Additive Unload). SceneVisibilityChecker​ ServerAttribute​ Prevents a method from running if server is not active. Can only be used inside a NetworkBehaviour ServerObjectManager​ The ServerObjectManager. ServerRpcAttribute​ Call this from a client to run this function on the server. Make sure to validate input etc. It's not possible to call this from a server. ShowInInspectorAttribute​ Used to show private SyncList in the inspector, Use instead of SerializeField for non Serializable types SpawnEvent​ SpawnHandler​ SpawnObjectException​ Exception thrown when spawning fails StringHash​ SyncVarAttribute​ SyncVars are used to synchronize a variable from the server to all clients automatically. Value must be changed on server, not directly by clients. Hook parameter allows you to define a client-side method to be invoked when the client gets an update from the server. SyncVarReceiver​ Class that handles syncvar message and passes it to correct SyncVarSender​ Class that Syncs syncvar and other State Version​ "},{"title":"Structs​","type":1,"pageTitle":"Mirage","url":"docs/reference/Mirage/#structs","content":"AddCharacterMessage​ GameObjectSyncvar​ backing struct for a NetworkIdentity when used as a syncvar the weaver will replace the syncvar with this struct. NetworkBehaviorSyncvar​ backing struct for a NetworkIdentity when used as a syncvar the weaver will replace the syncvar with this struct. NetworkBehaviour.Id​ NetworkDiagnostics.MessageInfo​ Describes an outgoing message NetworkIdentity.TransformSpawnSettings​ NetworkIdentitySyncvar​ backing struct for a NetworkIdentity when used as a syncvar the weaver will replace the syncvar with this struct. NetworkPingMessage​ NetworkPongMessage​ ObjectDestroyMessage​ ObjectHideMessage​ PipePeerConnection.PipeNotifyToken​ Token that invokes immediately RemoveAuthorityMessage​ RemoveCharacterMessage​ RpcMessage​ SceneMessage​ SceneNotReadyMessage​ Sent to client to mark their scene as not ready Client can sent once its scene is ready again SceneReadyMessage​ Sent to indicate the scene is finished loading ServerRpcMessage​ ServerRpcReply​ ServerRpcWithReplyMessage​ SpawnMessage​ UpdateVarsMessage​ "},{"title":"Interfaces​","type":1,"pageTitle":"Mirage","url":"docs/reference/Mirage/#interfaces","content":"IAuthenticatedObject​ IMessageReceiver​ An object that can receive messages IMessageSender​ An object that can send messages INetIdGenerator​ INetworkPlayer​ An object owned by a player that can: send/receive messages, have network visibility, be an object owner, authenticated permissions, and load scenes. May be from the server to client or from client to server IObjectLocator​ An object that implements this interface can find objects by their net id This is used by readers when trying to deserialize gameobjects IObjectOwner​ An object that can own networked objects ISceneLoader​ IVisibilityTracker​ An object that can observe NetworkIdentities. this is useful for interest management "},{"title":"Enums​","type":1,"pageTitle":"Mirage","url":"docs/reference/Mirage/#enums","content":"CharacterSpawner.PlayerSpawnMethod​ Enumeration of methods of where to spawn player objects in multiplayer games. ClientStoppedReason​ Reason why Client was stopped or disconnected ConnectState​ NetworkManagerMode​ RpcTarget​ Used by ClientRpc to tell mirage who to send remote call to SceneOperation​ SyncHookType​ SyncMode​ Sync to everyone, or only to owner. "},{"title":"Delegates​","type":1,"pageTitle":"Mirage","url":"docs/reference/Mirage/#delegates","content":"DynamicSpawnHandlerDelegate​ MessageDelegate&lt;T&gt;​ MessageDelegateWithPlayer&lt;T&gt;​ SpawnHandlerAsyncDelegate​ SpawnHandlerDelegate​ UnSpawnDelegate​ "},{"title":"Struct AddCharacterMessage","type":0,"sectionRef":"#","url":"docs/reference/Mirage/AddCharacterMessage","content":"Struct AddCharacterMessage Syntax​ public struct AddCharacterMessage ","keywords":""},{"title":"Class Channel","type":0,"sectionRef":"#","url":"docs/reference/Mirage/Channel","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class Channel","url":"docs/reference/Mirage/Channel#fields","content":"Reliable​ Declaration​ public const int Reliable = 0  Unreliable​ Declaration​ public const int Unreliable = 1  "},{"title":"Class CharacterSpawner","type":0,"sectionRef":"#","url":"docs/reference/Mirage/CharacterSpawner","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class CharacterSpawner","url":"docs/reference/Mirage/CharacterSpawner#fields","content":"Client​ Declaration​ public NetworkClient Client  Server​ Declaration​ public NetworkServer Server  SceneManager​ Declaration​ public NetworkSceneManager SceneManager  ClientObjectManager​ Declaration​ public ClientObjectManager ClientObjectManager  ServerObjectManager​ Declaration​ public ServerObjectManager ServerObjectManager  PlayerPrefab​ Declaration​ public NetworkIdentity PlayerPrefab  AutoSpawn​ Whether to span the player upon connection automatically Declaration​ public bool AutoSpawn  startPositionIndex​ Declaration​ public int startPositionIndex  startPositions​ List of transforms where players can be spawned Declaration​ public List&lt;Transform&gt; startPositions  playerSpawnMethod​ The current method of spawning players used by the CharacterSpawner. Declaration​ public CharacterSpawner.PlayerSpawnMethod playerSpawnMethod  "},{"title":"Methods​","type":1,"pageTitle":"Class CharacterSpawner","url":"docs/reference/Mirage/CharacterSpawner#methods","content":"Awake()​ Declaration​ public virtual void Awake()  OnClientFinishedSceneChange(Scene, SceneOperation)​ Called on the client when a normal scene change happens. The default implementation of this function sets the client as ready and adds a player. Override the function to dictate what happens when the client connects. Declaration​ public virtual void OnClientFinishedSceneChange(Scene scene, SceneOperation sceneOperation)  Parameters​ Type\tName\tDescriptionScene\tscene Mirage.SceneOperation\tsceneOperation\tThe type of scene load that happened. RequestServerSpawnPlayer()​ Declaration​ public virtual void RequestServerSpawnPlayer()  OnServerAddPlayer(INetworkPlayer)​ Called on the server when a client adds a new player with ClientScene.AddPlayer. The default implementation for this function creates a new player object from the playerPrefab. Declaration​ public virtual void OnServerAddPlayer(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tConnection from client. SetCharacterName(INetworkPlayer, NetworkIdentity)​ Declaration​ protected virtual void SetCharacterName(INetworkPlayer player, NetworkIdentity character)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer Mirage.NetworkIdentity\tcharacter\t GetStartPosition()​ This finds a spawn position based on start position objects in the scene. This is used by the default implementation of OnServerAddPlayer. Declaration​ public virtual Transform GetStartPosition()  Returns​ Type\tDescriptionTransform\tReturns the transform to spawn a player at, or null. "},{"title":"Enum CharacterSpawner.PlayerSpawnMethod","type":0,"sectionRef":"#","url":"docs/reference/Mirage/CharacterSpawner.PlayerSpawnMethod","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Enum CharacterSpawner.PlayerSpawnMethod","url":"docs/reference/Mirage/CharacterSpawner.PlayerSpawnMethod#fields","content":"Random​ Declaration​ Random = 0  RoundRobin​ Declaration​ RoundRobin = 1  "},{"title":"Class ClientAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage/ClientAttribute","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class ClientAttribute","url":"docs/reference/Mirage/ClientAttribute#fields","content":"error​ If true, when the method is called from a client, it throws an error If false, no error is thrown, but the method won't execute useful for unity built in methods such as Await, Update, Start, etc. Declaration​ public bool error  "},{"title":"Class ClientRpcAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage/ClientRpcAttribute","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class ClientRpcAttribute","url":"docs/reference/Mirage/ClientRpcAttribute#fields","content":"channel​ Declaration​ public int channel  target​ Declaration​ public RpcTarget target  excludeOwner​ Declaration​ public bool excludeOwner  "},{"title":"Class ClientObjectManager","type":0,"sectionRef":"#","url":"docs/reference/Mirage/ClientObjectManager","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class ClientObjectManager","url":"docs/reference/Mirage/ClientObjectManager#fields","content":"Client​ Declaration​ public NetworkClient Client  NetworkSceneManager​ Declaration​ public NetworkSceneManager NetworkSceneManager  spawnPrefabs​ List of prefabs that will be registered with the spawning system. For each of these prefabs, ClientManager.RegisterPrefab() will be automatically invoke. Declaration​ public List&lt;NetworkIdentity&gt; spawnPrefabs  spawnableObjects​ This is dictionary of the disabled NetworkIdentity objects in the scene that could be spawned by messages from the server. The key to the dictionary is the NetworkIdentity sceneId. Declaration​ public readonly Dictionary&lt;ulong, NetworkIdentity&gt; spawnableObjects  "},{"title":"Methods​","type":1,"pageTitle":"Class ClientObjectManager","url":"docs/reference/Mirage/ClientObjectManager#methods","content":"Start()​ Declaration​ public void Start()  PrepareToSpawnSceneObjects()​ Call this after loading/unloading a scene in the client after connection to register the spawnable objects Declaration​ public void PrepareToSpawnSceneObjects()  GetPrefab(Int32)​ Find the registered prefab for this asset id. Useful for debuggers Declaration​ [Obsolete(&quot;use GetSpawnHandler instead&quot;)] public NetworkIdentity GetPrefab(int prefabHash)  Parameters​ Type\tName\tDescriptionSystem.Int32\tprefabHash\tasset id of the prefab Returns​ Type\tDescriptionMirage.NetworkIdentity\ttrue if prefab was registered GetSpawnHandler(Int32)​ Find the registered or dynamic handler for prefabHash Useful for debuggers Declaration​ public SpawnHandler GetSpawnHandler(int prefabHash)  Parameters​ Type\tName\tDescriptionSystem.Int32\tprefabHash\tasset id of the prefab Returns​ Type\tDescriptionMirage.SpawnHandler\ttrue if prefab was registered RegisterPrefab(NetworkIdentity, Int32)​ Registers a prefab with the spawning system. When a NetworkIdentity object is spawned on the server with ServerObjectManager.Spawn(), the server will send a spawn message to the client with the PrefabHash. the client then finds the prefab registered with RegisterPrefab() to instantiate the client object. The ClientObjectManager has a list of spawnable prefabs, it uses this function to register those prefabs with the ClientScene. The set of current spawnable object is available in the ClientScene static member variable ClientScene.prefabs, which is a dictionary of PrefabHash and prefab references. Declaration​ public void RegisterPrefab(NetworkIdentity identity, int newPrefabHash)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tidentity\tA Prefab that will be spawned. System.Int32\tnewPrefabHash\tA hash to be assigned to this prefab. This allows a dynamically created game object to be registered for an already known asset Id. RegisterPrefab(NetworkIdentity)​ Registers a prefab with the spawning system. When a NetworkIdentity object is spawned on the server with ServerObjectManager.Spawn(), the server will send a spawn message to the client with the PrefabHash. the client then finds the prefab registered with RegisterPrefab() to instantiate the client object. The ClientObjectManager has a list of spawnable prefabs, it uses this function to register those prefabs with the ClientScene. The set of current spawnable object is available in the ClientScene static member variable ClientScene.prefabs, which is a dictionary of PrefabHash and prefab references. Declaration​ public void RegisterPrefab(NetworkIdentity identity)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tidentity\tA Prefab that will be spawned. RegisterUnspawnHandler(NetworkIdentity, UnSpawnDelegate)​ Registers an unspawn handler for a prefab Should be called after RegisterPrefab Declaration​ public void RegisterUnspawnHandler(NetworkIdentity identity, UnSpawnDelegate unspawnHandler)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tidentity\tPrefab to add handler for Mirage.UnSpawnDelegate\tunspawnHandler\tA method to use as a custom un-spawnhandler on clients. UnregisterPrefab(NetworkIdentity)​ Removes a registered spawn prefab that was setup with ClientScene.RegisterPrefab. Declaration​ public void UnregisterPrefab(NetworkIdentity identity)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tidentity\tThe prefab to be removed from registration. RegisterSpawnHandler(NetworkIdentity, SpawnHandlerDelegate, UnSpawnDelegate)​ Registers custom handlers for a prefab with the spawning system. When a NetworkIdentity object is spawned on the server with ServerObjectManager.Spawn(), the server will send a spawn message to the client with the PrefabHash. the client then finds the prefab registered with RegisterPrefab() to instantiate the client object. The ClientObjectManager has a list of spawnable prefabs, it uses this function to register those prefabs with the ClientScene. The set of current spawnable object is available in the ClientScene static member variable ClientScene.prefabs, which is a dictionary of PrefabHash and prefab references. Declaration​ public void RegisterSpawnHandler(NetworkIdentity identity, SpawnHandlerDelegate spawnHandler, UnSpawnDelegate unspawnHandler)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tidentity\tA Prefab that will be spawned. Mirage.SpawnHandlerDelegate\tspawnHandler\tA method to use as a custom spawnhandler on clients. Mirage.UnSpawnDelegate\tunspawnHandler\tA method to use as a custom un-spawnhandler on clients. RegisterSpawnHandler(Int32, SpawnHandlerDelegate, UnSpawnDelegate)​ This is an advanced spawning function that registers a custom prefabHash with the UNET spawning system. This can be used to register custom spawning methods for an prefabHash - instead of the usual method of registering spawning methods for a prefab. This should be used when no prefab exists for the spawned objects - such as when they are constructed dynamically at runtime from configuration data. Declaration​ public void RegisterSpawnHandler(int prefabHash, SpawnHandlerDelegate spawnHandler, UnSpawnDelegate unspawnHandler)  Parameters​ Type\tName\tDescriptionSystem.Int32\tprefabHash Mirage.SpawnHandlerDelegate\tspawnHandler\tA method to use as a custom spawnhandler on clients. Mirage.UnSpawnDelegate\tunspawnHandler\tA method to use as a custom un-spawnhandler on clients. RegisterSpawnHandler(NetworkIdentity, SpawnHandlerAsyncDelegate, UnSpawnDelegate)​ Declaration​ public void RegisterSpawnHandler(NetworkIdentity identity, SpawnHandlerAsyncDelegate spawnHandler, UnSpawnDelegate unspawnHandler)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tidentity Mirage.SpawnHandlerAsyncDelegate\tspawnHandler Mirage.UnSpawnDelegate\tunspawnHandler\t RegisterSpawnHandler(Int32, SpawnHandlerAsyncDelegate, UnSpawnDelegate)​ Declaration​ public void RegisterSpawnHandler(int prefabHash, SpawnHandlerAsyncDelegate spawnHandler, UnSpawnDelegate unspawnHandler)  Parameters​ Type\tName\tDescriptionSystem.Int32\tprefabHash Mirage.SpawnHandlerAsyncDelegate\tspawnHandler Mirage.UnSpawnDelegate\tunspawnHandler\t UnregisterSpawnHandler(Int32)​ Removes a registered spawn handler function that was registered with ClientScene.RegisterHandler(). Declaration​ public void UnregisterSpawnHandler(int prefabHash)  Parameters​ Type\tName\tDescriptionSystem.Int32\tprefabHash\tThe prefabHash for the handler to be removed for. ClearSpawners()​ This clears the registered spawn prefabs and spawn handler functions for this client. Declaration​ public void ClearSpawners()  RegisterDynamicSpawnHandler(DynamicSpawnHandlerDelegate)​ Declaration​ public void RegisterDynamicSpawnHandler(DynamicSpawnHandlerDelegate dynamicHandler)  Parameters​ Type\tName\tDescriptionMirage.DynamicSpawnHandlerDelegate\tdynamicHandler\t DestroyAllClientObjects()​ Destroys all networked objects on the client. This can be used to clean up when a network connection is closed. Declaration​ public void DestroyAllClientObjects()  "},{"title":"Enum ClientStoppedReason","type":0,"sectionRef":"#","url":"docs/reference/Mirage/ClientStoppedReason","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Enum ClientStoppedReason","url":"docs/reference/Mirage/ClientStoppedReason#fields","content":"None​ No reason given Declaration​ None = 0  Timeout​ Connecting timed out Server not sending replies Declaration​ Timeout = 1  LocalConnectionClosed​ Connection disconnect called locally Declaration​ LocalConnectionClosed = 2  RemoteConnectionClosed​ Connection disconnect called on server Declaration​ RemoteConnectionClosed = 3  InvalidPacket​ Server disconnected because sent packet was not allowed by server config Declaration​ InvalidPacket = 8  ServerFull​ Server rejected connecting because it was full Declaration​ ServerFull = 4  ConnectingTimeout​ Server did not reply Declaration​ ConnectingTimeout = 5  ConnectingCancel​ Disconnect called locally before server replies with connected Declaration​ ConnectingCancel = 6  KeyInvalid​ Key given with first message did not match the value on the server, See SocketLayer Config Declaration​ KeyInvalid = 9  HostModeStopped​ Disconnect called when server was stopped in host mode Declaration​ HostModeStopped = 7  "},{"title":"Enum ConnectState","type":0,"sectionRef":"#","url":"docs/reference/Mirage/ConnectState","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Enum ConnectState","url":"docs/reference/Mirage/ConnectState#fields","content":"Disconnected​ Declaration​ Disconnected = 0  Connecting​ Declaration​ Connecting = 1  Connected​ Declaration​ Connected = 2  "},{"title":"Class DeserializeFailedException","type":0,"sectionRef":"#","url":"docs/reference/Mirage/DeserializeFailedException","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class DeserializeFailedException","url":"docs/reference/Mirage/DeserializeFailedException#constructors","content":"DeserializeFailedException(String)​ Declaration​ public DeserializeFailedException(string message)  Parameters​ Type\tName\tDescriptionSystem.String\tmessage\t DeserializeFailedException(SerializationInfo, StreamingContext)​ Declaration​ protected DeserializeFailedException(SerializationInfo info, StreamingContext context)  Parameters​ Type\tName\tDescriptionSystem.Runtime.Serialization.SerializationInfo\tinfo System.Runtime.Serialization.StreamingContext\tcontext\t "},{"title":"Delegate DynamicSpawnHandlerDelegate","type":0,"sectionRef":"#","url":"docs/reference/Mirage/DynamicSpawnHandlerDelegate","content":"Delegate DynamicSpawnHandlerDelegate Syntax​ public delegate SpawnHandler DynamicSpawnHandlerDelegate(int prefabHash); ","keywords":""},{"title":"Class ExponentialMovingAverage","type":0,"sectionRef":"#","url":"docs/reference/Mirage/ExponentialMovingAverage","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class ExponentialMovingAverage","url":"docs/reference/Mirage/ExponentialMovingAverage#constructors","content":"ExponentialMovingAverage(Int32)​ Declaration​ public ExponentialMovingAverage(int n)  Parameters​ Type\tName\tDescriptionSystem.Int32\tn\t "},{"title":"Properties​","type":1,"pageTitle":"Class ExponentialMovingAverage","url":"docs/reference/Mirage/ExponentialMovingAverage#properties","content":"Value​ Declaration​ public double Value { get; }  Var​ Declaration​ public double Var { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class ExponentialMovingAverage","url":"docs/reference/Mirage/ExponentialMovingAverage#methods","content":"Reset()​ Declaration​ public void Reset()  Add(Double)​ Declaration​ public void Add(double newValue)  Parameters​ Type\tName\tDescriptionSystem.Double\tnewValue\t "},{"title":"Class FoldoutEventAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage/FoldoutEventAttribute","content":"Class FoldoutEventAttribute Draws UnityEvent as a foldout Inheritance​ System.Object Syntax​ [AttributeUsage(AttributeTargets.Field)] public sealed class FoldoutEventAttribute : PropertyAttribute ","keywords":""},{"title":"Class GameobjectExtension","type":0,"sectionRef":"#","url":"docs/reference/Mirage/GameobjectExtension","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class GameobjectExtension","url":"docs/reference/Mirage/GameobjectExtension#methods","content":"GetNetworkIdentity(GameObject)​ Gets on a and throws if the GameObject does not have one. Declaration​ public static NetworkIdentity GetNetworkIdentity(this GameObject gameObject)  Parameters​ Type\tName\tDescriptionGameObject\tgameObject\t Returns​ Type\tDescriptionMirage.NetworkIdentity\tattached NetworkIdentity "},{"title":"Class GameObjectSerializers","type":0,"sectionRef":"#","url":"docs/reference/Mirage/GameObjectSerializers","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class GameObjectSerializers","url":"docs/reference/Mirage/GameObjectSerializers#methods","content":"WriteGameObjectSyncVar(NetworkWriter, GameObjectSyncvar)​ Declaration​ public static void WriteGameObjectSyncVar(this NetworkWriter writer, GameObjectSyncvar id)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Mirage.GameObjectSyncvar\tid\t ReadGameObjectSyncVar(NetworkReader)​ Declaration​ public static GameObjectSyncvar ReadGameObjectSyncVar(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionMirage.GameObjectSyncvar\t "},{"title":"Struct GameObjectSyncvar","type":0,"sectionRef":"#","url":"docs/reference/Mirage/GameObjectSyncvar","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Struct GameObjectSyncvar","url":"docs/reference/Mirage/GameObjectSyncvar#properties","content":"Value​ Declaration​ public GameObject Value { get; set; }  "},{"title":"Class HasAuthorityAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage/HasAuthorityAttribute","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class HasAuthorityAttribute","url":"docs/reference/Mirage/HasAuthorityAttribute#fields","content":"error​ If true, when the method is called from a client, it throws an error If false, no error is thrown, but the method won't execute useful for unity built in methods such as Await, Update, Start, etc. Declaration​ public bool error  "},{"title":"Class HeadlessAutoStart","type":0,"sectionRef":"#","url":"docs/reference/Mirage/HeadlessAutoStart","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class HeadlessAutoStart","url":"docs/reference/Mirage/HeadlessAutoStart#fields","content":"Server​ Declaration​ public NetworkServer Server  startOnHeadless​ Automatically invoke StartServer() If the application is a Server Build or run with the -batchMode ServerRpc line argument, StartServer is automatically invoked. Declaration​ public bool startOnHeadless  "},{"title":"Class HeadlessFrameLimiter","type":0,"sectionRef":"#","url":"docs/reference/Mirage/HeadlessFrameLimiter","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class HeadlessFrameLimiter","url":"docs/reference/Mirage/HeadlessFrameLimiter#fields","content":"serverTickRate​ Server Update frequency, per second. Use around 60Hz for fast paced games like Counter-Strike to minimize latency. Use around 30Hz for games like WoW to minimize computations. Use around 1-10Hz for slow paced games like EVE. Declaration​ public int serverTickRate  "},{"title":"Methods​","type":1,"pageTitle":"Class HeadlessFrameLimiter","url":"docs/reference/Mirage/HeadlessFrameLimiter#methods","content":"Start()​ Set the frame rate for a headless server. Declaration​ public void Start()  "},{"title":"Interface IAuthenticatedObject","type":0,"sectionRef":"#","url":"docs/reference/Mirage/IAuthenticatedObject","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Interface IAuthenticatedObject","url":"docs/reference/Mirage/IAuthenticatedObject#properties","content":"IsAuthenticated​ Marks if this player has been accepted by a Declaration​ bool IsAuthenticated { get; set; }  AuthenticationData​ General purpose object to hold authentication data, character selection, tokens, etc. associated with the connection for reference after Authentication completes. Declaration​ object AuthenticationData { get; set; }  "},{"title":"Interface IMessageReceiver","type":0,"sectionRef":"#","url":"docs/reference/Mirage/IMessageReceiver","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Interface IMessageReceiver","url":"docs/reference/Mirage/IMessageReceiver#methods","content":"RegisterHandler&lt;T&gt;(MessageDelegateWithPlayer&lt;T&gt;)​ Declaration​ void RegisterHandler&lt;T&gt;(MessageDelegateWithPlayer&lt;T&gt; handler)  Parameters​ Type\tName\tDescriptionMirage.MessageDelegateWithPlayer&lt;T&gt;\thandler\t RegisterHandler&lt;T&gt;(MessageDelegate&lt;T&gt;)​ Declaration​ void RegisterHandler&lt;T&gt;(MessageDelegate&lt;T&gt; handler)  Parameters​ Type\tName\tDescriptionMirage.MessageDelegate&lt;T&gt;\thandler\t UnregisterHandler&lt;T&gt;()​ Declaration​ void UnregisterHandler&lt;T&gt;()  ClearHandlers()​ Declaration​ void ClearHandlers()  HandleMessage(INetworkPlayer, ArraySegment&lt;Byte&gt;)​ Declaration​ void HandleMessage(INetworkPlayer player, ArraySegment&lt;byte&gt; packet)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer System.ArraySegment&lt;System.Byte&gt;\tpacket\t "},{"title":"Interface IMessageSender","type":0,"sectionRef":"#","url":"docs/reference/Mirage/IMessageSender","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Interface IMessageSender","url":"docs/reference/Mirage/IMessageSender#methods","content":"Send&lt;T&gt;(T, Int32)​ Declaration​ void Send&lt;T&gt;(T message, int channelId = 0)  Parameters​ Type\tName\tDescriptionT\tmessage System.Int32\tchannelId\t Send(ArraySegment&lt;Byte&gt;, Int32)​ Declaration​ void Send(ArraySegment&lt;byte&gt; segment, int channelId = 0)  Parameters​ Type\tName\tDescriptionSystem.ArraySegment&lt;System.Byte&gt;\tsegment System.Int32\tchannelId\t Send&lt;T&gt;(T, INotifyCallBack)​ Declaration​ void Send&lt;T&gt;(T message, INotifyCallBack notifyCallBack)  Parameters​ Type\tName\tDescriptionT\tmessage Mirage.SocketLayer.INotifyCallBack\tnotifyCallBack\t "},{"title":"Interface INetIdGenerator","type":0,"sectionRef":"#","url":"docs/reference/Mirage/INetIdGenerator","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Interface INetIdGenerator","url":"docs/reference/Mirage/INetIdGenerator#methods","content":"GenerateNetId()​ Generate your own specific net id. Declaration​ uint GenerateNetId()  Returns​ Type\tDescriptionSystem.UInt32\t "},{"title":"Interface IObjectLocator","type":0,"sectionRef":"#","url":"docs/reference/Mirage/IObjectLocator","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Interface IObjectLocator","url":"docs/reference/Mirage/IObjectLocator#methods","content":"TryGetIdentity(UInt32, out NetworkIdentity)​ Finds a network identity by id Declaration​ bool TryGetIdentity(uint netId, out NetworkIdentity identity)  Parameters​ Type\tName\tDescriptionSystem.UInt32\tnetId\tthe id of the object to find Mirage.NetworkIdentity\tidentity\tThe NetworkIdentity matching the netId or null if none is found Returns​ Type\tDescriptionSystem.Boolean\ttrue if identity is found and is not null "},{"title":"Interface INetworkPlayer","type":0,"sectionRef":"#","url":"docs/reference/Mirage/INetworkPlayer","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Interface INetworkPlayer","url":"docs/reference/Mirage/INetworkPlayer#properties","content":"Address​ Declaration​ IEndPoint Address { get; }  Connection​ Declaration​ IConnection Connection { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Interface INetworkPlayer","url":"docs/reference/Mirage/INetworkPlayer#methods","content":"Disconnect()​ Declaration​ void Disconnect()  MarkAsDisconnected()​ Declaration​ void MarkAsDisconnected()  "},{"title":"Interface ISceneLoader","type":0,"sectionRef":"#","url":"docs/reference/Mirage/ISceneLoader","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Interface ISceneLoader","url":"docs/reference/Mirage/ISceneLoader#properties","content":"SceneIsReady​ Scene is fully loaded and we now can do things with player. Declaration​ bool SceneIsReady { get; set; }  "},{"title":"Interface IObjectOwner","type":0,"sectionRef":"#","url":"docs/reference/Mirage/IObjectOwner","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Interface IObjectOwner","url":"docs/reference/Mirage/IObjectOwner#properties","content":"Identity​ Declaration​ NetworkIdentity Identity { get; set; }  HasCharacter​ Declaration​ bool HasCharacter { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Interface IObjectOwner","url":"docs/reference/Mirage/IObjectOwner#methods","content":"RemoveOwnedObject(NetworkIdentity)​ Declaration​ void RemoveOwnedObject(NetworkIdentity networkIdentity)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tnetworkIdentity\t AddOwnedObject(NetworkIdentity)​ Declaration​ void AddOwnedObject(NetworkIdentity networkIdentity)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tnetworkIdentity\t DestroyOwnedObjects()​ Declaration​ void DestroyOwnedObjects()  "},{"title":"Interface IVisibilityTracker","type":0,"sectionRef":"#","url":"docs/reference/Mirage/IVisibilityTracker","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Interface IVisibilityTracker","url":"docs/reference/Mirage/IVisibilityTracker#properties","content":"VisList​ HashSet of all that this player can see Only valid on server Reverse collection for Declaration​ IReadOnlyCollection&lt;NetworkIdentity&gt; VisList { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Interface IVisibilityTracker","url":"docs/reference/Mirage/IVisibilityTracker#methods","content":"AddToVisList(NetworkIdentity)​ Called when sending spawn message to client Declaration​ void AddToVisList(NetworkIdentity identity)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tidentity\t RemoveFromVisList(NetworkIdentity)​ Called when sending destroy message to client Declaration​ void RemoveFromVisList(NetworkIdentity identity)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tidentity\t RemoveAllVisibleObjects()​ Removes all that this player can see This is called when loading a new scene Declaration​ void RemoveAllVisibleObjects()  ContainsInVisList(NetworkIdentity)​ Checks if player can see Declaration​ bool ContainsInVisList(NetworkIdentity identity)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tidentity\t Returns​ Type\tDescriptionSystem.Boolean\t "},{"title":"Class LobbyReady","type":0,"sectionRef":"#","url":"docs/reference/Mirage/LobbyReady","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class LobbyReady","url":"docs/reference/Mirage/LobbyReady#fields","content":"ObjectReadyList​ Declaration​ public List&lt;ObjectReady&gt; ObjectReadyList  "},{"title":"Methods​","type":1,"pageTitle":"Class LobbyReady","url":"docs/reference/Mirage/LobbyReady#methods","content":"SetAllClientsNotReady()​ Declaration​ public void SetAllClientsNotReady()  SendToReady&lt;T&gt;(NetworkIdentity, T, Boolean, Int32)​ Declaration​ public void SendToReady&lt;T&gt;(NetworkIdentity identity, T msg, bool includeOwner = true, int channelId = 0)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tidentity T\tmsg System.Boolean\tincludeOwner System.Int32\tchannelId\t "},{"title":"Class LocalPlayerAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage/LocalPlayerAttribute","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class LocalPlayerAttribute","url":"docs/reference/Mirage/LocalPlayerAttribute#fields","content":"error​ If true, when the method is called from a client, it throws an error If false, no error is thrown, but the method won't execute useful for unity built in methods such as Await, Update, Start, etc. Declaration​ public bool error  "},{"title":"Delegate MessageDelegate<T>","type":0,"sectionRef":"#","url":"docs/reference/Mirage/MessageDelegate-1","content":"Delegate MessageDelegate&lt;T&gt; Syntax​ public delegate void MessageDelegate&lt;in T&gt;(T message); Type Parameters​ Name\tDescriptionT\t","keywords":""},{"title":"Delegate MessageDelegateWithPlayer<T>","type":0,"sectionRef":"#","url":"docs/reference/Mirage/MessageDelegateWithPlayer-1","content":"Delegate MessageDelegateWithPlayer&lt;T&gt; Syntax​ public delegate void MessageDelegateWithPlayer&lt;in T&gt;(INetworkPlayer player, T message); Type Parameters​ Name\tDescriptionT\t","keywords":""},{"title":"Class MessageHandler","type":0,"sectionRef":"#","url":"docs/reference/Mirage/MessageHandler","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class MessageHandler","url":"docs/reference/Mirage/MessageHandler#constructors","content":"MessageHandler(IObjectLocator, Boolean)​ Declaration​ public MessageHandler(IObjectLocator objectLocator, bool disconnectOnException)  Parameters​ Type\tName\tDescriptionMirage.IObjectLocator\tobjectLocator System.Boolean\tdisconnectOnException\t "},{"title":"Methods​","type":1,"pageTitle":"Class MessageHandler","url":"docs/reference/Mirage/MessageHandler#methods","content":"RegisterHandler&lt;T&gt;(MessageDelegateWithPlayer&lt;T&gt;)​ Register a handler for a particular message type. There are several system message types which you can add handlers for. You can also add your own message types. Declaration​ public void RegisterHandler&lt;T&gt;(MessageDelegateWithPlayer&lt;T&gt; handler)  Parameters​ Type\tName\tDescriptionMirage.MessageDelegateWithPlayer&lt;T&gt;\thandler\tFunction handler which will be invoked for when this message type is received. RegisterHandler&lt;T&gt;(MessageDelegate&lt;T&gt;)​ Register a handler for a particular message type. There are several system message types which you can add handlers for. You can also add your own message types. Declaration​ public void RegisterHandler&lt;T&gt;(MessageDelegate&lt;T&gt; handler)  Parameters​ Type\tName\tDescriptionMirage.MessageDelegate&lt;T&gt;\thandler\tFunction handler which will be invoked for when this message type is received. UnregisterHandler&lt;T&gt;()​ Unregister a handler for a particular message type. Note: Messages dont need to be unregister when server or client stops as MessageHandler will be re-created next time server or client starts Declaration​ public void UnregisterHandler&lt;T&gt;()  ClearHandlers()​ Clear all registered callback handlers. Declaration​ public void ClearHandlers()  HandleMessage(INetworkPlayer, ArraySegment&lt;Byte&gt;)​ Declaration​ public void HandleMessage(INetworkPlayer player, ArraySegment&lt;byte&gt; packet)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer System.ArraySegment&lt;System.Byte&gt;\tpacket\t LogAndCheckDisconnect(INetworkPlayer, Exception)​ Declaration​ public void LogAndCheckDisconnect(INetworkPlayer player, Exception e)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer System.Exception\te\t "},{"title":"Class MethodInvocationException","type":0,"sectionRef":"#","url":"docs/reference/Mirage/MethodInvocationException","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class MethodInvocationException","url":"docs/reference/Mirage/MethodInvocationException#constructors","content":"MethodInvocationException()​ Initializes a new instance of the class Declaration​ public MethodInvocationException()  MethodInvocationException(String)​ Initializes a new instance of the class Declaration​ public MethodInvocationException(string message)  Parameters​ Type\tName\tDescriptionSystem.String\tmessage\tA that describes the exception. MethodInvocationException(SerializationInfo, StreamingContext)​ Declaration​ protected MethodInvocationException(SerializationInfo info, StreamingContext context)  Parameters​ Type\tName\tDescriptionSystem.Runtime.Serialization.SerializationInfo\tinfo System.Runtime.Serialization.StreamingContext\tcontext\t "},{"title":"Class NetworkAnimator","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkAnimator","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkAnimator","url":"docs/reference/Mirage/NetworkAnimator#fields","content":"ClientAuthority​ Declaration​ public bool ClientAuthority  Animator​ The animator component to synchronize. Declaration​ public Animator Animator  "},{"title":"Methods​","type":1,"pageTitle":"Class NetworkAnimator","url":"docs/reference/Mirage/NetworkAnimator#methods","content":"OnSerialize(NetworkWriter, Boolean)​ Custom Serialization Declaration​ public override bool OnSerialize(NetworkWriter writer, bool initialState)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Boolean\tinitialState\t Returns​ Type\tDescriptionSystem.Boolean\t OnDeserialize(NetworkReader, Boolean)​ Custom Deserialization Declaration​ public override void OnDeserialize(NetworkReader reader, bool initialState)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader System.Boolean\tinitialState\t SetTrigger(String)​ Causes an animation trigger to be invoked for a networked object. If local authority is set, and this is called from the client, then the trigger will be invoked on the server and all clients. If not, then this is called on the server, and the trigger will be called on all clients. Declaration​ public void SetTrigger(string triggerName)  Parameters​ Type\tName\tDescriptionSystem.String\ttriggerName\tName of trigger. SetTrigger(Int32)​ Causes an animation trigger to be invoked for a networked object. Declaration​ public void SetTrigger(int hash)  Parameters​ Type\tName\tDescriptionSystem.Int32\thash\tHash id of trigger (from the Animator). ResetTrigger(String)​ Causes an animation trigger to be reset for a networked object. If local authority is set, and this is called from the client, then the trigger will be reset on the server and all clients. If not, then this is called on the server, and the trigger will be reset on all clients. Declaration​ public void ResetTrigger(string triggerName)  Parameters​ Type\tName\tDescriptionSystem.String\ttriggerName\tName of trigger. ResetTrigger(Int32)​ Causes an animation trigger to be reset for a networked object. Declaration​ public void ResetTrigger(int hash)  Parameters​ Type\tName\tDescriptionSystem.Int32\thash\tHash id of trigger (from the Animator). "},{"title":"Class NetworkAuthenticator","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkAuthenticator","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class NetworkAuthenticator","url":"docs/reference/Mirage/NetworkAuthenticator#methods","content":"ServerAccept(INetworkPlayer)​ Call this when player has been accepted on the server Declaration​ protected void ServerAccept(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\t ServerReject(INetworkPlayer)​ Call this when player has been rejected on the server. This will disconnect the player. Declaration​ protected void ServerReject(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\t ServerSetup(NetworkServer)​ Used to set up authenticator on server Can be used to register message handlers before any players connect Declaration​ public abstract void ServerSetup(NetworkServer server)  Parameters​ Type\tName\tDescriptionMirage.NetworkServer\tserver\t ServerAuthenticate(INetworkPlayer)​ Authenticate the player on the Server. Called by the server when new client connects Declaration​ public abstract void ServerAuthenticate(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\t ClientAccept(INetworkPlayer)​ Call this when player has been accepted on the client. Declaration​ protected void ClientAccept(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\t ClientReject(INetworkPlayer)​ Call this when player has been rejected on the client. This will disconnect the player. Declaration​ protected void ClientReject(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\t ClientSetup(NetworkClient)​ Used to set up authenticator on client Can be used to register message handlers before any player connects Declaration​ public abstract void ClientSetup(NetworkClient client)  Parameters​ Type\tName\tDescriptionMirage.NetworkClient\tclient\t ClientAuthenticate(INetworkPlayer)​ Authenticate the player on the Client. Called by the client after connected to the server Declaration​ public abstract void ClientAuthenticate(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\t "},{"title":"Class NetworkBehaviorSerializers","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkBehaviorSerializers","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class NetworkBehaviorSerializers","url":"docs/reference/Mirage/NetworkBehaviorSerializers#methods","content":"WriteNetworkBehaviorSyncVar(NetworkWriter, NetworkBehaviorSyncvar)​ Declaration​ public static void WriteNetworkBehaviorSyncVar(this NetworkWriter writer, NetworkBehaviorSyncvar id)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Mirage.NetworkBehaviorSyncvar\tid\t ReadNetworkBehaviourSyncVar(NetworkReader)​ Declaration​ public static NetworkBehaviorSyncvar ReadNetworkBehaviourSyncVar(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionMirage.NetworkBehaviorSyncvar\t "},{"title":"Struct NetworkBehaviorSyncvar","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkBehaviorSyncvar","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Struct NetworkBehaviorSyncvar","url":"docs/reference/Mirage/NetworkBehaviorSyncvar#properties","content":"Value​ Declaration​ public NetworkBehaviour Value { get; set; }  "},{"title":"Struct NetworkBehaviour.Id","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkBehaviour.Id","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Struct NetworkBehaviour.Id","url":"docs/reference/Mirage/NetworkBehaviour.Id#constructors","content":"Id(UInt32, Int32)​ Declaration​ public Id(uint netId, int componentIndex)  Parameters​ Type\tName\tDescriptionSystem.UInt32\tnetId System.Int32\tcomponentIndex\t Id(NetworkBehaviour)​ Declaration​ public Id(NetworkBehaviour behaviour)  Parameters​ Type\tName\tDescriptionMirage.NetworkBehaviour\tbehaviour\t "},{"title":"Fields​","type":1,"pageTitle":"Struct NetworkBehaviour.Id","url":"docs/reference/Mirage/NetworkBehaviour.Id#fields","content":"NetId​ Declaration​ public readonly uint NetId  ComponentIndex​ Declaration​ public readonly int ComponentIndex  "},{"title":"Methods​","type":1,"pageTitle":"Struct NetworkBehaviour.Id","url":"docs/reference/Mirage/NetworkBehaviour.Id#methods","content":"GetHashCode()​ Declaration​ public override int GetHashCode()  Returns​ Type\tDescriptionSystem.Int32\t Equals(NetworkBehaviour.Id)​ Declaration​ public bool Equals(NetworkBehaviour.Id other)  Parameters​ Type\tName\tDescriptionMirage.NetworkBehaviour.Id\tother\t Returns​ Type\tDescriptionSystem.Boolean\t Equals(Object)​ Declaration​ public override bool Equals(object obj)  Parameters​ Type\tName\tDescriptionSystem.Object\tobj\t Returns​ Type\tDescriptionSystem.Boolean\t "},{"title":"Class NetworkBehaviour","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkBehaviour","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class NetworkBehaviour","url":"docs/reference/Mirage/NetworkBehaviour#constructors","content":"NetworkBehaviour()​ Declaration​ protected NetworkBehaviour()  "},{"title":"Fields​","type":1,"pageTitle":"Class NetworkBehaviour","url":"docs/reference/Mirage/NetworkBehaviour#fields","content":"syncMode​ sync mode for OnSerialize Declaration​ public SyncMode syncMode  syncInterval​ sync interval for OnSerialize (in seconds) Declaration​ public float syncInterval  syncObjects​ objects that can synchronize themselves, such as synclists Declaration​ protected readonly List&lt;ISyncObject&gt; syncObjects  COMPONENT_INDEX_NOT_FOUND​ Declaration​ public const int COMPONENT_INDEX_NOT_FOUND = -1  RemoteCallCollection​ Collection that holds information about all RPC in this networkbehaviour (including derived classes) Can be used to get RPC name from its index NOTE: Weaver uses this collection to add rpcs, If adding your own rpc do at your own risk Declaration​ [NonSerialized] public readonly RemoteCallCollection RemoteCallCollection  "},{"title":"Properties​","type":1,"pageTitle":"Class NetworkBehaviour","url":"docs/reference/Mirage/NetworkBehaviour#properties","content":"IsServer​ Returns true if this object is active on an active server. This is only true if the object has been spawned. This is different from NetworkServer.active, which is true if the server itself is active rather than this object being active. Declaration​ public bool IsServer { get; }  IsClient​ Returns true if running as a client and this object was spawned by a server. Declaration​ public bool IsClient { get; }  IsLocalClient​ Returns true if we're on host mode. Declaration​ public bool IsLocalClient { get; }  IsLocalPlayer​ This returns true if this object is the one that represents the player on the local machine. In multiplayer games, there are multiple instances of the Player object. The client needs to know which one is for &quot;themselves&quot; so that only that player processes input and potentially has a camera attached. The IsLocalPlayer function will return true only for the player instance that belongs to the player on the local machine, so it can be used to filter out input for non-local players. Declaration​ public bool IsLocalPlayer { get; }  IsServerOnly​ True if this object only exists on the server Declaration​ public bool IsServerOnly { get; }  IsClientOnly​ True if this object exists on a client that is not also acting as a server Declaration​ public bool IsClientOnly { get; }  HasAuthority​ This returns true if this object is the authoritative version of the object in the distributed network application. The value on the NetworkIdentity determines how authority is determined. For most objects, authority is held by the server. For objects with set, authority is held by the client of that player. Declaration​ public bool HasAuthority { get; }  NetId​ The unique network Id of this object. This is assigned at runtime by the network server and will be unique for all objects for that network session. Declaration​ public uint NetId { get; }  Server​ The associated to this object. Declaration​ public NetworkServer Server { get; }  ServerObjectManager​ Quick Reference to the NetworkIdentities ServerObjectManager. Present only for server/host instances. Declaration​ public ServerObjectManager ServerObjectManager { get; }  Client​ The associated to this object. Declaration​ public NetworkClient Client { get; }  ClientObjectManager​ Quick Reference to the NetworkIdentities ClientObjectManager. Present only for instances instances. Declaration​ public ClientObjectManager ClientObjectManager { get; }  Owner​ The associated with this This is only valid for player objects on the server. Declaration​ public INetworkPlayer Owner { get; }  World​ Declaration​ public NetworkWorld World { get; }  NetworkTime​ Returns the appropriate NetworkTime instance based on if this NetworkBehaviour is running as a Server or Client. Declaration​ public NetworkTime NetworkTime { get; }  BehaviourId​ Get Id of this NetworkBehaviour, Its NetId and ComponentIndex Declaration​ public NetworkBehaviour.Id BehaviourId { get; }  SyncVarDirtyBits​ Declaration​ protected ulong SyncVarDirtyBits { get; }  Identity​ Returns the NetworkIdentity of this object Declaration​ public NetworkIdentity Identity { get; }  ComponentIndex​ Returns the index of the component on this object Declaration​ public int ComponentIndex { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class NetworkBehaviour","url":"docs/reference/Mirage/NetworkBehaviour#methods","content":"GetSyncVarHookGuard(UInt64)​ Declaration​ protected bool GetSyncVarHookGuard(ulong dirtyBit)  Parameters​ Type\tName\tDescriptionSystem.UInt64\tdirtyBit\t Returns​ Type\tDescriptionSystem.Boolean\t SetSyncVarHookGuard(UInt64, Boolean)​ Declaration​ protected void SetSyncVarHookGuard(ulong dirtyBit, bool value)  Parameters​ Type\tName\tDescriptionSystem.UInt64\tdirtyBit System.Boolean\tvalue\t InitSyncObject(ISyncObject)​ Declaration​ protected void InitSyncObject(ISyncObject syncObject)  Parameters​ Type\tName\tDescriptionMirage.Collections.ISyncObject\tsyncObject\t SyncVarEqual&lt;T&gt;(T, T)​ Declaration​ protected bool SyncVarEqual&lt;T&gt;(T value, T fieldValue)  Parameters​ Type\tName\tDescriptionT\tvalue T\tfieldValue\t Returns​ Type\tDescriptionSystem.Boolean\t SetDirtyBit(UInt64)​ Used to set the behaviour as dirty, so that a network update will be sent for the object. these are masks, not bit numbers, ie. 0x004 not 2 Declaration​ public void SetDirtyBit(ulong dirtyBit)  Parameters​ Type\tName\tDescriptionSystem.UInt64\tdirtyBit\tBit mask to set. ClearAllDirtyBits()​ This clears all the dirty bits that were set on this script by SetDirtyBits(); This is automatically invoked when an update is sent for this object, but can be called manually as well. Declaration​ public void ClearAllDirtyBits()  IsDirty()​ Declaration​ public bool IsDirty()  Returns​ Type\tDescriptionSystem.Boolean\t StillDirty()​ Declaration​ public bool StillDirty()  Returns​ Type\tDescriptionSystem.Boolean\t OnSerialize(NetworkWriter, Boolean)​ Virtual function to override to send custom serialization data. The corresponding function to send serialization data is OnDeserialize(). Declaration​ public virtual bool OnSerialize(NetworkWriter writer, bool initialState)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter\tWriter to use to write to the stream. System.Boolean\tinitialState\tIf this is being called to send initial state. Returns​ Type\tDescriptionSystem.Boolean\tTrue if data was written. OnDeserialize(NetworkReader, Boolean)​ Virtual function to override to receive custom serialization data. The corresponding function to send serialization data is OnSerialize(). Declaration​ public virtual void OnDeserialize(NetworkReader reader, bool initialState)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\tReader to read from the stream. System.Boolean\tinitialState\tTrue if being sent initial state. SerializeSyncVars(NetworkWriter, Boolean)​ Declaration​ public virtual bool SerializeSyncVars(NetworkWriter writer, bool initialState)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Boolean\tinitialState\t Returns​ Type\tDescriptionSystem.Boolean\t DeserializeSyncVars(NetworkReader, Boolean)​ Declaration​ public virtual void DeserializeSyncVars(NetworkReader reader, bool initialState)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader System.Boolean\tinitialState\t SerializeObjectsAll(NetworkWriter)​ Declaration​ public bool SerializeObjectsAll(NetworkWriter writer)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter\t Returns​ Type\tDescriptionSystem.Boolean\t SerializeObjectsDelta(NetworkWriter)​ Declaration​ public bool SerializeObjectsDelta(NetworkWriter writer)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter\t Returns​ Type\tDescriptionSystem.Boolean\t GetRpcCount()​ Declaration​ protected virtual int GetRpcCount()  Returns​ Type\tDescriptionSystem.Int32\t "},{"title":"Class NetworkClient","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkClient","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkClient","url":"docs/reference/Mirage/NetworkClient#fields","content":"EnablePeerMetrics​ Declaration​ public bool EnablePeerMetrics  MetricsSize​ Declaration​ public int MetricsSize  SocketFactory​ Declaration​ public SocketFactory SocketFactory  DisconnectOnException​ Declaration​ public bool DisconnectOnException  RunInBackground​ Declaration​ public bool RunInBackground  authenticator​ Declaration​ public NetworkAuthenticator authenticator  ManualUpdate​ Set to true if you want to manually call and and stop mirage from automatically calling them Declaration​ public bool ManualUpdate  "},{"title":"Properties​","type":1,"pageTitle":"Class NetworkClient","url":"docs/reference/Mirage/NetworkClient#properties","content":"Metrics​ Declaration​ public Metrics Metrics { get; }  PeerConfig​ Config for peer, if not set will use default settings Declaration​ public Config PeerConfig { get; set; }  Started​ Event fires when the client starts, before it has connected to the Server. Declaration​ public IAddLateEvent Started { get; }  Connected​ Event fires once the Client has connected its Server. Declaration​ public IAddLateEvent&lt;INetworkPlayer&gt; Connected { get; }  Authenticated​ Event fires after the Client connection has successfully been authenticated with its Server. Declaration​ public IAddLateEvent&lt;INetworkPlayer&gt; Authenticated { get; }  Disconnected​ Event fires after the Client has disconnected from its Server and Cleanup has been called. Declaration​ public IAddLateEvent&lt;ClientStoppedReason&gt; Disconnected { get; }  Player​ The NetworkConnection object this client is using. Declaration​ public INetworkPlayer Player { get; }  Active​ active is true while a client is connecting/connected (= while the network is active) Declaration​ public bool Active { get; }  IsConnected​ This gives the current connection status of the client. Declaration​ public bool IsConnected { get; }  World​ Declaration​ public NetworkWorld World { get; }  MessageHandler​ Declaration​ public MessageHandler MessageHandler { get; }  IsLocalClient​ Is this NetworkClient connected to a local server in host mode Declaration​ public bool IsLocalClient { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class NetworkClient","url":"docs/reference/Mirage/NetworkClient#methods","content":"Connect(String, Nullable&lt;UInt16&gt;)​ Connect client to a NetworkServer instance. Declaration​ public void Connect(string address = null, ushort? port = default(ushort? ))  Parameters​ Type\tName\tDescriptionSystem.String\taddress System.Nullable&lt;System.UInt16&gt;\tport\t Disconnect()​ Disconnect from server. The disconnect message will be invoked. Declaration​ public void Disconnect()  Send&lt;T&gt;(T, Int32)​ This sends a network message with a message Id to the server. This message is sent on channel zero, which by default is the reliable channel. The message must be an instance of a class derived from MessageBase. The message id passed to Send() is used to identify the handler function to invoke on the server when the message is received. Declaration​ public void Send&lt;T&gt;(T message, int channelId = 0)  Parameters​ Type\tName\tDescriptionT\tmessage System.Int32\tchannelId\t Send(ArraySegment&lt;Byte&gt;, Int32)​ Declaration​ public void Send(ArraySegment&lt;byte&gt; segment, int channelId = 0)  Parameters​ Type\tName\tDescriptionSystem.ArraySegment&lt;System.Byte&gt;\tsegment System.Int32\tchannelId\t Send&lt;T&gt;(T, INotifyCallBack)​ Declaration​ public void Send&lt;T&gt;(T message, INotifyCallBack notifyCallBack)  Parameters​ Type\tName\tDescriptionT\tmessage Mirage.SocketLayer.INotifyCallBack\tnotifyCallBack\t UpdateReceive()​ Declaration​ public void UpdateReceive()  UpdateSent()​ Declaration​ public void UpdateSent()  "},{"title":"Class NetworkDiagnostics","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkDiagnostics","content":"Class NetworkDiagnostics Provides profiling information from mirror A profiler can subscribe to these events and present the data in a friendly way to the user Inheritance​ System.Object Inherited Members​ Show Syntax​ public static class NetworkDiagnostics ","keywords":""},{"title":"Struct NetworkDiagnostics.MessageInfo","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkDiagnostics.MessageInfo","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Struct NetworkDiagnostics.MessageInfo","url":"docs/reference/Mirage/NetworkDiagnostics.MessageInfo#constructors","content":"MessageInfo(Object, Int32, Int32)​ Declaration​ public MessageInfo(object message, int bytes, int count)  Parameters​ Type\tName\tDescriptionSystem.Object\tmessage System.Int32\tbytes System.Int32\tcount\t "},{"title":"Fields​","type":1,"pageTitle":"Struct NetworkDiagnostics.MessageInfo","url":"docs/reference/Mirage/NetworkDiagnostics.MessageInfo#fields","content":"message​ The message being sent Declaration​ public readonly object message  bytes​ how big was the message (does not include transport headers) Declaration​ public readonly int bytes  count​ How many connections was the message sent to If an object has a lot of observers this count could be high Declaration​ public readonly int count  "},{"title":"Struct NetworkIdentity.TransformSpawnSettings","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkIdentity.TransformSpawnSettings","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Struct NetworkIdentity.TransformSpawnSettings","url":"docs/reference/Mirage/NetworkIdentity.TransformSpawnSettings#constructors","content":"TransformSpawnSettings(Boolean, Boolean, Boolean)​ Declaration​ public TransformSpawnSettings(bool sendPosition, bool sendRotation, bool sendScale)  Parameters​ Type\tName\tDescriptionSystem.Boolean\tsendPosition System.Boolean\tsendRotation System.Boolean\tsendScale\t "},{"title":"Fields​","type":1,"pageTitle":"Struct NetworkIdentity.TransformSpawnSettings","url":"docs/reference/Mirage/NetworkIdentity.TransformSpawnSettings#fields","content":"SendPosition​ Declaration​ public bool SendPosition  SendRotation​ Declaration​ public bool SendRotation  SendScale​ Declaration​ public bool SendScale  "},{"title":"Class NetworkIdentity","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkIdentity","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkIdentity","url":"docs/reference/Mirage/NetworkIdentity#fields","content":"SpawnSettings​ Declaration​ public NetworkIdentity.TransformSpawnSettings SpawnSettings  observers​ The set of network connections (players) that can see this object. Declaration​ public readonly HashSet&lt;INetworkPlayer&gt; observers  ServerObjectManager​ Declaration​ public ServerObjectManager ServerObjectManager  ClientObjectManager​ The ClientObjectManager is present only for client instances. Declaration​ public ClientObjectManager ClientObjectManager  "},{"title":"Properties​","type":1,"pageTitle":"Class NetworkIdentity","url":"docs/reference/Mirage/NetworkIdentity#properties","content":"IsClient​ Returns true if running as a client and this object was spawned by a server. Declaration​ public bool IsClient { get; }  IsServer​ Returns true if NetworkServer.active and server is not stopped. Declaration​ public bool IsServer { get; }  IsLocalClient​ Returns true if we're on host mode. Declaration​ public bool IsLocalClient { get; }  IsLocalPlayer​ This returns true if this object is the one that represents the player on the local machine. This is set when the server has spawned an object for this particular client. Declaration​ public bool IsLocalPlayer { get; }  HasAuthority​ This returns true if this object is the authoritative player object on the client. This value is determined at runtime. For most objects, authority is held by the server. For objects that had their authority set by AssignClientAuthority on the server, this will be true on the client that owns the object. NOT on other clients. Declaration​ public bool HasAuthority { get; }  NetId​ Unique identifier for this particular object instance, used for tracking objects between networked clients and the server. This is a unique identifier for this particular GameObject instance. Use it to track GameObjects between networked clients and the server. Declaration​ public uint NetId { get; }  IsSceneObject​ Is this object part of a scene and have a Scene Id? Declaration​ public bool IsSceneObject { get; }  IsPrefab​ Is this object a prefab and have a so that it can be spawned over the network Declaration​ public bool IsPrefab { get; }  IsSpawned​ Has this object been spawned and have a Declaration​ public bool IsSpawned { get; }  Server​ The NetworkServer associated with this NetworkIdentity. Declaration​ public NetworkServer Server { get; }  World​ The world this object exists in Declaration​ public NetworkWorld World { get; }  Client​ The NetworkClient associated with this NetworkIdentity. Declaration​ public NetworkClient Client { get; }  Owner​ The INetworkPlayer associated with this . This property is only valid on server Use it to return details such as the connection's identity, IP address and ready status. Declaration​ public INetworkPlayer Owner { get; }  NetworkBehaviours​ Array of NetworkBehaviours associated with this NetworkIdentity. Can be in child GameObjects. Declaration​ public NetworkBehaviour[] NetworkBehaviours { get; }  Visibility​ Declaration​ public NetworkVisibility Visibility { get; }  PrefabHash​ Declaration​ public int PrefabHash { get; }  OnStartServer​ This is invoked for NetworkBehaviour objects when they become active on the server. This could be triggered by NetworkServer.Start() for objects in the scene, or by ServerObjectManager.Spawn() for objects you spawn at runtime. This will be called for objects on a &quot;host&quot; as well as for object on a dedicated server. OnStartServer is invoked before this object is added to collection of spawned objects Declaration​ public IAddLateEvent OnStartServer { get; }  OnStartClient​ Called on every NetworkBehaviour when it is activated on a client. Objects on the host have this function called, as there is a local client on the host. The values of SyncVars on object are guaranteed to be initialized correctly with the latest state from the server when this function is called on the client. Declaration​ public IAddLateEvent OnStartClient { get; }  OnStartLocalPlayer​ Called when the local player object has been set up. This happens after OnStartClient(), as it is triggered by an ownership message from the server. This is an appropriate place to activate components or functionality that should only be active for the local player, such as cameras and input. Declaration​ public IAddLateEvent OnStartLocalPlayer { get; }  OnAuthorityChanged​ This is invoked on behaviours that have authority given or removed, see This is called after and before When or is called on the server, this will be called on the client that owns the object. When an object is spawned with with a NetworkConnection parameter included, this will be called on the client that owns the object. NOTE: this even is only called for client and host Declaration​ public IAddLateEvent&lt;bool&gt; OnAuthorityChanged { get; }  OnOwnerChanged​ This is invoked on behaviours that have an owner assigned. This even is only called on server See for more comments on owner and authority Declaration​ public IAddLateEvent&lt;INetworkPlayer&gt; OnOwnerChanged { get; }  OnStopClient​ This is invoked on clients when the server has caused this object to be destroyed. This can be used as a hook to invoke effects or do client specific cleanup. Declaration​ public IAddLateEvent OnStopClient { get; }  OnStopServer​ This is called on the server when the object is unspawned Declaration​ public IAddLateEvent OnStopServer { get; }  SpawnedFromInstantiate​ Declaration​ public bool SpawnedFromInstantiate { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class NetworkIdentity","url":"docs/reference/Mirage/NetworkIdentity#methods","content":"RebuildObservers(Boolean)​ This causes the set of players that can see this object to be rebuild. The OnRebuildObservers callback function will be invoked on each NetworkBehaviour. Declaration​ public void RebuildObservers(bool initialize)  Parameters​ Type\tName\tDescriptionSystem.Boolean\tinitialize\tTrue if this is the first time. AssignClientAuthority(INetworkPlayer)​ Assign control of an object to a client via the client's This causes hasAuthority to be set on the client that owns the object, and NetworkBehaviour.OnStartAuthority will be called on that client. This object then will be in the NetworkConnection.clientOwnedObjects list for the connection. Authority can be removed with RemoveClientAuthority. Only one client can own an object at any time. This does not need to be called for player objects, as their authority is setup automatically. Declaration​ public void AssignClientAuthority(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tThe connection of the client to assign authority to. RemoveClientAuthority()​ Removes ownership for an object. This applies to objects that had authority set by AssignClientAuthority, or with a NetworkConnection parameter included. Authority cannot be removed for player objects. Declaration​ public void RemoveClientAuthority()  "},{"title":"Class NetworkIdentitySerializers","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkIdentitySerializers","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class NetworkIdentitySerializers","url":"docs/reference/Mirage/NetworkIdentitySerializers#methods","content":"WriteNetworkIdentitySyncVar(NetworkWriter, NetworkIdentitySyncvar)​ Declaration​ public static void WriteNetworkIdentitySyncVar(this NetworkWriter writer, NetworkIdentitySyncvar id)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Mirage.NetworkIdentitySyncvar\tid\t ReadNetworkIdentitySyncVar(NetworkReader)​ Declaration​ public static NetworkIdentitySyncvar ReadNetworkIdentitySyncVar(this NetworkReader reader)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader\t Returns​ Type\tDescriptionMirage.NetworkIdentitySyncvar\t "},{"title":"Class NetworkManager","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkManager","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkManager","url":"docs/reference/Mirage/NetworkManager#fields","content":"Server​ Declaration​ public NetworkServer Server  Client​ Declaration​ public NetworkClient Client  NetworkSceneManager​ Declaration​ public NetworkSceneManager NetworkSceneManager  ServerObjectManager​ Declaration​ public ServerObjectManager ServerObjectManager  ClientObjectManager​ Declaration​ public ClientObjectManager ClientObjectManager  "},{"title":"Properties​","type":1,"pageTitle":"Class NetworkManager","url":"docs/reference/Mirage/NetworkManager#properties","content":"IsNetworkActive​ True if the server or client is started and running This is set True in StartServer / StartClient, and set False in StopServer / StopClient Declaration​ public bool IsNetworkActive { get; }  NetworkMode​ helper enum to know if we started the networkmanager as server/client/host. Declaration​ public NetworkManagerMode NetworkMode { get; }  "},{"title":"Struct NetworkIdentitySyncvar","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkIdentitySyncvar","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Struct NetworkIdentitySyncvar","url":"docs/reference/Mirage/NetworkIdentitySyncvar#properties","content":"Value​ Declaration​ public NetworkIdentity Value { get; set; }  "},{"title":"Class NetworkManagerGUI","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkManagerGUI","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkManagerGUI","url":"docs/reference/Mirage/NetworkManagerGUI#fields","content":"NetworkManager​ Declaration​ public NetworkManager NetworkManager  NetworkAddress​ Declaration​ public string NetworkAddress  Scale​ Declaration​ public float Scale  GUIAnchor​ Declaration​ public TextAnchor GUIAnchor  "},{"title":"Enum NetworkManagerMode","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkManagerMode","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Enum NetworkManagerMode","url":"docs/reference/Mirage/NetworkManagerMode#fields","content":"None​ Declaration​ None = 0  Server​ Declaration​ Server = 1  Client​ Declaration​ Client = 2  Host​ Declaration​ Host = 3  "},{"title":"Class NetworkManagerHud","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkManagerHud","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkManagerHud","url":"docs/reference/Mirage/NetworkManagerHud#fields","content":"NetworkManager​ Declaration​ public NetworkManager NetworkManager  NetworkAddress​ Declaration​ public string NetworkAddress  DontDestroy​ Declaration​ public bool DontDestroy  NetworkAddressInput​ Declaration​ public InputField NetworkAddressInput  OfflineGO​ Declaration​ public GameObject OfflineGO  OnlineGO​ Declaration​ public GameObject OnlineGO  StatusLabel​ Declaration​ public Text StatusLabel  "},{"title":"Methods​","type":1,"pageTitle":"Class NetworkManagerHud","url":"docs/reference/Mirage/NetworkManagerHud#methods","content":"StartHostButtonHandler()​ Declaration​ public void StartHostButtonHandler()  StartServerOnlyButtonHandler()​ Declaration​ public void StartServerOnlyButtonHandler()  StartClientButtonHandler()​ Declaration​ public void StartClientButtonHandler()  StopButtonHandler()​ Declaration​ public void StopButtonHandler()  OnNetworkAddressInputUpdate()​ Declaration​ public void OnNetworkAddressInputUpdate()  "},{"title":"Class NetworkMatchChecker","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkMatchChecker","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkMatchChecker","url":"docs/reference/Mirage/NetworkMatchChecker#fields","content":"currentMatchDebug​ Declaration​ public string currentMatchDebug  "},{"title":"Properties​","type":1,"pageTitle":"Class NetworkMatchChecker","url":"docs/reference/Mirage/NetworkMatchChecker#properties","content":"MatchId​ Set this to the same value on all networked objects that belong to a given match Declaration​ public Guid MatchId { get; set; }  "},{"title":"Methods​","type":1,"pageTitle":"Class NetworkMatchChecker","url":"docs/reference/Mirage/NetworkMatchChecker#methods","content":"Awake()​ Declaration​ public void Awake()  OnStartServer()​ Declaration​ public void OnStartServer()  OnCheckObserver(INetworkPlayer)​ Callback used by the visibility system to determine if an observer (player) can see this object. If this function returns true, the network connection will be added as an observer. Declaration​ public override bool OnCheckObserver(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tNetwork connection of a player. Returns​ Type\tDescriptionSystem.Boolean\tTrue if the player can see this object. OnRebuildObservers(HashSet&lt;INetworkPlayer&gt;, Boolean)​ Callback used by the visibility system to (re)construct the set of observers that can see this object. Implementations of this callback should add network connections of players that can see this object to the observers set. Declaration​ public override void OnRebuildObservers(HashSet&lt;INetworkPlayer&gt; observers, bool initialize)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.HashSet&lt;Mirage.INetworkPlayer&gt;\tobservers\tThe new set of observers for this object. System.Boolean\tinitialize\tTrue if the set of observers is being built for the first time. "},{"title":"Class NetworkMessageAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkMessageAttribute","content":"Class NetworkMessageAttribute Tell the weaver to generate reader and writer for a class Inheritance​ System.Object System.Attribute Inherited Members​ Show Syntax​ [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)] public class NetworkMessageAttribute : Attribute, _Attribute ","keywords":""},{"title":"Class NetworkPingDisplay","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkPingDisplay","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkPingDisplay","url":"docs/reference/Mirage/NetworkPingDisplay#fields","content":"Client​ Declaration​ public NetworkClient Client  NetworkPingLabelText​ Declaration​ public Text NetworkPingLabelText  "},{"title":"Struct NetworkPingMessage","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkPingMessage","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Struct NetworkPingMessage","url":"docs/reference/Mirage/NetworkPingMessage#fields","content":"clientTime​ Declaration​ public double clientTime  "},{"title":"Struct NetworkPongMessage","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkPongMessage","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Struct NetworkPongMessage","url":"docs/reference/Mirage/NetworkPongMessage#fields","content":"clientTime​ Declaration​ public double clientTime  serverTime​ Declaration​ public double serverTime  "},{"title":"Class NetworkPlayer","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkPlayer","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class NetworkPlayer","url":"docs/reference/Mirage/NetworkPlayer#constructors","content":"NetworkPlayer(IConnection)​ Creates a new NetworkConnection with the specified address and connectionId Declaration​ public NetworkPlayer(IConnection connection)  Parameters​ Type\tName\tDescriptionMirage.SocketLayer.IConnection\tconnection\t "},{"title":"Properties​","type":1,"pageTitle":"Class NetworkPlayer","url":"docs/reference/Mirage/NetworkPlayer#properties","content":"IsAuthenticated​ Marks if this player has been accepted by a Declaration​ public bool IsAuthenticated { get; set; }  AuthenticationData​ General purpose object to hold authentication data, character selection, tokens, etc. associated with the connection for reference after Authentication completes. Declaration​ public object AuthenticationData { get; set; }  SceneIsReady​ Flag that tells us if the scene has fully loaded in for player. This property is read-only. It is set by the system on the client when the scene has fully loaded, and set by the system on the server when a ready message is received from a client. A client that is ready is sent spawned objects by the server and updates to the state of spawned objects. A client that is not ready is not sent spawned objects. Starts as true, when a client connects it is assumed that it is already in a ready scene. It will be set to not ready if NetworkSceneManager loads a scene Declaration​ public bool SceneIsReady { get; set; }  HasCharacter​ Checks if this player has a Declaration​ public bool HasCharacter { get; }  Address​ The IP address / URL / FQDN associated with the connection. Can be useful for a game master to do IP Bans etc. Declaration​ public IEndPoint Address { get; }  Connection​ Declaration​ public IConnection Connection { get; }  VisList​ List of all networkIdentity that this player can see Only valid on server Declaration​ public IReadOnlyCollection&lt;NetworkIdentity&gt; VisList { get; }  Identity​ The NetworkIdentity for this connection. Declaration​ public NetworkIdentity Identity { get; set; }  "},{"title":"Methods​","type":1,"pageTitle":"Class NetworkPlayer","url":"docs/reference/Mirage/NetworkPlayer#methods","content":"Disconnect()​ Disconnects the player. A disconnected player can not send messages Declaration​ public void Disconnect()  MarkAsDisconnected()​ Marks player as disconnected, used when the disconnect call is from peer A disconnected player can not send messages Declaration​ public void MarkAsDisconnected()  Send&lt;T&gt;(T, Int32)​ This sends a network message to the connection. Declaration​ public void Send&lt;T&gt;(T message, int channelId = 0)  Parameters​ Type\tName\tDescriptionT\tmessage System.Int32\tchannelId\tThe transport layer channel to send on. Send(ArraySegment&lt;Byte&gt;, Int32)​ Sends a block of data Only use this method if data has message Id already included, otherwise receives wont know how to handle it. Otherwise use Declaration​ public void Send(ArraySegment&lt;byte&gt; segment, int channelId = 0)  Parameters​ Type\tName\tDescriptionSystem.ArraySegment&lt;System.Byte&gt;\tsegment System.Int32\tchannelId\t Send&lt;T&gt;(T, INotifyCallBack)​ This sends a network message to the connection. Declaration​ public void Send&lt;T&gt;(T message, INotifyCallBack callBacks)  Parameters​ Type\tName\tDescriptionT\tmessage Mirage.SocketLayer.INotifyCallBack\tcallBacks\t ToString()​ Declaration​ public override string ToString()  Returns​ Type\tDescriptionSystem.String\t AddToVisList(NetworkIdentity)​ Declaration​ public void AddToVisList(NetworkIdentity identity)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tidentity\t RemoveFromVisList(NetworkIdentity)​ Declaration​ public void RemoveFromVisList(NetworkIdentity identity)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tidentity\t ContainsInVisList(NetworkIdentity)​ Checks if player can see NetworkIdentity Declaration​ public bool ContainsInVisList(NetworkIdentity identity)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tidentity\t Returns​ Type\tDescriptionSystem.Boolean\t RemoveAllVisibleObjects()​ Removes all objects that this player can see This is called when loading a new scene Declaration​ public void RemoveAllVisibleObjects()  AddOwnedObject(NetworkIdentity)​ Declaration​ public void AddOwnedObject(NetworkIdentity identity)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tidentity\t RemoveOwnedObject(NetworkIdentity)​ Declaration​ public void RemoveOwnedObject(NetworkIdentity identity)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tidentity\t DestroyOwnedObjects()​ Destroy all objects owned by this player NOTE: only destroyed objects that are currently spawned Declaration​ public void DestroyOwnedObjects()  "},{"title":"Class NetworkProximityChecker","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkProximityChecker","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkProximityChecker","url":"docs/reference/Mirage/NetworkProximityChecker#fields","content":"VisibilityRange​ The maximim range that objects will be visible at. Declaration​ public int VisibilityRange  VisibilityUpdateInterval​ How often (in seconds) that this object should update the list of observers that can see it. Declaration​ public float VisibilityUpdateInterval  ForceHidden​ Flag to force this object to be hidden for players. If this object is a player object, it will not be hidden for that player. Declaration​ public bool ForceHidden  "},{"title":"Methods​","type":1,"pageTitle":"Class NetworkProximityChecker","url":"docs/reference/Mirage/NetworkProximityChecker#methods","content":"Awake()​ Declaration​ public void Awake()  OnCheckObserver(INetworkPlayer)​ Callback used by the visibility system to determine if an observer (player) can see this object. If this function returns true, the network connection will be added as an observer. Declaration​ public override bool OnCheckObserver(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tNetwork connection of a player. Returns​ Type\tDescriptionSystem.Boolean\tTrue if the player can see this object. OnRebuildObservers(HashSet&lt;INetworkPlayer&gt;, Boolean)​ Callback used by the visibility system to (re)construct the set of observers that can see this object. Implementations of this callback should add network connections of players that can see this object to the observers set. Declaration​ public override void OnRebuildObservers(HashSet&lt;INetworkPlayer&gt; observers, bool initialize)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.HashSet&lt;Mirage.INetworkPlayer&gt;\tobservers\tThe new set of observers for this object. System.Boolean\tinitialize\tTrue if the set of observers is being built for the first time. "},{"title":"Class NetworkSceneChecker","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkSceneChecker","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkSceneChecker","url":"docs/reference/Mirage/NetworkSceneChecker#fields","content":"forceHidden​ Flag to force this object to be hidden from all observers. If this object is a player object, it will not be hidden for that client. Declaration​ public bool forceHidden  "},{"title":"Methods​","type":1,"pageTitle":"Class NetworkSceneChecker","url":"docs/reference/Mirage/NetworkSceneChecker#methods","content":"OnStartServer()​ Declaration​ public void OnStartServer()  OnCheckObserver(INetworkPlayer)​ Callback used by the visibility system to determine if an observer (player) can see this object. If this function returns true, the network connection will be added as an observer. Declaration​ public override bool OnCheckObserver(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tNetwork connection of a player. Returns​ Type\tDescriptionSystem.Boolean\tTrue if the player can see this object. OnRebuildObservers(HashSet&lt;INetworkPlayer&gt;, Boolean)​ Callback used by the visibility system to (re)construct the set of observers that can see this object. Implementations of this callback should add network connections of players that can see this object to the observers set. Declaration​ public override void OnRebuildObservers(HashSet&lt;INetworkPlayer&gt; observers, bool initialize)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.HashSet&lt;Mirage.INetworkPlayer&gt;\tobservers\tThe new set of observers for this object. System.Boolean\tinitialize\tTrue if the set of observers is being built for the first time. "},{"title":"Class NetworkSceneManager","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkSceneManager","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkSceneManager","url":"docs/reference/Mirage/NetworkSceneManager#fields","content":"Client​ Declaration​ public NetworkClient Client  Server​ Declaration​ public NetworkServer Server  DontDestroy​ Sets the NetworksSceneManagers GameObject to DontDestroyOnLoad. Default = true. Declaration​ public bool DontDestroy  SceneLoadingAsyncOperationInfo​ Information on any scene that is currently being loaded. Declaration​ public AsyncOperation SceneLoadingAsyncOperationInfo  "},{"title":"Properties​","type":1,"pageTitle":"Class NetworkSceneManager","url":"docs/reference/Mirage/NetworkSceneManager#properties","content":"ActiveScenePath​ The path of the current active scene. If using additive scenes this will be the first scene. Value from Declaration​ public string ActiveScenePath { get; }  ServerSceneData​ Collection of scenes and which player's are in those scenes. Declaration​ public IReadOnlyDictionary&lt;Scene, HashSet&lt;INetworkPlayer&gt;&gt; ServerSceneData { get; }  OnClientStartedSceneChange​ Event fires when the Client starts changing scene. Declaration​ public SceneChangeStartedEvent OnClientStartedSceneChange { get; }  OnClientFinishedSceneChange​ Event fires after the Client has completed its scene change. Declaration​ public SceneChangeFinishedEvent OnClientFinishedSceneChange { get; }  OnServerStartedSceneChange​ Event fires before Server changes scene. Declaration​ public SceneChangeStartedEvent OnServerStartedSceneChange { get; }  OnServerFinishedSceneChange​ Event fires after Server has completed scene change. Declaration​ public SceneChangeFinishedEvent OnServerFinishedSceneChange { get; }  OnPlayerSceneReady​ Event fires On the server, after Client sends to the server Declaration​ public PlayerSceneChangeEvent OnPlayerSceneReady { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class NetworkSceneManager","url":"docs/reference/Mirage/NetworkSceneManager#methods","content":"Start()​ Declaration​ public virtual void Start()  OnDestroy()​ Declaration​ public virtual void OnDestroy()  IsPlayerInScene(Scene, INetworkPlayer)​ Check whether or not the player is in a specific scene or not. Declaration​ public bool IsPlayerInScene(Scene scene, INetworkPlayer player)  Parameters​ Type\tName\tDescriptionScene\tscene\tThe scene we want to check in. Mirage.INetworkPlayer\tplayer\tThe player we want to check for. Returns​ Type\tDescriptionSystem.Boolean\tReturns true or false if the player is in the scene specified. ScenesPlayerIsIn(INetworkPlayer)​ What scene is this specific player currently in. Declaration​ public Scene[] ScenesPlayerIsIn(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tThe player we want to check against. Returns​ Type\tDescriptionScene[]\tReturns back a array of scene's the player is currently in. ScenesPlayerIsInNonAlloc(INetworkPlayer, List&lt;Scene&gt;)​ Declaration​ public void ScenesPlayerIsInNonAlloc(INetworkPlayer player, List&lt;Scene&gt; scenes)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer System.Collections.Generic.List&lt;Scene&gt;\tscenes\t ClientStartSceneMessage(INetworkPlayer, SceneMessage)​ Received message from server to start loading scene or scenes. Default implementation is to load main activate scene server is using and load any other additive scenes in background and notify event handler. If this is not intended behavior you need please override this function. Declaration​ public virtual void ClientStartSceneMessage(INetworkPlayer player, SceneMessage message)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer Mirage.SceneMessage\tmessage\t ClientFinishedLoadingSceneMessage(INetworkPlayer, SceneReadyMessage)​ Received message from server that it has finished loading the scene. Default implementation will set AllowSceneActivation = true and invoke event handler. If this is not good enough intended behavior then override this method. Declaration​ protected virtual void ClientFinishedLoadingSceneMessage(INetworkPlayer player, SceneReadyMessage message)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tThe player who sent the message. Mirage.SceneReadyMessage\tmessage\tThe message data coming back from server. ClientNotReadyMessage(INetworkPlayer, SceneNotReadyMessage)​ Received message that player is not ready. Default implementation is to set player to not ready. Declaration​ protected virtual void ClientNotReadyMessage(INetworkPlayer player, SceneNotReadyMessage message)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tThe player that is currently not ready. Mirage.SceneNotReadyMessage\tmessage\tThe message data coming in. SetSceneIsReady()​ Signal that the client connection is ready to enter the game. This could be for example when a client enters an ongoing game and has finished loading the current scene. The server should respond to the message with an appropriate handler which instantiates the players object for example. Declaration​ public void SetSceneIsReady()  ServerLoadSceneNormal(String, Nullable&lt;LoadSceneParameters&gt;)​ Allows server to fully load in a new scene and override current active scene. Declaration​ public void ServerLoadSceneNormal(string scenePath, LoadSceneParameters? sceneLoadParameters = default(LoadSceneParameters? ))  Parameters​ Type\tName\tDescriptionSystem.String\tscenePath\tThe full path to the scene file or the name of the scene. System.Nullable&lt;LoadSceneParameters&gt;\tsceneLoadParameters\tWhat settings should we be using for physics scene loading. ServerLoadSceneAdditively(String, IEnumerable&lt;INetworkPlayer&gt;, Boolean, Nullable&lt;LoadSceneParameters&gt;)​ Allows server to fully load in another scene on top of current active scene. Declaration​ public void ServerLoadSceneAdditively(string scenePath, IEnumerable&lt;INetworkPlayer&gt; players, bool shouldClientLoadNormally = false, LoadSceneParameters? sceneLoadParameters = default(LoadSceneParameters? ))  Parameters​ Type\tName\tDescriptionSystem.String\tscenePath\tThe full path to the scene file or the name of the scene. System.Collections.Generic.IEnumerable&lt;Mirage.INetworkPlayer&gt;\tplayers\tCollection of player's that are receiving the new scene load. System.Boolean\tshouldClientLoadNormally\tShould the clients load this additively too or load it full normal scene change. System.Nullable&lt;LoadSceneParameters&gt;\tsceneLoadParameters\tWhat settings should we be using for physics scene loading. ServerUnloadSceneAdditively(Scene, IEnumerable&lt;INetworkPlayer&gt;)​ Allows server to fully unload a scene additively. Declaration​ public void ServerUnloadSceneAdditively(Scene scene, IEnumerable&lt;INetworkPlayer&gt; players)  Parameters​ Type\tName\tDescriptionScene\tscene\tThe scene handle which we want to unload additively. System.Collections.Generic.IEnumerable&lt;Mirage.INetworkPlayer&gt;\tplayers\tCollection of player's that are receiving the new scene unload. OnServerAuthenticated(INetworkPlayer)​ When player authenticates to server we send a message to them to load up main scene and any other scenes that are loaded on server. Default implementation takes main activate scene as main and any other loaded scenes and sends it to player's Please override this function if this is not intended behavior for you. Declaration​ protected virtual void OnServerAuthenticated(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tThe current player that finished authenticating. OnServerPlayerDisconnected(INetworkPlayer)​ When player disconnects from server we will need to clean up info in scenes related to user. Default implementation we loop through list of scenes and find where this player was in and removed them from list. Declaration​ protected virtual void OnServerPlayerDisconnected(INetworkPlayer disconnectedPlayer)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tdisconnectedPlayer\t SetAllClientsNotReady(IEnumerable&lt;INetworkPlayer&gt;)​ Marks all connected clients as no longer ready. All clients will no longer be sent state synchronization updates. The player&amp;apos;s clients can call ClientManager.Ready() again to re-enter the ready state. This is useful when switching scenes.  Declaration​ public void SetAllClientsNotReady(IEnumerable&lt;INetworkPlayer&gt; players = null)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IEnumerable&lt;Mirage.INetworkPlayer&gt;\tplayers\t SetClientNotReady(INetworkPlayer)​ Sets a player as not ready and removes all visible objects Players that are not ready will not be sent spawn message or state updates. Players that are not ready do not receive spawned objects or state synchronization updates. They client can be made ready again by calling SetClientReady(). Declaration​ public void SetClientNotReady(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tThe player to make not ready. GetSceneByPathOrName(String)​ Let's us get scene by full path or by its name. Declaration​ public Scene GetSceneByPathOrName(string scenePath)  Parameters​ Type\tName\tDescriptionSystem.String\tscenePath\tThe path or name representing the scene. Returns​ Type\tDescriptionScene\tReturns back correct scene data. "},{"title":"Class NetworkServer","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkServer","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkServer","url":"docs/reference/Mirage/NetworkServer#fields","content":"EnablePeerMetrics​ Declaration​ public bool EnablePeerMetrics  MetricsSize​ Declaration​ public int MetricsSize  MaxConnections​ The maximum number of concurrent network connections to support. Excluding the host player. This field is only used if the property is null Declaration​ public int MaxConnections  DisconnectOnException​ Declaration​ public bool DisconnectOnException  RunInBackground​ Declaration​ public bool RunInBackground  Listening​ Declaration​ public bool Listening  SocketFactory​ Declaration​ public SocketFactory SocketFactory  authenticator​ Declaration​ public NetworkAuthenticator authenticator  ManualUpdate​ Set to true if you want to manually call and and stop mirage from automatically calling them Declaration​ public bool ManualUpdate  "},{"title":"Properties​","type":1,"pageTitle":"Class NetworkServer","url":"docs/reference/Mirage/NetworkServer#properties","content":"Metrics​ Declaration​ public Metrics Metrics { get; }  PeerConfig​ Config for peer, if not set will use default settings Declaration​ public Config PeerConfig { get; set; }  Started​ This is invoked when a server is started - including when a host is started. Declaration​ public IAddLateEvent Started { get; }  Connected​ Declaration​ public NetworkPlayerEvent Connected { get; }  Authenticated​ Declaration​ public NetworkPlayerEvent Authenticated { get; }  Disconnected​ Declaration​ public NetworkPlayerEvent Disconnected { get; }  Stopped​ Declaration​ public IAddLateEvent Stopped { get; }  OnStartHost​ Declaration​ public IAddLateEvent OnStartHost { get; }  OnStopHost​ Declaration​ public IAddLateEvent OnStopHost { get; }  LocalPlayer​ The connection to the host mode client (if any). Declaration​ public INetworkPlayer LocalPlayer { get; }  LocalClient​ The host client for this server Declaration​ public NetworkClient LocalClient { get; }  LocalClientActive​ True if there is a local client connected to this server (host mode) Declaration​ public bool LocalClientActive { get; }  NumberOfPlayers​ Number of active player objects across all connections on the server. This is only valid on the host / server. Declaration​ public int NumberOfPlayers { get; }  Players​ A list of local connections on the server. Declaration​ public IReadOnlyCollection&lt;INetworkPlayer&gt; Players { get; }  Active​ Checks if the server has been started. This will be true after NetworkServer.Listen() has been called. Declaration​ public bool Active { get; }  World​ Declaration​ public NetworkWorld World { get; }  SyncVarSender​ Declaration​ public SyncVarSender SyncVarSender { get; }  MessageHandler​ Declaration​ public MessageHandler MessageHandler { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class NetworkServer","url":"docs/reference/Mirage/NetworkServer#methods","content":"Stop()​ This shuts down the server and disconnects all clients. If In host mode, this will also stop the local client Declaration​ public void Stop()  StartServer(NetworkClient)​ Start the server If localClient is given then will start in host mode Declaration​ public void StartServer(NetworkClient localClient = null)  Parameters​ Type\tName\tDescriptionMirage.NetworkClient\tlocalClient\tif not null then start the server and client in hostmode UpdateReceive()​ Declaration​ public void UpdateReceive()  UpdateSent()​ Declaration​ public void UpdateSent()  AddConnection(INetworkPlayer)​ This accepts a network connection and adds it to the server. This connection will use the callbacks registered with the server. Declaration​ public void AddConnection(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tNetwork connection to add. RemoveConnection(INetworkPlayer)​ This removes an external connection. Declaration​ public void RemoveConnection(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\t SendToAll&lt;T&gt;(T, Int32)​ Send a message to all connected clients. Declaration​ public void SendToAll&lt;T&gt;(T msg, int channelId = 0)  Parameters​ Type\tName\tDescriptionT\tmsg\tMessage System.Int32\tchannelId\tTransport channel to use SendToMany&lt;T&gt;(IEnumerable&lt;INetworkPlayer&gt;, T, Int32)​ Sends a message to many connections WARNING: using this method may cause Enumerator to be boxed creating GC/alloc. Use version where possible Declaration​ public static void SendToMany&lt;T&gt;(IEnumerable&lt;INetworkPlayer&gt; players, T msg, int channelId = 0)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IEnumerable&lt;Mirage.INetworkPlayer&gt;\tplayers T\tmsg System.Int32\tchannelId\t SendToMany&lt;T&gt;(IReadOnlyList&lt;INetworkPlayer&gt;, T, Int32)​ Sends a message to many connections Same as but uses for loop to avoid allocations Declaration​ public static void SendToMany&lt;T&gt;(IReadOnlyList&lt;INetworkPlayer&gt; players, T msg, int channelId = 0)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IReadOnlyList&lt;Mirage.INetworkPlayer&gt;\tplayers T\tmsg System.Int32\tchannelId\t SendToManyExcept&lt;T&gt;(IEnumerable&lt;INetworkPlayer&gt;, INetworkPlayer, T, Int32)​ Sends a message to many connections, expect excluded. This can be useful if you want to send to a observers of an object expect the owner. Or if you want to send to all expect the local host player. WARNING: using this method may cause Enumerator to be boxed creating GC/alloc. Use version where possible Declaration​ public static void SendToManyExcept&lt;T&gt;(IEnumerable&lt;INetworkPlayer&gt; players, INetworkPlayer excluded, T msg, int channelId = 0)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.IEnumerable&lt;Mirage.INetworkPlayer&gt;\tplayers Mirage.INetworkPlayer\texcluded\tplayer to exclude, Can be null T\tmsg System.Int32\tchannelId\t "},{"title":"Class NetworkTime","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkTime","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class NetworkTime","url":"docs/reference/Mirage/NetworkTime#constructors","content":"NetworkTime()​ Declaration​ public NetworkTime()  "},{"title":"Fields​","type":1,"pageTitle":"Class NetworkTime","url":"docs/reference/Mirage/NetworkTime#fields","content":"PingInterval​ how often are we sending ping messages used to calculate network time and RTT Declaration​ public float PingInterval  PingWindowSize​ average out the last few results from Ping Declaration​ public int PingWindowSize  "},{"title":"Properties​","type":1,"pageTitle":"Class NetworkTime","url":"docs/reference/Mirage/NetworkTime#properties","content":"Time​ The time in seconds since the server started. Declaration​ public double Time { get; }  TimeVar​ Measurement of the variance of time. The higher the variance, the less accurate the time is Declaration​ public double TimeVar { get; }  TimeSd​ standard deviation of time. The higher the variance, the less accurate the time is Declaration​ public double TimeSd { get; }  Offset​ Clock difference in seconds between the client and the server Declaration​ public double Offset { get; }  Rtt​ how long in seconds does it take for a message to go to the server and come back Declaration​ public double Rtt { get; }  RttVar​ measure variance of rtt the higher the number, the less accurate rtt is Declaration​ public double RttVar { get; }  RttSd​ Measure the standard deviation of rtt the higher the number, the less accurate rtt is Declaration​ public double RttSd { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class NetworkTime","url":"docs/reference/Mirage/NetworkTime#methods","content":"Reset()​ Declaration​ public void Reset()  "},{"title":"Class NetworkTransform","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkTransform","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Class NetworkTransform","url":"docs/reference/Mirage/NetworkTransform#properties","content":"TargetComponent​ Declaration​ protected override Transform TargetComponent { get; }  "},{"title":"Class NetworkTransformBase.DataPoint","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkTransformBase.DataPoint","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkTransformBase.DataPoint","url":"docs/reference/Mirage/NetworkTransformBase.DataPoint#fields","content":"TimeStamp​ Declaration​ public float TimeStamp  LocalPosition​ Declaration​ public Vector3 LocalPosition  LocalRotation​ Declaration​ public Quaternion LocalRotation  LocalScale​ Declaration​ public Vector3 LocalScale  MovementSpeed​ Declaration​ public float MovementSpeed  "},{"title":"Class NetworkTransformBase","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkTransformBase","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkTransformBase","url":"docs/reference/Mirage/NetworkTransformBase#fields","content":"ClientAuthority​ Declaration​ public bool ClientAuthority  LocalPositionSensitivity​ Declaration​ public float LocalPositionSensitivity  LocalRotationSensitivity​ Declaration​ public float LocalRotationSensitivity  LocalScaleSensitivity​ Declaration​ public float LocalScaleSensitivity  "},{"title":"Properties​","type":1,"pageTitle":"Class NetworkTransformBase","url":"docs/reference/Mirage/NetworkTransformBase#properties","content":"TargetComponent​ Declaration​ protected abstract Transform TargetComponent { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class NetworkTransformBase","url":"docs/reference/Mirage/NetworkTransformBase#methods","content":"SerializeIntoWriter(NetworkWriter, Vector3, Quaternion, Vector3)​ Declaration​ public static void SerializeIntoWriter(NetworkWriter writer, Vector3 position, Quaternion rotation, Vector3 scale)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter Vector3\tposition Quaternion\trotation Vector3\tscale\t OnSerialize(NetworkWriter, Boolean)​ Declaration​ public override bool OnSerialize(NetworkWriter writer, bool initialState)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkWriter\twriter System.Boolean\tinitialState\t Returns​ Type\tDescriptionSystem.Boolean\t OnDeserialize(NetworkReader, Boolean)​ Declaration​ public override void OnDeserialize(NetworkReader reader, bool initialState)  Parameters​ Type\tName\tDescriptionMirage.Serialization.NetworkReader\treader System.Boolean\tinitialState\t "},{"title":"Class NetworkTransformChild","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkTransformChild","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class NetworkTransformChild","url":"docs/reference/Mirage/NetworkTransformChild#fields","content":"Target​ Declaration​ public Transform Target  "},{"title":"Properties​","type":1,"pageTitle":"Class NetworkTransformChild","url":"docs/reference/Mirage/NetworkTransformChild#properties","content":"TargetComponent​ Declaration​ protected override Transform TargetComponent { get; }  "},{"title":"Class NetworkVisibility","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkVisibility","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class NetworkVisibility","url":"docs/reference/Mirage/NetworkVisibility#methods","content":"OnCheckObserver(INetworkPlayer)​ Callback used by the visibility system to determine if an observer (player) can see this object. If this function returns true, the network connection will be added as an observer. Declaration​ public abstract bool OnCheckObserver(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tNetwork connection of a player. Returns​ Type\tDescriptionSystem.Boolean\tTrue if the player can see this object. OnRebuildObservers(HashSet&lt;INetworkPlayer&gt;, Boolean)​ Callback used by the visibility system to (re)construct the set of observers that can see this object. Implementations of this callback should add network connections of players that can see this object to the observers set. NOTE: override this function if you want to optimize this loop in your visibility, for example if you need to call GetComponent on this object you can call it once at the start of the loop Declaration​ public virtual void OnRebuildObservers(HashSet&lt;INetworkPlayer&gt; observers, bool initialize)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.HashSet&lt;Mirage.INetworkPlayer&gt;\tobservers\tThe new set of observers for this object. System.Boolean\tinitialize\tTrue if the set of observers is being built for the first time. "},{"title":"Class NetworkWorld","type":0,"sectionRef":"#","url":"docs/reference/Mirage/NetworkWorld","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class NetworkWorld","url":"docs/reference/Mirage/NetworkWorld#constructors","content":"NetworkWorld()​ Declaration​ public NetworkWorld()  "},{"title":"Properties​","type":1,"pageTitle":"Class NetworkWorld","url":"docs/reference/Mirage/NetworkWorld#properties","content":"Time​ Time kept in this world Declaration​ public NetworkTime Time { get; }  SpawnedIdentities​ Declaration​ public IReadOnlyCollection&lt;NetworkIdentity&gt; SpawnedIdentities { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class NetworkWorld","url":"docs/reference/Mirage/NetworkWorld#methods","content":"TryGetIdentity(UInt32, out NetworkIdentity)​ Declaration​ public bool TryGetIdentity(uint netId, out NetworkIdentity identity)  Parameters​ Type\tName\tDescriptionSystem.UInt32\tnetId Mirage.NetworkIdentity\tidentity\t Returns​ Type\tDescriptionSystem.Boolean\t "},{"title":"Struct ObjectDestroyMessage","type":0,"sectionRef":"#","url":"docs/reference/Mirage/ObjectDestroyMessage","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Struct ObjectDestroyMessage","url":"docs/reference/Mirage/ObjectDestroyMessage#fields","content":"netId​ Declaration​ public uint netId  "},{"title":"Struct ObjectHideMessage","type":0,"sectionRef":"#","url":"docs/reference/Mirage/ObjectHideMessage","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Struct ObjectHideMessage","url":"docs/reference/Mirage/ObjectHideMessage#fields","content":"netId​ Declaration​ public uint netId  "},{"title":"Class OnlineOfflineScene","type":0,"sectionRef":"#","url":"docs/reference/Mirage/OnlineOfflineScene","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class OnlineOfflineScene","url":"docs/reference/Mirage/OnlineOfflineScene#fields","content":"Server​ Declaration​ public NetworkServer Server  NetworkSceneManager​ Declaration​ public NetworkSceneManager NetworkSceneManager  OnlineScene​ Declaration​ public string OnlineScene  OfflineScene​ Declaration​ public string OfflineScene  "},{"title":"Class ObjectReady","type":0,"sectionRef":"#","url":"docs/reference/Mirage/ObjectReady","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class ObjectReady","url":"docs/reference/Mirage/ObjectReady#fields","content":"IsReady​ Declaration​ public bool IsReady  "},{"title":"Methods​","type":1,"pageTitle":"Class ObjectReady","url":"docs/reference/Mirage/ObjectReady#methods","content":"SetClientReady()​ Declaration​ public void SetClientReady()  SetClientNotReady()​ Declaration​ public void SetClientNotReady()  Ready()​ Declaration​ public void Ready()  "},{"title":"Class PipePeerConnection.PipeEndPoint","type":0,"sectionRef":"#","url":"docs/reference/Mirage/PipePeerConnection.PipeEndPoint","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class PipePeerConnection.PipeEndPoint","url":"docs/reference/Mirage/PipePeerConnection.PipeEndPoint#methods","content":"IEndPoint.CreateCopy()​ Declaration​ IEndPoint IEndPoint.CreateCopy()  Returns​ Type\tDescriptionMirage.SocketLayer.IEndPoint\t "},{"title":"Class PipePeerConnection","type":0,"sectionRef":"#","url":"docs/reference/Mirage/PipePeerConnection","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Class PipePeerConnection","url":"docs/reference/Mirage/PipePeerConnection#properties","content":"IConnection.EndPoint​ Declaration​ IEndPoint IConnection.EndPoint { get; }  State​ Declaration​ public ConnectionState State { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class PipePeerConnection","url":"docs/reference/Mirage/PipePeerConnection#methods","content":"Create(IDataHandler, IDataHandler, Action, Action)​ Declaration​ public static (IConnection clientConn, IConnection serverConn) Create(IDataHandler clientHandler, IDataHandler serverHandler, Action clientOnDisconnect, Action serverOnDisconnect)  Parameters​ Type\tName\tDescriptionMirage.SocketLayer.IDataHandler\tclientHandler Mirage.SocketLayer.IDataHandler\tserverHandler System.Action\tclientOnDisconnect System.Action\tserverOnDisconnect\t Returns​ Type\tDescriptionSystem.ValueTuple{Mirage.SocketLayer.IConnection,Mirage.SocketLayer.IConnection}\t ToString()​ Declaration​ public override string ToString()  Returns​ Type\tDescriptionSystem.String\t IConnection.FlushBatch()​ Declaration​ void IConnection.FlushBatch()  IConnection.Disconnect()​ Declaration​ void IConnection.Disconnect()  SendNotify(Byte[], Int32, Int32)​ Declaration​ public INotifyToken SendNotify(byte[] packet, int offset, int length)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tpacket System.Int32\toffset System.Int32\tlength\t Returns​ Type\tDescriptionMirage.SocketLayer.INotifyToken\t SendNotify(ArraySegment&lt;Byte&gt;)​ Declaration​ public INotifyToken SendNotify(ArraySegment&lt;byte&gt; packet)  Parameters​ Type\tName\tDescriptionSystem.ArraySegment&lt;System.Byte&gt;\tpacket\t Returns​ Type\tDescriptionMirage.SocketLayer.INotifyToken\t SendNotify(Byte[])​ Declaration​ public INotifyToken SendNotify(byte[] packet)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tpacket\t Returns​ Type\tDescriptionMirage.SocketLayer.INotifyToken\t SendNotify(Byte[], Int32, Int32, INotifyCallBack)​ Declaration​ public void SendNotify(byte[] packet, int offset, int length, INotifyCallBack callBacks)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tpacket System.Int32\toffset System.Int32\tlength Mirage.SocketLayer.INotifyCallBack\tcallBacks\t SendNotify(ArraySegment&lt;Byte&gt;, INotifyCallBack)​ Declaration​ public void SendNotify(ArraySegment&lt;byte&gt; packet, INotifyCallBack callBacks)  Parameters​ Type\tName\tDescriptionSystem.ArraySegment&lt;System.Byte&gt;\tpacket Mirage.SocketLayer.INotifyCallBack\tcallBacks\t SendNotify(Byte[], INotifyCallBack)​ Declaration​ public void SendNotify(byte[] packet, INotifyCallBack callBacks)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tpacket Mirage.SocketLayer.INotifyCallBack\tcallBacks\t SendReliable(Byte[], Int32, Int32)​ Declaration​ public void SendReliable(byte[] message, int offset, int length)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tmessage System.Int32\toffset System.Int32\tlength\t SendReliable(ArraySegment&lt;Byte&gt;)​ Declaration​ public void SendReliable(ArraySegment&lt;byte&gt; message)  Parameters​ Type\tName\tDescriptionSystem.ArraySegment&lt;System.Byte&gt;\tmessage\t SendReliable(Byte[])​ Declaration​ public void SendReliable(byte[] message)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tmessage\t SendUnreliable(Byte[], Int32, Int32)​ Declaration​ public void SendUnreliable(byte[] packet, int offset, int length)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tpacket System.Int32\toffset System.Int32\tlength\t SendUnreliable(ArraySegment&lt;Byte&gt;)​ Declaration​ public void SendUnreliable(ArraySegment&lt;byte&gt; packet)  Parameters​ Type\tName\tDescriptionSystem.ArraySegment&lt;System.Byte&gt;\tpacket\t SendUnreliable(Byte[])​ Declaration​ public void SendUnreliable(byte[] packet)  Parameters​ Type\tName\tDescriptionSystem.Byte[]\tpacket\t "},{"title":"Struct PipePeerConnection.PipeNotifyToken","type":0,"sectionRef":"#","url":"docs/reference/Mirage/PipePeerConnection.PipeNotifyToken","content":"Struct PipePeerConnection.PipeNotifyToken Token that invokes immediately Syntax​ public struct PipeNotifyToken : INotifyToken ","keywords":""},{"title":"Class PlayerSceneChangeEvent","type":0,"sectionRef":"#","url":"docs/reference/Mirage/PlayerSceneChangeEvent","content":"Class PlayerSceneChangeEvent Inheritance​ System.Object Syntax​ [Serializable] public class PlayerSceneChangeEvent : UnityEvent&lt;INetworkPlayer&gt; ","keywords":""},{"title":"Class ReadOnlyInspectorAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage/ReadOnlyInspectorAttribute","content":"Class ReadOnlyInspectorAttribute Makes field readonly in inspector. This is useful for fields that are set by code, but are shown iin inpector for debuggiing Inheritance​ System.Object Syntax​ [AttributeUsage(AttributeTargets.Field)] public sealed class ReadOnlyInspectorAttribute : PropertyAttribute ","keywords":""},{"title":"Struct RemoveAuthorityMessage","type":0,"sectionRef":"#","url":"docs/reference/Mirage/RemoveAuthorityMessage","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Struct RemoveAuthorityMessage","url":"docs/reference/Mirage/RemoveAuthorityMessage#fields","content":"netId​ Declaration​ public uint netId  "},{"title":"Struct RemoveCharacterMessage","type":0,"sectionRef":"#","url":"docs/reference/Mirage/RemoveCharacterMessage","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Struct RemoveCharacterMessage","url":"docs/reference/Mirage/RemoveCharacterMessage#fields","content":"keepAuthority​ Declaration​ public bool keepAuthority  "},{"title":"Struct RpcMessage","type":0,"sectionRef":"#","url":"docs/reference/Mirage/RpcMessage","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Struct RpcMessage","url":"docs/reference/Mirage/RpcMessage#fields","content":"netId​ Declaration​ public uint netId  componentIndex​ Declaration​ public int componentIndex  functionIndex​ Declaration​ public int functionIndex  payload​ Declaration​ public ArraySegment&lt;byte&gt; payload  "},{"title":"Enum RpcTarget","type":0,"sectionRef":"#","url":"docs/reference/Mirage/RpcTarget","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Enum RpcTarget","url":"docs/reference/Mirage/RpcTarget#fields","content":"Owner​ Sends to the that owns the object Declaration​ Owner = 0  Observers​ Sends to all that can see the object Declaration​ Observers = 1  Player​ Sends to the that is given as an argument in the RPC function (requires target to be an observer) Declaration​ Player = 2  "},{"title":"Class SceneAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage/SceneAttribute","content":"Class SceneAttribute Converts a string property into a Scene property in the inspector Inheritance​ System.Object Syntax​ public sealed class SceneAttribute : PropertyAttribute ","keywords":""},{"title":"Class SceneChangeFinishedEvent","type":0,"sectionRef":"#","url":"docs/reference/Mirage/SceneChangeFinishedEvent","content":"Class SceneChangeFinishedEvent Event fires from INetworkSceneManager when a scene change finishes on either Server or Client. Scene - Loaded scene SceneOperation - Scene change type (Normal, Additive Load, Additive Unload). Inheritance​ System.Object Syntax​ [Serializable] public class SceneChangeFinishedEvent : UnityEvent&lt;Scene, SceneOperation&gt; ","keywords":""},{"title":"Class SceneChangeStartedEvent","type":0,"sectionRef":"#","url":"docs/reference/Mirage/SceneChangeStartedEvent","content":"Class SceneChangeStartedEvent Event fires from INetworkSceneManager when a scene change begins on either Server or Client. Scene - Name or path of the scene that's about to be loaded SceneOperation - Scene change type (Normal, Additive Load, Additive Unload). Inheritance​ System.Object Syntax​ [Serializable] public class SceneChangeStartedEvent : UnityEvent&lt;string, SceneOperation&gt; ","keywords":""},{"title":"Struct SceneMessage","type":0,"sectionRef":"#","url":"docs/reference/Mirage/SceneMessage","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Struct SceneMessage","url":"docs/reference/Mirage/SceneMessage#fields","content":"MainActivateScene​ Declaration​ public string MainActivateScene  SceneOperation​ Declaration​ public SceneOperation SceneOperation  AdditiveScenes​ Declaration​ public List&lt;string&gt; AdditiveScenes  "},{"title":"Enum SceneOperation","type":0,"sectionRef":"#","url":"docs/reference/Mirage/SceneOperation","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Enum SceneOperation","url":"docs/reference/Mirage/SceneOperation#fields","content":"Normal​ Declaration​ Normal = 0  LoadAdditive​ Declaration​ LoadAdditive = 1  UnloadAdditive​ Declaration​ UnloadAdditive = 2  "},{"title":"Struct SceneNotReadyMessage","type":0,"sectionRef":"#","url":"docs/reference/Mirage/SceneNotReadyMessage","content":"Struct SceneNotReadyMessage Sent to client to mark their scene as not ready Client can sent once its scene is ready again Syntax​ public struct SceneNotReadyMessage ","keywords":""},{"title":"Struct SceneReadyMessage","type":0,"sectionRef":"#","url":"docs/reference/Mirage/SceneReadyMessage","content":"Struct SceneReadyMessage Sent to indicate the scene is finished loading Syntax​ public struct SceneReadyMessage ","keywords":""},{"title":"Class SceneVisibilityChecker","type":0,"sectionRef":"#","url":"docs/reference/Mirage/SceneVisibilityChecker","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class SceneVisibilityChecker","url":"docs/reference/Mirage/SceneVisibilityChecker#methods","content":"OnCheckObserver(INetworkPlayer)​ Declaration​ public override bool OnCheckObserver(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\t Returns​ Type\tDescriptionSystem.Boolean\t OnRebuildObservers(HashSet&lt;INetworkPlayer&gt;, Boolean)​ Declaration​ public override void OnRebuildObservers(HashSet&lt;INetworkPlayer&gt; observers, bool initialize)  Parameters​ Type\tName\tDescriptionSystem.Collections.Generic.HashSet&lt;Mirage.INetworkPlayer&gt;\tobservers System.Boolean\tinitialize\t MoveToScene(Scene)​ Call this function on an object to move it to a new scene and rebuild its observers Declaration​ public void MoveToScene(Scene scene)  Parameters​ Type\tName\tDescriptionScene\tscene\t "},{"title":"Class ServerAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage/ServerAttribute","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class ServerAttribute","url":"docs/reference/Mirage/ServerAttribute#fields","content":"error​ If true, when the method is called from a client, it throws an error If false, no error is thrown, but the method won't execute useful for unity built in methods such as Await, Update, Start, etc. Declaration​ public bool error  "},{"title":"Class ServerRpcAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage/ServerRpcAttribute","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class ServerRpcAttribute","url":"docs/reference/Mirage/ServerRpcAttribute#fields","content":"channel​ Declaration​ public int channel  requireAuthority​ Declaration​ public bool requireAuthority  "},{"title":"Class ServerObjectManager","type":0,"sectionRef":"#","url":"docs/reference/Mirage/ServerObjectManager","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class ServerObjectManager","url":"docs/reference/Mirage/ServerObjectManager#fields","content":"Server​ Declaration​ public NetworkServer Server  NetworkSceneManager​ Declaration​ public NetworkSceneManager NetworkSceneManager  OnlySpawnOnAuthenticated​ Declaration​ public bool OnlySpawnOnAuthenticated  NetIdGenerator​ Declaration​ public INetIdGenerator NetIdGenerator  "},{"title":"Methods​","type":1,"pageTitle":"Class ServerObjectManager","url":"docs/reference/Mirage/ServerObjectManager#methods","content":"Start()​ Declaration​ public void Start()  ReplaceCharacter(INetworkPlayer, GameObject, Int32, Boolean)​ This replaces the player object for a connection with a different player object. The old player object is not destroyed. If a connection already has a player object, this can be used to replace that object with a different player object. This does NOT change the ready state of the connection, so it can safely be used while changing scenes. Declaration​ public void ReplaceCharacter(INetworkPlayer player, GameObject character, int prefabHash, bool keepAuthority = false)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tConnection which is adding the player. GameObject\tcharacter\tPlayer object spawned for the player. System.Int32\tprefabHash System.Boolean\tkeepAuthority\tDoes the previous player remain attached to this connection? ReplaceCharacter(INetworkPlayer, NetworkIdentity, Int32, Boolean)​ This replaces the player object for a connection with a different player object. The old player object is not destroyed. If a connection already has a player object, this can be used to replace that object with a different player object. This does NOT change the ready state of the connection, so it can safely be used while changing scenes. Declaration​ public void ReplaceCharacter(INetworkPlayer player, NetworkIdentity character, int prefabHash, bool keepAuthority = false)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tConnection which is adding the player. Mirage.NetworkIdentity\tcharacter\tPlayer object spawned for the player. System.Int32\tprefabHash System.Boolean\tkeepAuthority\tDoes the previous player remain attached to this connection? ReplaceCharacter(INetworkPlayer, GameObject, Boolean)​ This replaces the player object for a connection with a different player object. The old player object is not destroyed. If a connection already has a player object, this can be used to replace that object with a different player object. This does NOT change the ready state of the connection, so it can safely be used while changing scenes. Declaration​ public void ReplaceCharacter(INetworkPlayer player, GameObject character, bool keepAuthority = false)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tConnection which is adding the player. GameObject\tcharacter\tPlayer object spawned for the player. System.Boolean\tkeepAuthority\tDoes the previous player remain attached to this connection? ReplaceCharacter(INetworkPlayer, NetworkIdentity, Boolean)​ This replaces the player object for a connection with a different player object. The old player object is not destroyed. If a connection already has a player object, this can be used to replace that object with a different player object. This does NOT change the ready state of the connection, so it can safely be used while changing scenes. Declaration​ public void ReplaceCharacter(INetworkPlayer player, NetworkIdentity identity, bool keepAuthority = false)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tConnection which is adding the player. Mirage.NetworkIdentity\tidentity\tPlayer object spawned for the player. System.Boolean\tkeepAuthority\tDoes the previous player remain attached to this connection? AddCharacter(INetworkPlayer, GameObject, Int32)​ When is received from a player, the server calls this to associate the character GameObject with the NetworkPlayer. When a character is added for a player the object is automatically spawned, so you do not need to call ServerObjectManager.Spawn for that object. This function is used for adding a character, not replacing. If there is already a character then use instead. Declaration​ public void AddCharacter(INetworkPlayer player, GameObject character, int prefabHash)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tthe Player to add the character to GameObject\tcharacter\tThe Network Object to add to the Player. Can be spawned or unspawned. Calling this method will respawn it. System.Int32\tprefabHash\tNew prefab hash to give to the player, used for dynamically creating objects at runtime. AddCharacter(INetworkPlayer, NetworkIdentity, Int32)​ When is received from a player, the server calls this to associate the character GameObject with the NetworkPlayer. When a character is added for a player the object is automatically spawned, so you do not need to call ServerObjectManager.Spawn for that object. This function is used for adding a character, not replacing. If there is already a character then use instead. Declaration​ public void AddCharacter(INetworkPlayer player, NetworkIdentity character, int prefabHash)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tthe Player to add the character to Mirage.NetworkIdentity\tcharacter\tThe Network Object to add to the Player. Can be spawned or unspawned. Calling this method will respawn it. System.Int32\tprefabHash\tNew prefab hash to give to the player, used for dynamically creating objects at runtime. AddCharacter(INetworkPlayer, GameObject)​ When is received from a player, the server calls this to associate the character GameObject with the NetworkPlayer. When a character is added for a player the object is automatically spawned, so you do not need to call ServerObjectManager.Spawn for that object. This function is used for adding a character, not replacing. If there is already a character then use instead. Declaration​ public void AddCharacter(INetworkPlayer player, GameObject character)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tthe Player to add the character to GameObject\tcharacter\tThe Network Object to add to the Player. Can be spawned or unspawned. Calling this method will respawn it. AddCharacter(INetworkPlayer, NetworkIdentity)​ When is received from a player, the server calls this to associate the character GameObject with the NetworkPlayer. When a character is added for a player the object is automatically spawned, so you do not need to call ServerObjectManager.Spawn for that object. This function is used for adding a character, not replacing. If there is already a character then use instead. Declaration​ public void AddCharacter(INetworkPlayer player, NetworkIdentity identity)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tthe Player to add the character to Mirage.NetworkIdentity\tidentity\t RemoveCharacter(INetworkPlayer, Boolean)​ Removes the character from a player, with the option to keep the player as the owner of the object Declaration​ public void RemoveCharacter(INetworkPlayer player, bool keepAuthority = false)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer System.Boolean\tkeepAuthority\t DestroyCharacter(INetworkPlayer, Boolean)​ Removes and destroys the character from a player Declaration​ public void DestroyCharacter(INetworkPlayer player, bool destroyServerObject = true)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer System.Boolean\tdestroyServerObject\t Spawn(GameObject, GameObject)​ Spawns the identity and settings its owner to the player that owns ownerObject Declaration​ public void Spawn(GameObject obj, GameObject ownerObject)  Parameters​ Type\tName\tDescriptionGameObject\tobj GameObject\townerObject\tAn object owned by a player Spawn(GameObject, Int32, INetworkPlayer)​ Assigns prefabHash to the obj and then spawns it with owner can only be set on an identity if the current value is Empty This method is useful if you are creating network objects at runtime and both server and client know what to set on an object  Declaration​ public void Spawn(GameObject obj, int prefabHash, INetworkPlayer owner = null)  Parameters​ Type\tName\tDescriptionGameObject\tobj\tThe object to spawn. System.Int32\tprefabHash\tThe prefabHash of the object to spawn. Used for custom spawn handlers. Mirage.INetworkPlayer\towner\tThe connection that has authority over the object Spawn(GameObject, INetworkPlayer)​ Spawns the identity and settings its owner to owner Declaration​ public void Spawn(GameObject obj, INetworkPlayer owner = null)  Parameters​ Type\tName\tDescriptionGameObject\tobj Mirage.INetworkPlayer\towner\t Spawn(NetworkIdentity, Int32, INetworkPlayer)​ Assigns prefabHash to the identity and then spawns it with owner can only be set on an identity if the current value is Empty This method is useful if you are creating network objects at runtime and both server and client know what to set on an object  Declaration​ public void Spawn(NetworkIdentity identity, int prefabHash, INetworkPlayer owner = null)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tidentity System.Int32\tprefabHash\tThe prefabHash of the object to spawn. Used for custom spawn handlers. Mirage.INetworkPlayer\towner\tThe connection that has authority over the object Spawn(NetworkIdentity)​ Spawns the identity and keeping owner as Declaration​ public void Spawn(NetworkIdentity identity)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tidentity\t Spawn(NetworkIdentity, INetworkPlayer)​ Spawns the identity and assigns owner to be it's owner Declaration​ public void Spawn(NetworkIdentity identity, INetworkPlayer owner)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tidentity Mirage.INetworkPlayer\towner\t Destroy(GameObject, Boolean)​ Destroys this object and corresponding objects on all clients. Game object to destroy. Sets if server object will also be destroyed Declaration​ public void Destroy(GameObject gameObject, bool destroyServerObject = true)  Parameters​ Type\tName\tDescriptionGameObject\tgameObject System.Boolean\tdestroyServerObject\t Destroy(NetworkIdentity, Boolean)​ Destroys this object and corresponding objects on all clients. Game object to destroy. Sets if server object will also be destroyed Declaration​ public void Destroy(NetworkIdentity identity, bool destroyServerObject = true)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tidentity System.Boolean\tdestroyServerObject\t SpawnObjects()​ This causes NetworkIdentity objects in a scene to be spawned on a server. Calling SpawnObjects() causes all scene objects to be spawned. It is like calling Spawn() for each of them.  Declaration​ public void SpawnObjects()  SpawnVisibleObjects(INetworkPlayer)​ Sends spawn message for scene objects and other visible objects to the given player if it has a character If there is a then this will be called after the client finishes loading the scene and sends Declaration​ public void SpawnVisibleObjects(INetworkPlayer player)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tThe player to spawn objects for SpawnVisibleObjects(INetworkPlayer, Boolean)​ Sends spawn message for scene objects and other visible objects to the given player if it has a character Declaration​ public void SpawnVisibleObjects(INetworkPlayer player, bool ignoreHasCharacter)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tThe player to spawn objects for System.Boolean\tignoreHasCharacter\tIf true will spawn visibile objects even if player does not have a spawned character yet SpawnVisibleObjects(INetworkPlayer, NetworkIdentity)​ Sends spawn message for scene objects and other visible objects to the given player if it has a character Declaration​ public void SpawnVisibleObjects(INetworkPlayer player, NetworkIdentity skip)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tThe player to spawn objects for Mirage.NetworkIdentity\tskip\t SpawnVisibleObjects(INetworkPlayer, Boolean, NetworkIdentity)​ Sends spawn message for scene objects and other visible objects to the given player if it has a character Declaration​ public void SpawnVisibleObjects(INetworkPlayer player, bool ignoreHasCharacter, NetworkIdentity skip)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tThe player to spawn objects for System.Boolean\tignoreHasCharacter\tIf true will spawn visibile objects even if player does not have a spawned character yet Mirage.NetworkIdentity\tskip\tNetworkIdentity to skip when spawning. Can be null SpawnVisibleObjects(INetworkPlayer, Boolean, HashSet&lt;NetworkIdentity&gt;)​ Sends spawn message for scene objects and other visible objects to the given player if it has a character Declaration​ public void SpawnVisibleObjects(INetworkPlayer player, bool ignoreHasCharacter, HashSet&lt;NetworkIdentity&gt; skip)  Parameters​ Type\tName\tDescriptionMirage.INetworkPlayer\tplayer\tThe player to spawn objects for System.Boolean\tignoreHasCharacter\tIf true will spawn visibile objects even if player does not have a spawned character yet System.Collections.Generic.HashSet&lt;Mirage.NetworkIdentity&gt;\tskip\tNetworkIdentity to skip when spawning. Can be null "},{"title":"Struct ServerRpcMessage","type":0,"sectionRef":"#","url":"docs/reference/Mirage/ServerRpcMessage","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Struct ServerRpcMessage","url":"docs/reference/Mirage/ServerRpcMessage#fields","content":"netId​ Declaration​ public uint netId  componentIndex​ Declaration​ public int componentIndex  functionIndex​ Declaration​ public int functionIndex  payload​ Declaration​ public ArraySegment&lt;byte&gt; payload  "},{"title":"Struct ServerRpcReply","type":0,"sectionRef":"#","url":"docs/reference/Mirage/ServerRpcReply","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Struct ServerRpcReply","url":"docs/reference/Mirage/ServerRpcReply#fields","content":"replyId​ Declaration​ public int replyId  payload​ Declaration​ public ArraySegment&lt;byte&gt; payload  "},{"title":"Struct ServerRpcWithReplyMessage","type":0,"sectionRef":"#","url":"docs/reference/Mirage/ServerRpcWithReplyMessage","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Struct ServerRpcWithReplyMessage","url":"docs/reference/Mirage/ServerRpcWithReplyMessage#fields","content":"netId​ Declaration​ public uint netId  componentIndex​ Declaration​ public int componentIndex  functionIndex​ Declaration​ public int functionIndex  replyId​ Declaration​ public int replyId  payload​ Declaration​ public ArraySegment&lt;byte&gt; payload  "},{"title":"Class ShowInInspectorAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage/ShowInInspectorAttribute","content":"Class ShowInInspectorAttribute Used to show private SyncList in the inspector, Use instead of SerializeField for non Serializable types Inheritance​ System.Object System.Attribute Inherited Members​ Show Syntax​ [AttributeUsage(AttributeTargets.Field)] public sealed class ShowInInspectorAttribute : Attribute, _Attribute ","keywords":""},{"title":"Class SpawnEvent","type":0,"sectionRef":"#","url":"docs/reference/Mirage/SpawnEvent","content":"Class SpawnEvent Inheritance​ System.Object Syntax​ [Serializable] public class SpawnEvent : UnityEvent&lt;NetworkIdentity&gt; ","keywords":""},{"title":"Delegate SpawnHandlerAsyncDelegate","type":0,"sectionRef":"#","url":"docs/reference/Mirage/SpawnHandlerAsyncDelegate","content":"Delegate SpawnHandlerAsyncDelegate Syntax​ public delegate UniTask&lt;NetworkIdentity&gt; SpawnHandlerAsyncDelegate(SpawnMessage msg); ","keywords":""},{"title":"Class SpawnHandler","type":0,"sectionRef":"#","url":"docs/reference/Mirage/SpawnHandler","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class SpawnHandler","url":"docs/reference/Mirage/SpawnHandler#constructors","content":"SpawnHandler(NetworkIdentity)​ Declaration​ public SpawnHandler(NetworkIdentity prefab)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tprefab\t SpawnHandler(SpawnHandlerDelegate, UnSpawnDelegate)​ Declaration​ public SpawnHandler(SpawnHandlerDelegate spawnHandler, UnSpawnDelegate unspawnHandler)  Parameters​ Type\tName\tDescriptionMirage.SpawnHandlerDelegate\tspawnHandler Mirage.UnSpawnDelegate\tunspawnHandler\t SpawnHandler(SpawnHandlerAsyncDelegate, UnSpawnDelegate)​ Declaration​ public SpawnHandler(SpawnHandlerAsyncDelegate spawnHandlerAsync, UnSpawnDelegate unspawnHandler)  Parameters​ Type\tName\tDescriptionMirage.SpawnHandlerAsyncDelegate\tspawnHandlerAsync Mirage.UnSpawnDelegate\tunspawnHandler\t "},{"title":"Fields​","type":1,"pageTitle":"Class SpawnHandler","url":"docs/reference/Mirage/SpawnHandler#fields","content":"Prefab​ Declaration​ public readonly NetworkIdentity Prefab  Handler​ Declaration​ public readonly SpawnHandlerDelegate Handler  HandlerAsync​ Declaration​ public readonly SpawnHandlerAsyncDelegate HandlerAsync  "},{"title":"Properties​","type":1,"pageTitle":"Class SpawnHandler","url":"docs/reference/Mirage/SpawnHandler#properties","content":"UnspawnHandler​ Declaration​ public UnSpawnDelegate UnspawnHandler { get; }  "},{"title":"Methods​","type":1,"pageTitle":"Class SpawnHandler","url":"docs/reference/Mirage/SpawnHandler#methods","content":"AddUnspawnHandler(UnSpawnDelegate)​ Declaration​ public void AddUnspawnHandler(UnSpawnDelegate unspawnHandler)  Parameters​ Type\tName\tDescriptionMirage.UnSpawnDelegate\tunspawnHandler\t IsAsyncSpawn()​ Declaration​ public bool IsAsyncSpawn()  Returns​ Type\tDescriptionSystem.Boolean\t "},{"title":"Delegate SpawnHandlerDelegate","type":0,"sectionRef":"#","url":"docs/reference/Mirage/SpawnHandlerDelegate","content":"Delegate SpawnHandlerDelegate Syntax​ public delegate NetworkIdentity SpawnHandlerDelegate(SpawnMessage msg); ","keywords":""},{"title":"Struct SpawnMessage","type":0,"sectionRef":"#","url":"docs/reference/Mirage/SpawnMessage","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Struct SpawnMessage","url":"docs/reference/Mirage/SpawnMessage#fields","content":"netId​ netId of new or existing object Declaration​ public uint netId  isLocalPlayer​ Is the spawning object the local player. Sets ClientScene.localPlayer Declaration​ public bool isLocalPlayer  isOwner​ Sets hasAuthority on the spawned object Declaration​ public bool isOwner  sceneId​ The id of the scene object to spawn Declaration​ public ulong? sceneId  prefabHash​ The id of the prefab to spawn If sceneId != 0 then it is used instead of prefabHash Declaration​ public int? prefabHash  position​ Local position Declaration​ public Vector3? position  rotation​ Local rotation Declaration​ public Quaternion? rotation  scale​ Local scale Declaration​ public Vector3? scale  payload​ The serialized component data ArraySegment to avoid unnecessary allocations Declaration​ public ArraySegment&lt;byte&gt; payload  "},{"title":"Class SpawnObjectException","type":0,"sectionRef":"#","url":"docs/reference/Mirage/SpawnObjectException","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class SpawnObjectException","url":"docs/reference/Mirage/SpawnObjectException#constructors","content":"SpawnObjectException(String)​ Declaration​ public SpawnObjectException(string message)  Parameters​ Type\tName\tDescriptionSystem.String\tmessage\t "},{"title":"Enum SyncHookType","type":0,"sectionRef":"#","url":"docs/reference/Mirage/SyncHookType","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Enum SyncHookType","url":"docs/reference/Mirage/SyncHookType#fields","content":"Automatic​ Looks for hooks matching the signature, gives compile error if none or more than 1 is found Declaration​ Automatic = 0  MethodWith1Arg​ Hook with signature void hookName(T newValue) Declaration​ MethodWith1Arg = 1  MethodWith2Arg​ Hook with signature void hookName(T oldValue, T newValue) Declaration​ MethodWith2Arg = 2  EventWith1Arg​ Hook with signature event Action{T} hookName; Declaration​ EventWith1Arg = 3  EventWith2Arg​ Hook with signature event Action{T,T} hookName; Declaration​ EventWith2Arg = 4  "},{"title":"Class StringHash","type":0,"sectionRef":"#","url":"docs/reference/Mirage/StringHash","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class StringHash","url":"docs/reference/Mirage/StringHash#fields","content":"EmptyString​ Declaration​ public const int EmptyString = 23  "},{"title":"Methods​","type":1,"pageTitle":"Class StringHash","url":"docs/reference/Mirage/StringHash#methods","content":"GetStableHashCode(String)​ Gets a hash for a string. This hash will be the same on all platforms Declaration​ public static int GetStableHashCode(this string text)  Parameters​ Type\tName\tDescriptionSystem.String\ttext\t Returns​ Type\tDescriptionSystem.Int32\t "},{"title":"Enum SyncMode","type":0,"sectionRef":"#","url":"docs/reference/Mirage/SyncMode","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Enum SyncMode","url":"docs/reference/Mirage/SyncMode#fields","content":"Observers​ Declaration​ Observers = 0  Owner​ Declaration​ Owner = 1  "},{"title":"Class SyncVarAttribute","type":0,"sectionRef":"#","url":"docs/reference/Mirage/SyncVarAttribute","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class SyncVarAttribute","url":"docs/reference/Mirage/SyncVarAttribute#fields","content":"hook​ A function that should be called on the client when the value changes. Declaration​ public string hook  initialOnly​ If true, this syncvar will only be sent with spawn message, any other changes will not be sent to existing objects Declaration​ public bool initialOnly  invokeHookOnServer​ If true this syncvar hook will also fire on the server side. Declaration​ public bool invokeHookOnServer  hookType​ What type of look Mirage should look for Declaration​ public SyncHookType hookType  "},{"title":"Class SyncVarReceiver","type":0,"sectionRef":"#","url":"docs/reference/Mirage/SyncVarReceiver","content":"","keywords":""},{"title":"Constructors​","type":1,"pageTitle":"Class SyncVarReceiver","url":"docs/reference/Mirage/SyncVarReceiver#constructors","content":"SyncVarReceiver(NetworkClient, IObjectLocator)​ Declaration​ public SyncVarReceiver(NetworkClient client, IObjectLocator objectLocator)  Parameters​ Type\tName\tDescriptionMirage.NetworkClient\tclient Mirage.IObjectLocator\tobjectLocator\t "},{"title":"Class SyncVarSender","type":0,"sectionRef":"#","url":"docs/reference/Mirage/SyncVarSender","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"Class SyncVarSender","url":"docs/reference/Mirage/SyncVarSender#methods","content":"AddDirtyObject(NetworkIdentity)​ Declaration​ public void AddDirtyObject(NetworkIdentity dirty)  Parameters​ Type\tName\tDescriptionMirage.NetworkIdentity\tdirty\t "},{"title":"Delegate UnSpawnDelegate","type":0,"sectionRef":"#","url":"docs/reference/Mirage/UnSpawnDelegate","content":"Delegate UnSpawnDelegate Syntax​ public delegate void UnSpawnDelegate(NetworkIdentity spawned); ","keywords":""},{"title":"Struct UpdateVarsMessage","type":0,"sectionRef":"#","url":"docs/reference/Mirage/UpdateVarsMessage","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Struct UpdateVarsMessage","url":"docs/reference/Mirage/UpdateVarsMessage#fields","content":"netId​ Declaration​ public uint netId  payload​ Declaration​ public ArraySegment&lt;byte&gt; payload  "},{"title":"Class Version","type":0,"sectionRef":"#","url":"docs/reference/Mirage/Version","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class Version","url":"docs/reference/Mirage/Version#fields","content":"Current​ Declaration​ public static readonly string Current  "},{"title":"NanoSockets","type":0,"sectionRef":"#","url":"docs/reference/NanoSockets/","content":"","keywords":""},{"title":"Classes​","type":1,"pageTitle":"NanoSockets","url":"docs/reference/NanoSockets/#classes","content":"UDP​ "},{"title":"Structs​","type":1,"pageTitle":"NanoSockets","url":"docs/reference/NanoSockets/#structs","content":"Address​ Socket​ "},{"title":"Enums​","type":1,"pageTitle":"NanoSockets","url":"docs/reference/NanoSockets/#enums","content":"Status​ "},{"title":"Struct Socket","type":0,"sectionRef":"#","url":"docs/reference/NanoSockets/Socket","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Struct Socket","url":"docs/reference/NanoSockets/Socket#properties","content":"IsCreated​ Declaration​ public bool IsCreated { get; }  "},{"title":"Struct Address","type":0,"sectionRef":"#","url":"docs/reference/NanoSockets/Address","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Struct Address","url":"docs/reference/NanoSockets/Address#fields","content":"port​ Declaration​ public ushort port  Port​ Declaration​ public ushort Port  "},{"title":"Methods​","type":1,"pageTitle":"Struct Address","url":"docs/reference/NanoSockets/Address#methods","content":"Equals(Address)​ Declaration​ public bool Equals(Address other)  Parameters​ Type\tName\tDescriptionNanoSockets.Address\tother\t Returns​ Type\tDescriptionSystem.Boolean\t Equals(Object)​ Declaration​ public override bool Equals(object obj)  Parameters​ Type\tName\tDescriptionSystem.Object\tobj\t Returns​ Type\tDescriptionSystem.Boolean\t GetHashCode()​ Declaration​ public override int GetHashCode()  Returns​ Type\tDescriptionSystem.Int32\t ToString()​ Declaration​ public override string ToString()  Returns​ Type\tDescriptionSystem.String\t CreateFromIpPort(String, UInt16)​ Declaration​ public static Address CreateFromIpPort(string ip, ushort port)  Parameters​ Type\tName\tDescriptionSystem.String\tip System.UInt16\tport\t Returns​ Type\tDescriptionNanoSockets.Address\t "},{"title":"Enum Status","type":0,"sectionRef":"#","url":"docs/reference/NanoSockets/Status","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Enum Status","url":"docs/reference/NanoSockets/Status#fields","content":"OK​ Declaration​ OK = 0  Error​ Declaration​ Error = -1  "},{"title":"Class UDP","type":0,"sectionRef":"#","url":"docs/reference/NanoSockets/UDP","content":"","keywords":""},{"title":"Fields​","type":1,"pageTitle":"Class UDP","url":"docs/reference/NanoSockets/UDP#fields","content":"hostNameSize​ Declaration​ public const int hostNameSize = 1025  "},{"title":"Methods​","type":1,"pageTitle":"Class UDP","url":"docs/reference/NanoSockets/UDP#methods","content":"Initialize()​ Declaration​ public static Status Initialize()  Returns​ Type\tDescriptionNanoSockets.Status\t Deinitialize()​ Declaration​ public static void Deinitialize()  Create(Int32, Int32)​ Declaration​ public static Socket Create(int sendBufferSize, int receiveBufferSize)  Parameters​ Type\tName\tDescriptionSystem.Int32\tsendBufferSize System.Int32\treceiveBufferSize\t Returns​ Type\tDescriptionNanoSockets.Socket\t Destroy(ref Socket)​ Declaration​ public static void Destroy(ref Socket socket)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket\t Bind(Socket, IntPtr)​ Declaration​ public static int Bind(Socket socket, IntPtr address)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket System.IntPtr\taddress\t Returns​ Type\tDescriptionSystem.Int32\t Bind(Socket, ref Address)​ Declaration​ public static int Bind(Socket socket, ref Address address)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket NanoSockets.Address\taddress\t Returns​ Type\tDescriptionSystem.Int32\t Connect(Socket, ref Address)​ Declaration​ public static int Connect(Socket socket, ref Address address)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket NanoSockets.Address\taddress\t Returns​ Type\tDescriptionSystem.Int32\t SetOption(Socket, Int32, Int32, ref Int32, Int32)​ Declaration​ public static Status SetOption(Socket socket, int level, int optionName, ref int optionValue, int optionLength)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket System.Int32\tlevel System.Int32\toptionName System.Int32\toptionValue System.Int32\toptionLength\t Returns​ Type\tDescriptionNanoSockets.Status\t GetOption(Socket, Int32, Int32, ref Int32, ref Int32)​ Declaration​ public static Status GetOption(Socket socket, int level, int optionName, ref int optionValue, ref int optionLength)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket System.Int32\tlevel System.Int32\toptionName System.Int32\toptionValue System.Int32\toptionLength\t Returns​ Type\tDescriptionNanoSockets.Status\t SetNonBlocking(Socket, Boolean)​ Declaration​ public static Status SetNonBlocking(Socket socket, bool shouldBlock = false)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket System.Boolean\tshouldBlock\t Returns​ Type\tDescriptionNanoSockets.Status\t SetDontFragment(Socket)​ Declaration​ public static Status SetDontFragment(Socket socket)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket\t Returns​ Type\tDescriptionNanoSockets.Status\t Poll(Socket, Int64)​ Declaration​ public static int Poll(Socket socket, long timeout)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket System.Int64\ttimeout\t Returns​ Type\tDescriptionSystem.Int32\t Send(Socket, IntPtr, IntPtr, Int32)​ Declaration​ public static int Send(Socket socket, IntPtr address, IntPtr buffer, int bufferLength)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket System.IntPtr\taddress System.IntPtr\tbuffer System.Int32\tbufferLength\t Returns​ Type\tDescriptionSystem.Int32\t Send(Socket, IntPtr, Byte[], Int32)​ Declaration​ public static int Send(Socket socket, IntPtr address, byte[] buffer, int bufferLength)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket System.IntPtr\taddress System.Byte[]\tbuffer System.Int32\tbufferLength\t Returns​ Type\tDescriptionSystem.Int32\t Send(Socket, ref Address, IntPtr, Int32)​ Declaration​ public static int Send(Socket socket, ref Address address, IntPtr buffer, int bufferLength)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket NanoSockets.Address\taddress System.IntPtr\tbuffer System.Int32\tbufferLength\t Returns​ Type\tDescriptionSystem.Int32\t Send(Socket, ref Address, Byte[], Int32)​ Declaration​ public static int Send(Socket socket, ref Address address, byte[] buffer, int bufferLength)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket NanoSockets.Address\taddress System.Byte[]\tbuffer System.Int32\tbufferLength\t Returns​ Type\tDescriptionSystem.Int32\t Send(Socket, IntPtr, Byte[], Int32, Int32)​ Declaration​ public static int Send(Socket socket, IntPtr address, byte[] buffer, int offset, int bufferLength)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket System.IntPtr\taddress System.Byte[]\tbuffer System.Int32\toffset System.Int32\tbufferLength\t Returns​ Type\tDescriptionSystem.Int32\t Send(Socket, ref Address, Byte[], Int32, Int32)​ Declaration​ public static int Send(Socket socket, ref Address address, byte[] buffer, int offset, int bufferLength)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket NanoSockets.Address\taddress System.Byte[]\tbuffer System.Int32\toffset System.Int32\tbufferLength\t Returns​ Type\tDescriptionSystem.Int32\t Receive(Socket, IntPtr, IntPtr, Int32)​ Declaration​ public static int Receive(Socket socket, IntPtr address, IntPtr buffer, int bufferLength)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket System.IntPtr\taddress System.IntPtr\tbuffer System.Int32\tbufferLength\t Returns​ Type\tDescriptionSystem.Int32\t Receive(Socket, IntPtr, Byte[], Int32)​ Declaration​ public static int Receive(Socket socket, IntPtr address, byte[] buffer, int bufferLength)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket System.IntPtr\taddress System.Byte[]\tbuffer System.Int32\tbufferLength\t Returns​ Type\tDescriptionSystem.Int32\t Receive(Socket, ref Address, IntPtr, Int32)​ Declaration​ public static int Receive(Socket socket, ref Address address, IntPtr buffer, int bufferLength)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket NanoSockets.Address\taddress System.IntPtr\tbuffer System.Int32\tbufferLength\t Returns​ Type\tDescriptionSystem.Int32\t Receive(Socket, ref Address, Byte[], Int32)​ Declaration​ public static int Receive(Socket socket, ref Address address, byte[] buffer, int bufferLength)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket NanoSockets.Address\taddress System.Byte[]\tbuffer System.Int32\tbufferLength\t Returns​ Type\tDescriptionSystem.Int32\t Receive(Socket, IntPtr, Byte[], Int32, Int32)​ Declaration​ public static int Receive(Socket socket, IntPtr address, byte[] buffer, int offset, int bufferLength)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket System.IntPtr\taddress System.Byte[]\tbuffer System.Int32\toffset System.Int32\tbufferLength\t Returns​ Type\tDescriptionSystem.Int32\t Receive(Socket, ref Address, Byte[], Int32, Int32)​ Declaration​ public static int Receive(Socket socket, ref Address address, byte[] buffer, int offset, int bufferLength)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket NanoSockets.Address\taddress System.Byte[]\tbuffer System.Int32\toffset System.Int32\tbufferLength\t Returns​ Type\tDescriptionSystem.Int32\t GetAddress(Socket, ref Address)​ Declaration​ public static Status GetAddress(Socket socket, ref Address address)  Parameters​ Type\tName\tDescriptionNanoSockets.Socket\tsocket NanoSockets.Address\taddress\t Returns​ Type\tDescriptionNanoSockets.Status\t IsEqual(ref Address, ref Address)​ Declaration​ public static Status IsEqual(ref Address left, ref Address right)  Parameters​ Type\tName\tDescriptionNanoSockets.Address\tleft NanoSockets.Address\tright\t Returns​ Type\tDescriptionNanoSockets.Status\t SetIP(ref Address, IntPtr)​ Declaration​ public static Status SetIP(ref Address address, IntPtr ip)  Parameters​ Type\tName\tDescriptionNanoSockets.Address\taddress System.IntPtr\tip\t Returns​ Type\tDescriptionNanoSockets.Status\t SetIP(ref Address, String)​ Declaration​ public static Status SetIP(ref Address address, string ip)  Parameters​ Type\tName\tDescriptionNanoSockets.Address\taddress System.String\tip\t Returns​ Type\tDescriptionNanoSockets.Status\t GetIP(ref Address, IntPtr, Int32)​ Declaration​ public static Status GetIP(ref Address address, IntPtr ip, int ipLength)  Parameters​ Type\tName\tDescriptionNanoSockets.Address\taddress System.IntPtr\tip System.Int32\tipLength\t Returns​ Type\tDescriptionNanoSockets.Status\t GetIP(ref Address, StringBuilder, Int32)​ Declaration​ public static Status GetIP(ref Address address, StringBuilder ip, int ipLength)  Parameters​ Type\tName\tDescriptionNanoSockets.Address\taddress System.Text.StringBuilder\tip System.Int32\tipLength\t Returns​ Type\tDescriptionNanoSockets.Status\t SetHostName(ref Address, IntPtr)​ Declaration​ public static Status SetHostName(ref Address address, IntPtr name)  Parameters​ Type\tName\tDescriptionNanoSockets.Address\taddress System.IntPtr\tname\t Returns​ Type\tDescriptionNanoSockets.Status\t SetHostName(ref Address, String)​ Declaration​ public static Status SetHostName(ref Address address, string name)  Parameters​ Type\tName\tDescriptionNanoSockets.Address\taddress System.String\tname\t Returns​ Type\tDescriptionNanoSockets.Status\t GetHostName(ref Address, IntPtr, Int32)​ Declaration​ public static Status GetHostName(ref Address address, IntPtr name, int nameLength)  Parameters​ Type\tName\tDescriptionNanoSockets.Address\taddress System.IntPtr\tname System.Int32\tnameLength\t Returns​ Type\tDescriptionNanoSockets.Status\t GetHostName(ref Address, StringBuilder, Int32)​ Declaration​ public static Status GetHostName(ref Address address, StringBuilder name, int nameLength)  Parameters​ Type\tName\tDescriptionNanoSockets.Address\taddress System.Text.StringBuilder\tname System.Int32\tnameLength\t Returns​ Type\tDescriptionNanoSockets.Status\t "}]